{
  "anthropic/claude-3-7-sonnet-20250219": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:40:41.148921",
      "duration": 7.233716249465942,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.embedded import EmbeddedOptions\n\n# Get environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_api_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not wcd_url or not wcd_api_key:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_wcs(\n    cluster_url=wcd_url,\n    auth_credentials=weaviate.auth.AuthApiKey(api_key=wcd_api_key),\n)\n\n# Check if the server is ready\nis_ready = client.is_ready()\nprint(f\"Weaviate server is ready: {is_ready}\")\n```\n\nThis code uses the latest Weaviate client syntax to connect to a Weaviate Cloud instance using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`. It then checks if the server is ready to accept requests using the `is_ready()` method and prints the result.",
      "stdout": "Weaviate server is ready: True\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:40:45.906298",
      "duration": 4.739451169967651,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\n\n# Get environment variables\ncluster_url = os.environ.get(\"WCD_TEST_URL\")\napi_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready()\n\n# Close the connection\nclient.close()\n```\n\nThis code:\n1. Imports the necessary modules\n2. Retrieves the Weaviate Cloud URL and API key from environment variables\n3. Connects to the Weaviate Cloud instance using the latest client syntax\n4. Verifies the server is ready to accept requests\n5. Closes the connection",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T20:40:55.341802",
      "duration": 9.417068719863892,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType, Configure\n\n# Get environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not weaviate_url or not weaviate_api_key:\n    raise ValueError(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables\")\n\n# Connect to Weaviate\nclient = weaviate.connect_to_wcs(\n    cluster_url=weaviate_url,\n    auth_credentials=weaviate.auth.AuthApiKey(weaviate_api_key),\n)\n\n# Collection name\ncollection_name = \"DemoProducts\"\n\n# Check if collection exists and delete it if it does\nif client.collections.exists(collection_name):\n    print(f\"Collection '{collection_name}' exists. Deleting it...\")\n    client.collections.delete(collection_name)\n    print(f\"Collection '{collection_name}' deleted.\")\n\n# Create the collection with properties\ncollection = client.collections.create(\n    name=collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n    ],\n    vectorizer_config=Configure.Vectorizer.none(),\n)\n\nprint(f\"Collection '{collection_name}' created successfully with the specified properties.\")\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Imports the necessary Weaviate modules\n2. Retrieves the Weaviate Cloud credentials from environment variables\n3. Connects to the Weaviate Cloud instance\n4. Checks if the \"DemoProducts\" collection exists and deletes it if it does\n5. Creates a new \"DemoProducts\" collection with the specified properties:\n   - name (text)\n   - description (text)\n   - price (number)\n   - in_stock (boolean)\n6. Uses the latest Weaviate client syntax with the Property and DataType classes\n7. Configures the collection with no vectorizer since none was specified\n8. Properly closes the client connection when done",
      "stdout": "Collection 'DemoProducts' exists. Deleting it...\nCollection 'DemoProducts' deleted.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 35, in <module>\n    Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n  File \"/usr/local/lib/python3.9/enum.py\", line 429, in __getattr__\n    raise AttributeError(name) from None\nAttributeError: BOOLEAN\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:41:00.618952",
      "duration": 5.257544994354248,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ.get(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.environ.get(\"WCD_TEST_KEY\"))\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n    print(f\"Deleted existing collection: {collection_name}\")\n\n# Create the collection with the specified properties\nproducts_collection = client.collections.create(\n    name=collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n```",
      "stdout": "Created collection: DemoProducts\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:41:08.595954",
      "duration": 7.95869517326355,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to create a \"DemoProducts\" collection with the specified properties using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\n# Check if collection exists and delete it if it does\nif client.collections.exists(\"DemoProducts\"):\n    client.collections.delete(\"DemoProducts\")\n\n# Create the DemoProducts collection with the specified properties\nclient.collections.create(\n    \"DemoProducts\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL)\n    ]\n)\n\n# Verify the collection was created\nif client.collections.exists(\"DemoProducts\"):\n    print(\"DemoProducts collection created successfully!\")\nelse:\n    print(\"Failed to create DemoProducts collection.\")\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the environment variables\n2. Checks if the \"DemoProducts\" collection already exists and deletes it if it does\n3. Creates a new \"DemoProducts\" collection with the specified properties\n4. Verifies the collection was created successfully\n5. Closes the client connection",
      "stdout": "DemoProducts collection created successfully!\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:41:17.991494",
      "duration": 8.32431697845459,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.classes.batch import Batch\n\n# Get environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate\nclient = weaviate.connect_to_wcs(\n    cluster_url=weaviate_url,\n    auth_credentials=weaviate.auth.AuthApiKey(weaviate_api_key),\n)\n\n# Check if collection exists, if not create it\nif not client.collections.exists(\"DemoProducts\"):\n    collection = client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ]\n    )\n    print(\"Collection 'DemoProducts' created\")\nelse:\n    collection = client.collections.get(\"DemoProducts\")\n    print(\"Collection 'DemoProducts' already exists\")\n\n# Batch import 50 objects\nwith collection.batch.dynamic() as batch:\n    for i in range(1, 51):\n        batch.add_object(\n            properties={\n                \"name\": f\"Product {i}\",\n                \"description\": f\"Description {i}\"\n            }\n        )\n\n# Print the number of objects in the collection\nobject_count = collection.aggregate.over_all().total_count\nprint(f\"Number of objects in the collection: {object_count}\")\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using environment variables\n2. Creates a \"DemoProducts\" collection with name and description properties if it doesn't exist\n3. Uses batch processing to efficiently add 50 sample products\n4. Queries the collection to get the total count of objects\n5. Properly closes the client connection\n\nThe code follows the latest Weaviate client syntax (v4+) with the new collection-based API.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 4, in <module>\n    from weaviate.classes.batch import Batch\nImportError: cannot import name 'Batch' from 'weaviate.classes.batch' (/usr/local/lib/python3.9/site-packages/weaviate/classes/batch.py)\n",
      "exit_code": 1
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T20:41:28.741033",
      "duration": 10.099881172180176,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.auth import Auth\n\n# Connect to Weaviate Cloud using environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=Auth.api_key(wcd_key),\n)\n\n# Check if collection exists, if not create it\nif \"DemoProducts\" not in client.collections.list_all():\n    collection = client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            {\n                \"name\": \"name\",\n                \"dataType\": [\"text\"]\n            },\n            {\n                \"name\": \"description\",\n                \"dataType\": [\"text\"]\n            }\n        ]\n    )\nelse:\n    collection = client.collections.get(\"DemoProducts\")\n\n# Prepare data for batch import\ndata_rows = [\n    {\n        \"name\": f\"Product {i+1}\",\n        \"description\": f\"Description for product {i+1}. This is a sample product.\"\n    } for i in range(50)\n]\n\n# Batch import objects\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\n# Check for failed objects\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\n# Print the number of objects in the collection\nprint(f\"Number of objects in the collection: {len(collection)}\")\n\n# Close the client\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using environment variables\n2. Creates the \"DemoProducts\" collection if it doesn't exist\n3. Prepares 50 sample product objects\n4. Batch imports the objects into the collection\n5. Checks for any failed imports\n6. Prints the total number of objects in the collection\n7. Closes the client connection\n\nThe collection has two text properties: \"name\" and \"description\" as requested.",
      "stdout": "Number of objects in the collection: 50\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:41:38.481117",
      "duration": 9.08914303779602,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to add objects to a \"DemoProducts\" collection using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\n# Check if collection exists and create it if it doesn't\nif not client.collections.exists(\"DemoProducts\"):\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ]\n    )\n\n# Get the collection\ncollection = client.collections.get(\"DemoProducts\")\n\n# Batch import 50 arbitrary objects\nwith collection.batch.fixed_size(batch_size=10) as batch:\n    for i in range(1, 51):\n        batch.add_object(\n            properties={\n                \"name\": f\"Product {i}\",\n                \"description\": f\"Description {i}\"\n            }\n        )\n\n# Print the number of objects in the collection\ncount = collection.query.fetch_objects(limit=0).total_count\nprint(f\"Number of objects in the DemoProducts collection: {count}\")\n\n# Close the client when done\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the environment variables\n2. Creates a \"DemoProducts\" collection if it doesn't exist\n3. Batch imports 50 simple product objects\n4. Prints the total count of objects in the collection\n5. Properly closes the client connection",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 36, in <module>\n    count = collection.query.fetch_objects(limit=0).total_count\nAttributeError: 'QueryReturn' object has no attribute 'total_count'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T20:41:50.417384",
      "duration": 11.097661018371582,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import QueryReference\nfrom weaviate.embedded import EmbeddedOptions\n\n# Get environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n\n# Initialize the Weaviate client\nclient = weaviate.connect_to_wcs(\n    cluster_url=weaviate_url,\n    auth_credentials=weaviate.auth.AuthApiKey(api_key=weaviate_api_key),\n    headers={\n        \"X-OpenAI-Api-Key\": openai_api_key\n    }\n)\n\n# Query the WineReview collection\nresponse = (\n    client.collections.get(\"WineReview\")\n    .query.near_text(\n        query=\"dessert wine\",\n        limit=2\n    )\n    .with_additional([\"distance\"])\n    .with_fields([\"title\", \"country\", \"price\", \"points\"])\n    .do()\n)\n\n# Print the results\nprint(\"Matching wines for 'dessert wine':\")\nfor wine in response.objects:\n    properties = wine.properties\n    print(f\"Title: {properties['title']}\")\n    print(f\"Country: {properties['country']}\")\n    print(f\"Price: ${properties['price']}\")\n    print(f\"Points: {properties['points']}\")\n    print(f\"Distance: {wine.metadata.distance}\")\n    print(\"-\" * 50)\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using environment variables\n2. Performs a semantic search for \"dessert wine\" using the text2vec-openai vectorizer\n3. Limits results to 2 wines\n4. Retrieves the title, country, price, and points for each wine\n5. Prints the results in a readable format\n6. Properly closes the client connection\n\nThe code uses the latest Weaviate client syntax with the collections API and the near_text query operator.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 22, in <module>\n    client.collections.get(\"WineReview\")\nAttributeError: 'QueryReturn' object has no attribute 'with_additional'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:41:58.227135",
      "duration": 7.338403940200806,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Get environment variables\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=Auth.api_key(wcd_key),\n    headers={\n        \"X-OpenAI-API-Key\": openai_api_key\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Query for wines matching \"dessert wine\"\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2\n)\n\n# Print the results\nfor obj in response.objects:\n    print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n    print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n    print(f\"Price: ${obj.properties.get('price', 'N/A')}\")\n    print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n    print(\"-\" * 40)\n\n# Close the client\nclient.close()\n```\n\nThis code:\n1. Retrieves the necessary environment variables\n2. Connects to your Weaviate Cloud instance using the provided credentials\n3. Gets the WineReview collection\n4. Performs a semantic search for \"dessert wine\" with a limit of 2 results\n5. Prints the title, country, price, and points for each matching wine\n6. Properly closes the client connection when done",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: $24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: $40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:42:06.086969",
      "duration": 7.461285829544067,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Query for wines that match \"dessert wine\"\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print the results\n    print(\"Wines matching 'dessert wine':\")\n    for wine in response.objects:\n        print(f\"Title: {wine.properties['title']}\")\n        print(f\"Country: {wine.properties['country']}\")\n        print(f\"Price: ${wine.properties['price']}\")\n        print(f\"Points: {wine.properties['points']}\")\n        print(\"-\" * 50)\n        \nfinally:\n    # Close the client connection\n    client.close()\n```",
      "stdout": "Wines matching 'dessert wine':\nTitle: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: $24.0\nPoints: 88\n--------------------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: $40.0\nPoints: 88\n--------------------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T20:42:18.610021",
      "duration": 12.128158330917358,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import QueryReference\nfrom weaviate.classes.filters import Filter, FilterOperator\n\n# Get environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n\n# Initialize Weaviate client\nclient = weaviate.connect_to_weaviate(\n    url=weaviate_url,\n    auth_credentials=weaviate.auth.AuthApiKey(api_key=weaviate_api_key),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": openai_api_key\n    }\n)\n\n# Create filter for price < 50 and points > 90\nprice_points_filter = Filter.by_property(\"price\").less_than(50).and_filter(\n    Filter.by_property(\"points\").greater_than(90)\n)\n\n# Create filter for review_body containing at least one of the specified substrings\nreview_filter = (\n    Filter.by_property(\"review_body\").contains_any(\"spice\").or_filter(\n        Filter.by_property(\"review_body\").contains_any(\"fruit\").or_filter(\n            Filter.by_property(\"review_body\").contains_any(\"berry\").or_filter(\n                Filter.by_property(\"review_body\").contains_any(\"cherry\").or_filter(\n                    Filter.by_property(\"review_body\").contains_any(\"honey\")\n                )\n            )\n        )\n    )\n)\n\n# Combine the filters\ncombined_filter = price_points_filter.and_filter(review_filter)\n\n# Query the collection\nresponse = (\n    client.collections.get(\"WineReview\")\n    .query\n    .hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        limit=5,\n        filters=combined_filter\n    )\n    .with_additional([\"certainty\", \"distance\"])\n    .with_fields([\"title\", \"country\", \"price\", \"points\", \"review_body\"])\n    .do()\n)\n\n# Print the results\nprint(\"Wines that pair well with steak:\")\nprint(\"-\" * 50)\n\nif response.objects:\n    for i, wine in enumerate(response.objects, 1):\n        props = wine.properties\n        print(f\"{i}. {props['title']}\")\n        print(f\"   Country: {props['country']}\")\n        print(f\"   Price: ${props['price']}\")\n        print(f\"   Points: {props['points']}\")\n        print(f\"   Certainty: {wine.metadata.certainty:.4f}\")\n        print(\"-\" * 50)\nelse:\n    print(\"No matching wines found.\")\n\n# Close the client\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using environment variables\n2. Creates filters for price < 50, points > 90, and review_body containing specific keywords\n3. Performs a hybrid search (combining vector and keyword search) with alpha=0.5\n4. Limits results to 5 wines\n5. Retrieves and prints the title, country, price, and points for each matching wine\n6. Includes certainty scores to show how well each result matches the query\n7. Properly closes the client connection when done",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 4, in <module>\n    from weaviate.classes.filters import Filter, FilterOperator\nModuleNotFoundError: No module named 'weaviate.classes.filters'\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T20:42:25.990811",
      "duration": 6.896207094192505,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=Auth.api_key(wcd_key),\n    headers={\n        \"X-OpenAI-API-Key\": openai_api_key\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform hybrid search\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) & \n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\n# Print results\nprint(f\"Found {len(response.objects)} matching wines:\")\nfor obj in response.objects:\n    print(f\"\\nTitle: {obj.properties['title']}\")\n    print(f\"Country: {obj.properties['country']}\")\n    print(f\"Price: ${obj.properties['price']}\")\n    print(f\"Points: {obj.properties['points']}\")\n    print(f\"Score: {obj.metadata.score}\")\n\n# Close the client\nclient.close()\n```",
      "stdout": "Found 5 matching wines:\n\nTitle: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.0\nPoints: 92\nScore: 0.5\n\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.0\nPoints: 91\nScore: 0.3765353560447693\n\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.0\nPoints: 91\nScore: 0.04513849690556526\n\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.0\nPoints: 93\nScore: 0.016171861439943314\n\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: $0.0\nPoints: 92\nScore: 0.0010482011130079627\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T20:42:41.059040",
      "duration": 14.665359020233154,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\nimport re\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Define the regex pattern to match any of the required substrings\n    pattern = re.compile(r'spice|fruit|berry|cherry|honey', re.IGNORECASE)\n    \n    # Create a filter for price < 50 and points > 90\n    price_points_filter = (\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90)\n    )\n    \n    # Perform hybrid search with alpha=0.5\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,  # Balance between keyword and vector search\n        filters=price_points_filter,\n        limit=5,\n        return_metadata=MetadataQuery(distance=True, score=True)\n    )\n    \n    # Process and print results, filtering for those containing required substrings\n    print(\"Wines that pair well with steak:\")\n    print(\"================================\")\n    \n    for obj in response.objects:\n        # Check if review_body contains any of the required substrings\n        review_body = obj.properties.get(\"review_body\", \"\")\n        if pattern.search(review_body):\n            print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n            print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n            print(f\"Price: ${obj.properties.get('price', 'N/A')}\")\n            print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n            print(f\"Score: {obj.metadata.score:.4f}\")\n            print(\"--------------------------------\")\n    \nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis Python code:\n\n1. Connects to Weaviate Cloud using environment variables for authentication\n2. Gets the WineReview collection\n3. Creates a regex pattern to match any of the required substrings in the review\n4. Sets up a filter for wines with price < 50 and points > 90\n5. Performs a hybrid search (combining vector and keyword search) with alpha=0.5 for \"pair with steak\"\n6. Processes the results, filtering for wines that contain at least one of the required substrings\n7. Prints the title, country, price, and points for each matching wine\n8. Properly closes the client connection when done\n\nThe code uses the latest Weaviate client syntax (v4.x) and follows best practices for connection handling and query construction.",
      "stdout": "Wines that pair well with steak:\n================================\nTitle: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.0\nPoints: 92\nScore: 0.5000\n--------------------------------\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.0\nPoints: 91\nScore: 0.3765\n--------------------------------\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.0\nPoints: 91\nScore: 0.0451\n--------------------------------\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.0\nPoints: 93\nScore: 0.0162\n--------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    }
  },
  "anthropic/claude-3-5-haiku-20241022": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T20:42:45.865312",
      "duration": 4.787637948989868,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "Here's a Python script that connects to Weaviate Cloud using environment variables and checks server readiness:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.connect import ConnectionParams\n\n# Create connection parameters from environment variables\nconnection_params = ConnectionParams.from_params(\n    url=os.getenv('WCD_TEST_URL'),\n    api_key=os.getenv('WCD_TEST_KEY')\n)\n\n# Create Weaviate client\nclient = weaviate.connect_to_custom(\n    connection_params=connection_params\n)\n\n# Check server readiness\ntry:\n    client.is_ready()\n    print(\"Weaviate server is ready.\")\nexcept Exception as e:\n    print(f\"Error connecting to Weaviate: {e}\")\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis script does the following:\n1. Uses environment variables for URL and API key\n2. Creates connection parameters\n3. Establishes a connection to Weaviate\n4. Checks server readiness\n5. Closes the connection",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 6, in <module>\n    connection_params = ConnectionParams.from_params(\nTypeError: from_params() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:42:50.038553",
      "duration": 4.1535632610321045,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "Here's the Python code to connect to Weaviate Cloud using environment variables:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv('WCD_TEST_URL'),\n    auth_credentials=Auth.api_key(os.getenv('WCD_TEST_KEY'))\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready()\n\n# Close the client connection\nclient.close()\n```\n\nThis code does the following:\n1. Imports the necessary modules\n2. Uses `os.getenv()` to retrieve the Weaviate Cloud URL and API key from environment variables\n3. Connects to the Weaviate Cloud instance\n4. Checks that the server is ready using `is_ready()`\n5. Closes the client connection",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T20:43:01.647647",
      "duration": 11.590353965759277,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "Here's a Python script using the latest Weaviate client syntax to create a collection with the specified properties:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\n\ndef create_products_collection():\n    # Get Weaviate Cloud credentials from environment variables\n    wcd_url = os.getenv('WCD_TEST_URL')\n    wcd_key = os.getenv('WCD_TEST_KEY')\n\n    # Create Weaviate client\n    client = weaviate.connect_to_wcs(\n        cluster_url=wcd_url,\n        auth_credentials=wcd_key\n    )\n\n    try:\n        # Check if collection exists and delete if it does\n        if client.collections.exists(\"DemoProducts\"):\n            print(\"Deleting existing DemoProducts collection...\")\n            client.collections.delete(\"DemoProducts\")\n\n        # Create the collection with specified properties\n        client.collections.create(\n            name=\"DemoProducts\",\n            properties=[\n                Property(\n                    name=\"name\",\n                    data_type=DataType.TEXT\n                ),\n                Property(\n                    name=\"description\", \n                    data_type=DataType.TEXT\n                ),\n                Property(\n                    name=\"price\", \n                    data_type=DataType.NUMBER\n                ),\n                Property(\n                    name=\"in_stock\", \n                    data_type=DataType.BOOLEAN\n                )\n            ]\n        )\n\n        print(\"DemoProducts collection created successfully!\")\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n    finally:\n        # Close the client connection\n        client.close()\n\n# Run the function\nif __name__ == \"__main__\":\n    create_products_collection()\n```\n\nThis script does the following:\n\n1. Imports necessary modules from the Weaviate client library.\n\n2. Defines a function `create_products_collection()` that:\n   - Retrieves Weaviate Cloud credentials from environment variables\n   - Connects to Weaviate Cloud using `connect_to_wcs()`\n   - Checks if the \"DemoProducts\" collection exists and deletes it if it does\n   - Creates a new collection with the specified properties\n   - Uses the latest Weaviate client syntax with `collections.create()`\n   - Defines properties using `Property()` with appropriate `DataType`\n\n3. Includes error handling and ensures the client connection is closed\n\n4. Runs the function when the script is executed directly\n\nBefore running the script, make sure to:\n- Install the Weaviate client: `pip install weaviate-client`\n- Set the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n\nExample of setting environment variables:\n```bash\nexport WCD_TEST_URL='https://your-cluster-url.weaviate.network'\nexport WCD_TEST_KEY='your-api-key'\n```\n\nThis script provides a clean, modern approach to creating a Weaviate collection with the specified properties.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 56, in <module>\n    create_products_collection()\n  File \"/code/code.py\", line 11, in create_products_collection\n    client = weaviate.connect_to_wcs(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/helpers.py\", line 145, in connect_to_wcs\n    return connect_to_weaviate_cloud(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/helpers.py\", line 80, in connect_to_weaviate_cloud\n    return __connect(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/helpers.py\", line 411, in __connect\n    raise e\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/helpers.py\", line 407, in __connect\n    client.connect()\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/syncify.py\", line 23, in sync_method\n    return _EventLoopSingleton.get_instance().run_until_complete(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/event_loop.py\", line 42, in run_until_complete\n    return fut.result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 446, in result\n    return self.__get_result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 391, in __get_result\n    raise self._exception\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/client_base.py\", line 153, in connect\n    await self._connection.connect(self._skip_init_checks)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 162, in connect\n    await self._open_connections_rest(self._auth, skip_init_checks)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 296, in _open_connections_rest\n    self._client = await _auth.get_auth_session()\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/authentication_async.py\", line 93, in get_auth_session\n    assert isinstance(self._credentials, AuthClientPassword)\nAssertionError\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:43:10.373275",
      "duration": 8.706377029418945,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "Here's the Python code to create a Weaviate collection using the latest client syntax, connecting to Weaviate Cloud with environment variables:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv('WCD_TEST_URL'),\n    auth_credentials=Auth.api_key(os.getenv('WCD_TEST_KEY'))\n)\n\n# Collection name\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\ntry:\n    if client.collections.exists(collection_name):\n        client.collections.delete(collection_name)\nexcept Exception as e:\n    print(f\"Error checking/deleting existing collection: {e}\")\n\n# Create the collection\ntry:\n    products_collection = client.collections.create(\n        collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n    print(f\"Created collection: {products_collection.name}\")\nexcept Exception as e:\n    print(f\"Error creating collection: {e}\")\n\n# Close connection\nclient.close()\n```\n\nThis script does the following:\n\n1. Imports necessary modules from the Weaviate client library.\n2. Connects to Weaviate Cloud using environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n3. Checks if the collection already exists and deletes it if it does.\n4. Creates a new collection named \"DemoProducts\" with the specified properties.\n5. Adds error handling to catch and print any exceptions during collection deletion or creation.\n6. Closes the client connection at the end.\n\nMake sure to set the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` before running the script. You can do this in your shell:\n\n```bash\nexport WCD_TEST_URL='your-weaviate-cloud-url'\nexport WCD_TEST_KEY='your-api-key'\n```\n\nOr set them programmatically before running the script.",
      "stdout": "Created collection: DemoProducts\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:43:19.138499",
      "duration": 8.74657392501831,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to create a \"DemoProducts\" collection in Weaviate Cloud using the latest client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\n# Delete the collection if it already exists\nif client.collections.exists(\"DemoProducts\"):\n    client.collections.delete(\"DemoProducts\")\n\n# Create the DemoProducts collection\nclient.collections.create(\n    \"DemoProducts\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL)\n    ]\n)\n\n# Close the client connection\nclient.close()\n```\n\nThis code does the following:\n\n1. Imports the necessary Weaviate client modules\n2. Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n3. Checks if the \"DemoProducts\" collection already exists, and if so, deletes it\n4. Creates a new \"DemoProducts\" collection with the specified properties:\n   - `name` as a text property\n   - `description` as a text property\n   - `price` as a number property\n   - `in_stock` as a boolean property\n5. Closes the client connection\n\nMake sure to set the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables before running the script.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T20:43:29.101407",
      "duration": 9.289789915084839,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Here's a Python script that accomplishes what you described using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nimport weaviate.classes as wvc\n\n# Read Weaviate Cloud credentials from environment variables\nWEAVIATE_URL = os.getenv('WCD_TEST_URL')\nWEAVIATE_API_KEY = os.getenv('WCD_TEST_KEY')\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_wcs(\n    cluster_url=WEAVIATE_URL,\n    auth_credentials=weaviate.auth.AuthApiKey(WEAVIATE_API_KEY)\n)\n\ntry:\n    # Create the collection with specified properties\n    client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            wvc.Property(name=\"name\", data_type=wvc.DataType.TEXT),\n            wvc.Property(name=\"description\", data_type=wvc.DataType.TEXT)\n        ]\n    )\n\n    # Get the collection\n    products = client.collections.get(\"DemoProducts\")\n\n    # Batch import 50 objects\n    with products.batch as batch:\n        for i in range(50):\n            batch.add_object({\n                \"name\": f\"Product {i}\",\n                \"description\": f\"Description {i}\"\n            })\n\n    # Print the number of objects in the collection\n    object_count = products.aggregate.count()\n    print(f\"Number of objects in DemoProducts collection: {object_count}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis script does the following:\n\n1. Imports necessary libraries\n2. Reads Weaviate Cloud credentials from environment variables\n3. Connects to Weaviate Cloud using the provided URL and API key\n4. Creates a collection named \"DemoProducts\" with name and description properties\n5. Batch imports 50 objects into the collection\n6. Prints the number of objects in the collection\n7. Closes the client connection\n\nMake sure to set the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` before running the script.\n\nNote: This code uses the latest Weaviate client syntax (v4.x), which is different from previous versions. Make sure you have the latest version installed:\n\n```bash\npip install weaviate-client\n```",
      "stdout": "An error occurred: module 'weaviate.classes' has no attribute 'Property'\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:43:39.608459",
      "duration": 9.861117839813232,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Here's the Python code to accomplish the task using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=AuthApiKey(os.getenv(\"WCD_TEST_KEY\")),\n)\n\n# Create the collection if it doesn't exist\ntry:\n    # Remove existing collection if needed\n    client.collections.delete(\"DemoProducts\")\nexcept Exception:\n    pass\n\n# Create the collection with specified properties\nclient.collections.create(\n    name=\"DemoProducts\",\n    properties=[\n        weaviate.Property(name=\"name\", data_type=weaviate.DataType.TEXT),\n        weaviate.Property(name=\"description\", data_type=weaviate.DataType.TEXT)\n    ]\n)\n\n# Get the collection\ncollection = client.collections.get(\"DemoProducts\")\n\n# Batch import 50 objects\nwith collection.batch.dynamic() as batch:\n    for i in range(50):\n        batch.add_object(\n            properties={\n                \"name\": f\"Product {i+1}\",\n                \"description\": f\"Description for Product {i+1}\"\n            }\n        )\n\n# Check for any batch import errors\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\n# Print the number of objects in the collection\nprint(f\"Number of objects in the collection: {len(collection)}\")\n\n# Close the client connection\nclient.close()\n```\n\nThis script does the following:\n\n1. Imports necessary libraries and uses environment variables for Weaviate Cloud connection.\n2. Connects to Weaviate Cloud using the URL and API key from environment variables.\n3. Creates a collection named \"DemoProducts\" with two text properties: \"name\" and \"description\".\n4. Batch imports 50 objects into the collection using a dynamic batch process.\n5. Checks for any failed imports and prints error information if applicable.\n6. Prints the total number of objects in the collection.\n7. Closes the client connection.\n\nMake sure to set the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` before running the script:\n\n```bash\nexport WCD_TEST_URL=\"your-weaviate-cloud-url\"\nexport WCD_TEST_KEY=\"your-api-key\"\n```\n\nThis code uses the latest Weaviate client syntax and follows best practices for batch importing objects.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 22, in <module>\n    weaviate.Property(name=\"name\", data_type=weaviate.DataType.TEXT),\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/__init__.py\", line 147, in __getattr__\n    raise AttributeError(f\"module {__name__} has no attribute {name}\")\nAttributeError: module weaviate has no attribute Property\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:43:49.700382",
      "duration": 9.482831001281738,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's a Python script that follows the requirements you specified:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\ntry:\n    # Create the collection with name and description properties\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT)\n        ]\n    )\n\n    # Get the collection\n    collection = client.collections.get(\"DemoProducts\")\n\n    # Batch import 50 objects\n    with collection.batch.fixed_size(batch_size=50) as batch:\n        for i in range(50):\n            batch.add_object(\n                properties={\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"Description {i}\"\n                }\n            )\n\n    # Print the number of objects in the collection\n    object_count = collection.aggregate.count()\n    print(f\"Number of objects in the collection: {object_count}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis script does the following:\n\n1. Imports necessary libraries\n2. Connects to Weaviate Cloud using the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables\n3. Creates a collection named \"DemoProducts\" with \"name\" and \"description\" properties\n4. Uses a fixed-size batch to import 50 objects with simple properties\n5. Prints the number of objects in the collection\n6. Ensures the client connection is closed\n\nMake sure to set the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables before running the script.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\nTraceback (most recent call last):\n  File \"/code/code.py\", line 14, in <module>\n    client.collections.create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/sync.py\", line 107, in create\n    self.__loop.run_until_complete(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/event_loop.py\", line 42, in run_until_complete\n    return fut.result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 446, in result\n    return self.__get_result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 391, in __get_result\n    raise self._exception\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/async_.py\", line 134, in create\n    name = await super()._create(config._to_dict())\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/base.py\", line 27, in _create\n    response = await self._connection.post(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 550, in post\n    return await self.__send(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 505, in __send\n    raise e\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 496, in __send\n    raise UnexpectedStatusCodeError(error_msg, response=res)\nweaviate.exceptions.UnexpectedStatusCodeError: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'class name DemoProducts already exists'}]}.\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:43:58.436731",
      "duration": 8.363570928573608,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's a Python script that accomplishes the task using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nimport weaviate.classes as wvc\n\n# Set up Weaviate client connection\nclient = weaviate.connect_to_wcs(\n    cluster_url=os.getenv('WCD_TEST_URL'),\n    auth_credentials=weaviate.auth.AuthApiKey(os.getenv('WCD_TEST_KEY')),\n    headers={\n        \"X-OpenAI-Api-Key\": os.getenv('OPENAI_API_KEY')\n    }\n)\n\ntry:\n    # Perform hybrid search on WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    results = wine_collection.query.hybrid(\n        query=\"dessert wine\",\n        limit=2\n    )\n\n    # Print details of matching wines\n    for wine in results.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: {wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(\"---\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis script does the following:\n\n1. Imports necessary libraries\n2. Connects to Weaviate Cloud using environment variables\n3. Performs a hybrid search on the WineReview collection\n4. Prints details of up to 2 matching wines\n5. Ensures the client connection is closed\n\nMake sure to set the environment variables `WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY` before running the script.",
      "stdout": "Title: Schmitz 24 Brix 2012 Sauvignon Blanc (Sierra Foothills)\nCountry: US\nPrice: 22.0\nPoints: 85\n---\nTitle: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n---\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:44:07.082779",
      "duration": 8.25115704536438,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "Here's the Python code to query the 'WineReview' collection for dessert wines using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv('WCD_TEST_URL'),\n    auth_credentials=Auth.api_key(os.getenv('WCD_TEST_KEY')),\n    headers={\n        \"X-OpenAI-API-Key\": os.getenv('OPENAI_API_KEY')\n    }\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform near_text query for dessert wines\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2\n)\n\n# Print details of matching wines\nfor obj in response.objects:\n    print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n    print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n    print(f\"Price: {obj.properties.get('price', 'N/A')}\")\n    print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n    print(\"---\")\n\n# Close the client connection\nclient.close()\n```\n\nThis script does the following:\n\n1. Imports the necessary Weaviate libraries\n2. Connects to Weaviate Cloud using environment variables\n3. Retrieves the 'WineReview' collection\n4. Performs a near_text query for \"dessert wine\" with a limit of 2 results\n5. Prints the title, country, price, and points for each matching wine\n6. Closes the client connection\n\nMake sure to set the following environment variables before running:\n- `WCD_TEST_URL`: Weaviate Cloud instance URL\n- `WCD_TEST_KEY`: Weaviate Cloud API key\n- `OPENAI_API_KEY`: OpenAI API key for the text2vec-openai vectorizer",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n---\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n---\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:44:17.852052",
      "duration": 10.385109186172485,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to query the 'WineReview' collection for dessert wines using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n\n    # Perform near_text search for \"dessert wine\"\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2\n    )\n\n    # Print details for each matching wine\n    for wine in response.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: {wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(\"---\")\n\nfinally:\n    # Always close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. Imports necessary libraries and modules\n2. Connects to Weaviate Cloud using environment variables\n3. Gets the 'WineReview' collection\n4. Performs a semantic search for \"dessert wine\" with a limit of 2 results\n5. Prints the title, country, price, and points for each matching wine\n6. Ensures the client connection is closed\n\nMake sure to set the following environment variables before running:\n- `WCD_TEST_URL`: Weaviate Cloud instance URL\n- `WCD_TEST_KEY`: Weaviate Cloud API key\n- `OPENAI_API_KEY`: OpenAI API key for the text2vec-openai vectorizer",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n---\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n---\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T20:44:28.277943",
      "duration": 10.01045298576355,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's a Python script that meets your requirements:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import HybridSearchOptions\n\ndef main():\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_wcs(\n        cluster_url=os.getenv('WCD_TEST_URL'),\n        auth_credentials=os.getenv('WCD_TEST_KEY'),\n        headers={\n            \"X-OpenAI-Api-Key\": os.getenv('OPENAI_API_KEY')\n        }\n    )\n\n    try:\n        # Query the WineReview collection\n        result = client.collections.get(\"WineReview\").query.hybrid(\n            query=\"pair with steak\",\n            hybrid_search_options=HybridSearchOptions(alpha=0.5),\n            filters=[\n                # Price less than 50\n                client.collections.get(\"WineReview\").filter.less_than(path=\"price\", value=50),\n                # Points greater than 90\n                client.collections.get(\"WineReview\").filter.greater_than(path=\"points\", value=90)\n            ],\n            limit=5\n        )\n\n        # Filter results based on review body keywords\n        matching_wines = [\n            wine for wine in result.objects \n            if any(keyword in wine.properties['review_body'].lower() \n                   for keyword in ['spice', 'fruit', 'berry', 'cherry', 'honey'])\n        ]\n\n        # Print matching wines\n        for wine in matching_wines:\n            print(f\"Title: {wine.properties['title']}\")\n            print(f\"Country: {wine.properties['country']}\")\n            print(f\"Price: ${wine.properties['price']}\")\n            print(f\"Points: {wine.properties['points']}\")\n            print(\"---\")\n\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis script does the following:\n\n1. Connects to Weaviate Cloud using environment variables\n2. Uses the latest Weaviate client syntax (v4+)\n3. Performs a hybrid search with alpha=0.5\n4. Applies filters for price and points\n5. Further filters results based on review body keywords\n6. Prints details of matching wines\n\nMake sure to set the following environment variables:\n- `WCD_TEST_URL`\n- `WCD_TEST_KEY`\n- `OPENAI_API_KEY`\n\nNote: The exact implementation might need slight adjustments based on the precise schema of your WineReview collection.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 3, in <module>\n    from weaviate.classes.query import HybridSearchOptions\nImportError: cannot import name 'HybridSearchOptions' from 'weaviate.classes.query' (/usr/local/lib/python3.9/site-packages/weaviate/classes/query.py)\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T20:44:38.021405",
      "duration": 9.339615106582642,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "Here's the Python code that matches your requirements:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv('WCD_TEST_URL'),\n    auth_credentials=Auth.api_key(os.getenv('WCD_TEST_KEY')),\n    headers={\n        \"X-OpenAI-API-Key\": os.getenv('OPENAI_API_KEY')\n    }\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform hybrid search with specified conditions\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    )\n)\n\n# Print matching wines\nfor wine in response.objects:\n    print(f\"Title: {wine.properties['title']}\")\n    print(f\"Country: {wine.properties['country']}\")\n    print(f\"Price: ${wine.properties['price']}\")\n    print(f\"Points: {wine.properties['points']}\")\n    print(\"---\")\n\n# Close the client connection\nclient.close()\n```\n\nThis script does the following:\n\n1. Imports necessary Weaviate libraries\n2. Connects to Weaviate Cloud using environment variables\n3. Retrieves the WineReview collection\n4. Performs a hybrid search with:\n   - Query: \"pair with steak\"\n   - Limit: 5 results\n   - Alpha: 0.5\n   - Filters:\n     * Price less than $50\n     * Points greater than 90\n     * Review body contains one of: \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n5. Prints the title, country, price, and points for each matching wine\n6. Closes the client connection\n\nMake sure to set the following environment variables before running:\n- `WCD_TEST_URL`: Weaviate Cloud instance URL\n- `WCD_TEST_KEY`: Weaviate Cloud API key\n- `OPENAI_API_KEY`: OpenAI API key for text2vec-openai vectorization",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.0\nPoints: 92\n---\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.0\nPoints: 91\n---\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.0\nPoints: 91\n---\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.0\nPoints: 93\n---\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: $0.0\nPoints: 92\n---\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T20:44:52.491824",
      "duration": 14.0812828540802,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to query the 'WineReview' collection based on your specific requirements:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, HybridFusion\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n\n    # Perform hybrid search with complex filtering\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,  # Balance between semantic and keyword search\n        fusion_type=HybridFusion.RELATIVE_SCORE,\n        filters=(\n            # Price less than 50\n            Filter.by_property(\"price\").less_than(50) &\n            # Points greater than 90\n            Filter.by_property(\"points\").greater_than(90) &\n            # Review body contains one of the specified substrings\n            Filter.by_property(\"review_body\").contains_any(\n                [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n            )\n        ),\n        limit=5\n    )\n\n    # Print results\n    for wine in response.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: ${wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(\"---\")\n\nfinally:\n    # Always close the client\n    client.close()\n```\n\nThis code does the following:\n\n1. Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY`.\n\n2. Retrieves the 'WineReview' collection.\n\n3. Performs a hybrid search with:\n   - Query: \"pair with steak\"\n   - Alpha of 0.5 (balanced semantic and keyword search)\n   - Filters for:\n     - Price less than $50\n     - Points greater than 90\n     - Review body containing at least one of: \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n   - Limit of 5 results\n\n4. Prints the title, country, price, and points for each matching wine.\n\n5. Ensures the client is closed using a `try`/`finally` block.\n\nMake sure to set the following environment variables before running the script:\n- `WCD_TEST_URL`: Weaviate Cloud instance URL\n- `WCD_TEST_KEY`: Weaviate Cloud API key\n- `OPENAI_API_KEY`: OpenAI API key for the text2vec-openai vectorizer",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.0\nPoints: 92\n---\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.0\nPoints: 91\n---\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.0\nPoints: 91\n---\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.0\nPoints: 93\n---\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: $0.0\nPoints: 92\n---\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    }
  },
  "openai/gpt-4.1-mini-2025-04-14": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T20:44:54.327837",
      "duration": 1.8178889751434326,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get environment variables\nurl = os.getenv(\"WCD_TEST_URL\")\napi_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Initialize Weaviate client with API key authentication\nclient = weaviate.Client(\n    url,\n    auth_client_secret=weaviate.AuthApiKey(api_key),\n)\n\n# Check if the server is ready\nif client.is_ready():\n    print(\"Weaviate server is ready to accept requests.\")\nelse:\n    print(\"Weaviate server is not ready.\")\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:9: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 9, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'auth_client_secret'\n",
      "exit_code": 1
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:44:57.264796",
      "duration": 2.917855978012085,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Read environment variables\ncluster_url = os.environ[\"WCD_TEST_URL\"]\napi_key = os.environ[\"WCD_TEST_KEY\"]\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Check if the server is ready\nassert client.is_ready()\n\nclient.close()\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T20:45:02.303685",
      "duration": 5.020914793014526,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set\")\n\n# Create Weaviate client with API key authentication\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": WCD_TEST_KEY  # sometimes needed for OpenAI modules, remove if not needed\n    }\n)\n\nclass_name = \"DemoProducts\"\n\n# Delete class if it exists\nif client.schema.contains(class_name):\n    client.schema.delete_class(class_name)\n\n# Define the schema for the class\ndemo_products_class = {\n    \"class\": class_name,\n    \"properties\": [\n        {\n            \"name\": \"name\",\n            \"dataType\": [\"text\"],\n        },\n        {\n            \"name\": \"description\",\n            \"dataType\": [\"text\"],\n        },\n        {\n            \"name\": \"price\",\n            \"dataType\": [\"number\"],\n        },\n        {\n            \"name\": \"in_stock\",\n            \"dataType\": [\"boolean\"],\n        },\n    ],\n}\n\n# Create the class\nclient.schema.create_class(demo_products_class)\n\nprint(f\"Class '{class_name}' created successfully.\")\n```\n",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:12: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 12, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:45:06.707915",
      "duration": 4.384147882461548,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Read environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY)\n)\n\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\n# Create the collection with the specified properties\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n```",
      "stdout": "Created collection: DemoProducts\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:45:11.161401",
      "duration": 4.435520887374878,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n)\n\ncollection_name = \"DemoProducts\"\n\n# If the collection exists, delete it first\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\n# Create the collection with the specified properties\nclient.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ],\n)\n\nprint(f\"Collection '{collection_name}' created successfully.\")\n```\nThis code uses the latest Weaviate Python client syntax to connect to your Weaviate Cloud instance, deletes the \"DemoProducts\" collection if it exists, and then creates it with the requested properties.\n\nFor more details, see the official docs on collection management:  \nhttps://docs.weaviate.io/weaviate/manage-data/collections",
      "stdout": "Collection 'DemoProducts' created successfully.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:45:22.833904",
      "duration": 11.010169744491577,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\ndef main():\n    # Get environment variables\n    url = os.environ.get(\"WCD_TEST_URL\")\n    api_key = os.environ.get(\"WCD_TEST_KEY\")\n\n    if not url or not api_key:\n        raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set\")\n\n    # Connect to Weaviate Cloud\n    client = weaviate.Client(\n        url=url,\n        auth_client_secret=weaviate.AuthApiKey(api_key),\n        additional_headers={\n            \"X-OpenAI-Api-Key\": api_key  # sometimes needed if using OpenAI modules, but not required here\n        }\n    )\n\n    # Define the schema for the class \"DemoProducts\"\n    class_obj = {\n        \"class\": \"DemoProducts\",\n        \"description\": \"A collection of demo products\",\n        \"properties\": [\n            {\n                \"name\": \"name\",\n                \"dataType\": [\"text\"],\n                \"description\": \"Name of the product\"\n            },\n            {\n                \"name\": \"description\",\n                \"dataType\": [\"text\"],\n                \"description\": \"Description of the product\"\n            }\n        ]\n    }\n\n    # Check if class exists, if not create it\n    schema = client.schema.get()\n    classes = [c[\"class\"] for c in schema.get(\"classes\", [])]\n    if \"DemoProducts\" not in classes:\n        client.schema.create_class(class_obj)\n\n    # Batch import 50 objects\n    with client.batch as batch:\n        batch.batch_size = 20  # batch size can be tuned\n        for i in range(1, 51):\n            obj = {\n                \"name\": f\"Product {i}\",\n                \"description\": f\"Description {i}\"\n            }\n            batch.add_data_object(obj, \"DemoProducts\")\n\n    # Count objects in the class\n    result = client.query.aggregate(\"DemoProducts\").with_meta_count().do()\n    count = result.get(\"data\", {}).get(\"Aggregate\", {}).get(\"DemoProducts\", [{}])[0].get(\"meta\", {}).get(\"count\", 0)\n\n    print(f\"Number of objects in 'DemoProducts': {count}\")\n\nif __name__ == \"__main__\":\n    main()\n```\n",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:13: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 62, in <module>\n    main()\n  File \"/code/code.py\", line 13, in main\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:45:33.779827",
      "duration": 10.236739873886108,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\ndef main():\n    # Read environment variables\n    WCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\n    WCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n    if not WCD_TEST_URL or not WCD_TEST_KEY:\n        raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set\")\n\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=AuthApiKey(api_key=WCD_TEST_KEY),\n    )\n\n    # Define the class schema for \"DemoProducts\" if it doesn't exist\n    class_name = \"DemoProducts\"\n    schema = client.schema.get()\n    classes = [c[\"class\"] for c in schema.get(\"classes\", [])]\n\n    if class_name not in classes:\n        class_obj = {\n            \"class\": class_name,\n            \"description\": \"A demo product class\",\n            \"properties\": [\n                {\n                    \"name\": \"name\",\n                    \"dataType\": [\"text\"],\n                    \"description\": \"Name of the product\",\n                },\n                {\n                    \"name\": \"description\",\n                    \"dataType\": [\"text\"],\n                    \"description\": \"Description of the product\",\n                },\n            ],\n        }\n        client.schema.create_class(class_obj)\n\n    # Prepare 50 arbitrary objects\n    data_rows = [\n        {\n            \"name\": f\"Product {i}\",\n            \"description\": f\"Description {i}\"\n        }\n        for i in range(1, 51)\n    ]\n\n    # Batch import objects\n    with client.batch as batch:\n        batch.batch_size = 20  # You can adjust batch size if you want\n        for data_row in data_rows:\n            batch.add_data_object(\n                data_object=data_row,\n                class_name=class_name,\n            )\n            if batch.number_errors > 10:\n                print(\"Batch import stopped due to excessive errors.\")\n                break\n\n    # Print number of objects in the collection\n    # Weaviate does not have a direct collection.count() method,\n    # so we do a count query\n    result = client.query.aggregate(class_name).with_meta_count().do()\n    count = 0\n    try:\n        count = result[\"data\"][\"Aggregate\"][class_name][0][\"meta\"][\"count\"]\n    except (KeyError, IndexError):\n        pass\n\n    print(f\"Number of objects in '{class_name}': {count}\")\n\n    client.close()\n\n\nif __name__ == \"__main__\":\n    main()\n```\n",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 80, in <module>\n    main()\n  File \"/code/code.py\", line 21, in main\n    schema = client.schema.get()\nAttributeError: 'WeaviateClient' object has no attribute 'schema'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:45:42.666829",
      "duration": 8.127864122390747,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Configure, Property, DataType\n\ndef main():\n    # Connect to Weaviate Cloud using environment variables\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=weaviate.classes.init.Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    )\n\n    # Check if collection \"DemoProducts\" exists, if not create it\n    if not client.collections.exists(\"DemoProducts\"):\n        client.collections.create(\n            \"DemoProducts\",\n            properties=[\n                Property(name=\"name\", data_type=DataType.TEXT),\n                Property(name=\"description\", data_type=DataType.TEXT),\n            ],\n            # Use a vectorizer suitable for text properties (optional, recommended)\n            vector_config=Configure.Vectors.text2vec_weaviate()\n        )\n\n    # Get the collection object\n    collection = client.collections.get(\"DemoProducts\")\n\n    # Batch import 50 arbitrary objects\n    with collection.batch.fixed_size(batch_size=50) as batch:\n        for i in range(50):\n            batch.add_object(\n                properties={\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"Description {i}\"\n                }\n            )\n\n    # Fetch the number of objects in the collection\n    count = collection.data.count()\n    print(f\"Number of objects in 'DemoProducts': {count}\")\n\n    # Close client connection\n    client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n---\n\n### Explanation:\n- Connects to Weaviate Cloud using `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables.\n- Checks if the collection `\"DemoProducts\"` exists; if not, creates it with `name` and `description` text properties.\n- Uses the `text2vec_weaviate` vectorizer (recommended for Weaviate Cloud).\n- Batch inserts 50 objects with simple properties.\n- Prints the total count of objects in the collection.\n- Closes the client connection at the end.\n\n---\n\n### References:\n- [Weaviate Python Client docs](https://docs.weaviate.io/weaviate/client-libraries/python)\n- [How to batch import data](https://docs.weaviate.io/weaviate/manage-data/import)\n- [Collection management](https://docs.weaviate.io/weaviate/manage-data/collections)",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 45, in <module>\n    main()\n  File \"/code/code.py\", line 38, in main\n    count = collection.data.count()\nAttributeError: '_DataCollection' object has no attribute 'count'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T20:45:48.544605",
      "duration": 5.449938058853149,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Load environment variables\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\nOPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\n\n# Initialize Weaviate client with authentication\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": OPENAI_API_KEY,\n    },\n)\n\n# Define the query string\nquery_text = \"dessert wine\"\n\n# Perform a vector search using the text2vec-openai vectorizer\nresult = (\n    client.query.get(\"WineReview\", [\"title\", \"country\", \"price\", \"points\"])\n    .with_near_text({\"concepts\": [query_text]})\n    .with_limit(2)\n    .do()\n)\n\n# Extract and print results\nfor wine in result.get(\"data\", {}).get(\"Get\", {}).get(\"WineReview\", []):\n    title = wine.get(\"title\")\n    country = wine.get(\"country\")\n    price = wine.get(\"price\")\n    points = wine.get(\"points\")\n    print(f\"Title: {title}\\nCountry: {country}\\nPrice: {price}\\nPoints: {points}\\n\")\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:10: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 10, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:45:55.991309",
      "duration": 7.03843879699707,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\ndef main():\n    # Load environment variables\n    WCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\n    WCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\n    OPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\n\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY),\n        headers={\n            \"X-OpenAI-API-Key\": OPENAI_API_KEY\n        },\n    )\n\n    # Get the WineReview collection\n    collection = client.collections.get(\"WineReview\")\n\n    # Query for \"dessert wine\" with max 2 results\n    response = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2\n    )\n\n    # Print title, country, price, and points for each result\n    for obj in response.objects:\n        props = obj.properties\n        title = props.get(\"title\", \"N/A\")\n        country = props.get(\"country\", \"N/A\")\n        price = props.get(\"price\", \"N/A\")\n        points = props.get(\"points\", \"N/A\")\n        print(f\"Title: {title}, Country: {country}, Price: {price}, Points: {points}\")\n\n    client.close()\n\nif __name__ == \"__main__\":\n    main()\n```",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA)), Country: US, Price: 24.0, Points: 88\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast), Country: US, Price: 40.0, Points: 88\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:46:06.090407",
      "duration": 9.623486995697021,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\ndef main():\n    # Read environment variables\n    wcd_url = os.environ[\"WCD_TEST_URL\"]\n    wcd_api_key = os.environ[\"WCD_TEST_KEY\"]\n    openai_api_key = os.environ[\"OPENAI_API_KEY\"]\n\n    # Connect to Weaviate Cloud with API key and OpenAI inference key in headers\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=wcd_url,\n        auth_credentials=Auth.api_key(wcd_api_key),\n        headers={\n            \"X-OpenAI-Api-Key\": openai_api_key\n        }\n    )\n\n    # Get the WineReview collection\n    collection = client.collections.get(\"WineReview\")\n\n    # Perform semantic search with near_text for \"dessert wine\", limit 2\n    response = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # Print the results\n    for obj in response.objects:\n        props = obj.properties\n        print(f\"Title: {props.get('title')}\")\n        print(f\"Country: {props.get('country')}\")\n        print(f\"Price: {props.get('price')}\")\n        print(f\"Points: {props.get('points')}\")\n        print(\"-\" * 40)\n\n    # Close client connection\n    client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\nThis code uses the latest Weaviate Python client syntax (v4.x), connects to your Weaviate Cloud instance using environment variables, queries the `WineReview` collection with a semantic search for \"dessert wine\" using the `text2vec-openai` vectorizer, limits results to 2, and prints the requested properties.\n\nFor more details on querying with the Python client, see the official docs:  \nhttps://weaviate.io/developers/weaviate/current/client-libraries/python.html#search-operations",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T20:46:17.244050",
      "duration": 10.724165678024292,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Load environment variables\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\nOPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\n\n# Initialize Weaviate client with API key authentication\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": OPENAI_API_KEY\n    }\n)\n\n# Define the query string\nquery_text = \"pair with steak\"\n\n# Define the substrings to filter in review_body\nsubstr_filters = [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n\n# Build the filter for review_body containing at least one of the substrings\n# Using \"or\" operator with \"operator\": \"Like\" (case-insensitive substring match)\nreview_body_filter = {\n    \"operator\": \"Or\",\n    \"operands\": [\n        {\n            \"path\": [\"review_body\"],\n            \"operator\": \"Like\",\n            \"valueString\": f\"*{substr}*\"\n        } for substr in substr_filters\n    ]\n}\n\n# Build the full filter combining price < 50, points > 90, and review_body substring filter\nwhere_filter = {\n    \"operator\": \"And\",\n    \"operands\": [\n        {\n            \"path\": [\"price\"],\n            \"operator\": \"LessThan\",\n            \"valueNumber\": 50\n        },\n        {\n            \"path\": [\"points\"],\n            \"operator\": \"GreaterThan\",\n            \"valueNumber\": 90\n        },\n        review_body_filter\n    ]\n}\n\n# Perform the hybrid query with alpha=0.5 and limit=5\nresponse = (\n    client.query.get(\"WineReview\", [\"title\", \"country\", \"price\", \"points\"])\n    .with_hybrid(query_text, alpha=0.5)\n    .with_limit(5)\n    .with_where(where_filter)\n    .do()\n)\n\n# Extract results\nresults = response.get(\"data\", {}).get(\"Get\", {}).get(\"WineReview\", [])\n\n# Print the results\nfor i, wine in enumerate(results, 1):\n    title = wine.get(\"title\", \"N/A\")\n    country = wine.get(\"country\", \"N/A\")\n    price = wine.get(\"price\", \"N/A\")\n    points = wine.get(\"points\", \"N/A\")\n    print(f\"{i}. Title: {title}\\n   Country: {country}\\n   Price: {price}\\n   Points: {points}\\n\")\n```\n",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:10: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 10, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T20:46:29.609731",
      "duration": 11.949652194976807,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\n\n# Read environment variables\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\nOPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    headers={\n        \"X-OpenAI-API-Key\": OPENAI_API_KEY\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Build the filter:\n# price < 50 AND points > 90 AND review_body contains any of the substrings\nfilter_ = (\n    Filter.by_property(\"price\").less_than(50) &\n    Filter.by_property(\"points\").greater_than(90) &\n    Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n)\n\n# Perform the hybrid query\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    filters=filter_,\n    return_metadata=MetadataQuery(score=True)\n)\n\n# Print the requested fields for each matching wine\nfor obj in response.objects:\n    props = obj.properties\n    title = props.get(\"title\", \"<no title>\")\n    country = props.get(\"country\", \"<no country>\")\n    price = props.get(\"price\", \"<no price>\")\n    points = props.get(\"points\", \"<no points>\")\n    print(f\"Title: {title}, Country: {country}, Price: {price}, Points: {points}\")\n\nclient.close()\n```",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir, Country: US, Price: 40.0, Points: 92\nTitle: Bink 2014 Pinot Noir (Anderson Valley), Country: US, Price: 49.0, Points: 91\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza), Country: Argentina, Price: 27.0, Points: 91\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji), Country: Hungary, Price: 25.0, Points: 93\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico), Country: Italy, Price: 0.0, Points: 92\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T20:46:37.668567",
      "duration": 7.621848821640015,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import Filter\n\n# Connect to Weaviate Cloud with API key and OpenAI API key in headers\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.AuthApiKey(api_key=os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Build the filter:\n# price < 50 AND points > 90 AND review_body contains at least one of the substrings\nprice_filter = Filter.by_property(\"price\").less_than(50)\npoints_filter = Filter.by_property(\"points\").greater_than(90)\n\n# For review_body substrings, use any_of with like filters (wildcard substring match)\nreview_substrings = [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\nreview_filters = [\n    Filter.by_property(\"review_body\").like(f\"*{substr}*\")\n    for substr in review_substrings\n]\nreview_filter = Filter.any_of(review_filters)\n\n# Combine all filters with AND\ncombined_filter = price_filter & points_filter & review_filter\n\n# Perform hybrid search with alpha=0.5, limit=5, with the filter\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    alpha=0.5,\n    limit=5,\n    filters=combined_filter,\n    return_properties=[\"title\", \"country\", \"price\", \"points\"]\n)\n\n# Print the results\nfor obj in response.objects:\n    props = obj.properties\n    print(f\"Title: {props.get('title')}\")\n    print(f\"Country: {props.get('country')}\")\n    print(f\"Price: {props.get('price')}\")\n    print(f\"Points: {props.get('points')}\")\n    print(\"-\" * 40)\n\n# Close client when done\nclient.close()\n```\n",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: 40.0\nPoints: 92\n----------------------------------------\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: 49.0\nPoints: 91\n----------------------------------------\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: 27.0\nPoints: 91\n----------------------------------------\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: 25.0\nPoints: 93\n----------------------------------------\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: 0.0\nPoints: 92\n----------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    }
  },
  "cohere/command-a-03-2025": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:46:41.580974",
      "duration": 3.8941800594329834,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to connect to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, and then check if the server is ready to accept requests:\n\n```python\nimport os\nimport weaviate\nfrom weaviate import WeaviateClient\nfrom weaviate.util import get_valid_uuid\n\n# Retrieve environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient: WeaviateClient = weaviate.connect_to_wcs(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=weaviate.auth.AuthApiKey(WCD_TEST_KEY),\n    headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\", \"\")  # Optional: If using OpenAI modules\n    }\n)\n\n# Check if the server is ready\nif client.is_ready():\n    print(\"Weaviate server is ready to accept requests.\")\nelse:\n    print(\"Weaviate server is not ready.\")\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the Weaviate Cloud URL and API key from the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n2. **Connection**: It uses `weaviate.connect_to_wcs()` to connect to the Weaviate Cloud instance. The `auth_credentials` parameter is set with the API key.\n3. **Server Readiness**: The `client.is_ready()` method checks if the Weaviate server is ready to accept requests. If it is, a success message is printed; otherwise, an error message is displayed.\n\nMake sure the required environment variables are set before running the script.",
      "stdout": "Weaviate server is ready to accept requests.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:46:45.131298",
      "duration": 3.5311999320983887,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to connect to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, and then check if the server is ready to accept requests:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Retrieve environment variables\ncluster_url = os.getenv(\"WCD_TEST_URL\")\napi_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Ensure environment variables are set\nif not cluster_url or not api_key:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set.\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Check if the server is ready\nassert client.is_ready(), \"Weaviate server is not ready.\"\n\n# Close the client connection\nclient.close()\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the `WCD_TEST_URL` and `WCD_TEST_KEY` from the environment using `os.getenv()`.\n2. **Error Handling**: It checks if the environment variables are set and raises an error if they are missing.\n3. **Connection**: It connects to the Weaviate Cloud instance using `weaviate.connect_to_weaviate_cloud()` with the provided URL and API key.\n4. **Readiness Check**: It verifies that the server is ready using `client.is_ready()` and asserts that it returns `True`.\n5. **Cleanup**: Finally, it closes the client connection using `client.close()`.\n\nThis code ensures a clean and efficient connection to Weaviate Cloud and verifies its readiness.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T20:46:50.484884",
      "duration": 5.334574937820435,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to create a collection named \"DemoProducts\" with the specified properties. The code also handles the case where the collection already exists by deleting it first. The connection to Weaviate Cloud is established using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Client\nfrom weaviate.util import generate_uuid5\n\n# Retrieve environment variables\nWEAVIATE_URL = os.getenv(\"WCD_TEST_URL\")\nWEAVIATE_API_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n# Initialize the Weaviate client\nclient = Client(\n    url=WEAVIATE_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WEAVIATE_API_KEY),\n    additional_headers={\"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")}  # Optional, if using OpenAI\n)\n\n# Define the collection name\ncollection_name = \"DemoProducts\"\n\n# Check if the collection exists and delete it if it does\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n    print(f\"Collection '{collection_name}' deleted.\")\n\n# Define the schema for the collection\nschema = {\n    \"classes\": [\n        {\n            \"class\": collection_name,\n            \"description\": \"A collection of demo products\",\n            \"properties\": [\n                {\n                    \"name\": \"name\",\n                    \"dataType\": [\"text\"],\n                    \"description\": \"The name of the product\"\n                },\n                {\n                    \"name\": \"description\",\n                    \"dataType\": [\"text\"],\n                    \"description\": \"The description of the product\"\n                },\n                {\n                    \"name\": \"price\",\n                    \"dataType\": [\"number\"],\n                    \"description\": \"The price of the product\"\n                },\n                {\n                    \"name\": \"in_stock\",\n                    \"dataType\": [\"boolean\"],\n                    \"description\": \"Whether the product is in stock\"\n                }\n            ]\n        }\n    ]\n}\n\n# Create the collection with the defined schema\nclient.collections.create(schema)\nprint(f\"Collection '{collection_name}' created successfully.\")\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the Weaviate Cloud URL and API key from environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n2. **Weaviate Client**: The client is initialized with the provided URL and API key.\n3. **Collection Existence Check**: The code checks if the collection `DemoProducts` already exists. If it does, the collection is deleted.\n4. **Schema Definition**: The schema for the `DemoProducts` collection is defined with the required properties (`name`, `description`, `price`, `in_stock`).\n5. **Collection Creation**: The collection is created using the defined schema.\n\nMake sure to install the Weaviate Python client library if you haven't already:\n\n```bash\npip install weaviate-client\n```\n\nAlso, ensure that the required environment variables (`WCD_TEST_URL`, `WCD_TEST_KEY`, and optionally `OPENAI_API_KEY`) are set before running the script.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:11: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 11, in <module>\n    client = Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T20:46:55.401375",
      "duration": 4.898437738418579,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to create a collection named `\"DemoProducts\"` with the specified properties. The code connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`. If the collection already exists, it deletes it first.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Retrieve environment variables for Weaviate Cloud connection\nCLUSTER_URL = os.getenv(\"WCD_TEST_URL\")\nAPI_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not CLUSTER_URL or not API_KEY:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set.\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=CLUSTER_URL,\n    auth_credentials=Auth.api_key(API_KEY)\n)\n\n# Define the collection name\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n    print(f\"Deleted existing collection: {collection_name}\")\n\n# Create the collection with the specified properties\nproducts_collection = client.collections.create(\n    name=collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close the connection\nclient.close()\n```\n\n### Key Points:\n1. **Environment Variables**: The code retrieves the Weaviate Cloud URL and API key from the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n2. **Collection Deletion**: If the collection `\"DemoProducts\"` already exists, it is deleted before creating a new one.\n3. **Properties**: The collection is created with the specified properties: `name`, `description`, `price`, and `in_stock`.\n4. **Connection Closure**: The connection to Weaviate Cloud is closed after the operation is complete.\n\nMake sure the environment variables are properly set in your environment before running the script.",
      "stdout": "Deleted existing collection: DemoProducts\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 35, in <module>\n    Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n  File \"/usr/local/lib/python3.9/enum.py\", line 429, in __getattr__\n    raise AttributeError(name) from None\nAttributeError: BOOLEAN\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "extensive_examples_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T20:47:00.484170",
      "duration": 5.064625024795532,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here\u2019s the Python code to create a collection named \"DemoProducts\" with the specified properties, using the latest Weaviate client syntax. The code connects to Weaviate Cloud using environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, and deletes the collection if it already exists.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Configure, Property, DataType\nfrom weaviate.classes.init import Auth\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n)\n\n# Define the collection name\ncollection_name = \"DemoProducts\"\n\n# Check if the collection exists and delete it if necessary\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\n# Create the collection with the specified properties\nclient.collections.create(\n    name=collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n    ]\n)\n\n# Close the client connection\nclient.close()\n```\n\n### Explanation:\n1. **Environment Variables**: The code uses `os.environ` to access the Weaviate Cloud URL (`WCD_TEST_URL`) and API key (`WCD_TEST_KEY`).\n2. **Collection Existence Check**: Before creating the collection, the code checks if it already exists using `client.collections.exists()`. If it does, the collection is deleted using `client.collections.delete()`.\n3. **Collection Creation**: The collection is created with the specified properties (`name`, `description`, `price`, `in_stock`) using the `client.collections.create()` method.\n4. **Connection Closure**: The client connection is closed using `client.close()` to ensure resources are properly released.\n\nThis code ensures the collection is created with the correct properties and handles the case where the collection might already exist.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 26, in <module>\n    Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n  File \"/usr/local/lib/python3.9/enum.py\", line 429, in __getattr__\n    raise AttributeError(name) from None\nAttributeError: BOOLEAN\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:47:05.943976",
      "duration": 4.7961812019348145,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to achieve the task you described. The code connects to Weaviate Cloud, creates a collection named \"DemoProducts\", batch imports 50 arbitrary objects, and then prints the number of objects in the collection.\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Client\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.collections.classes.batch import BatchObjectReturn\n\n# Connect to Weaviate Cloud using environment variables\nWEAVIATE_URL = os.getenv(\"WCD_TEST_URL\")\nWEAVIATE_API_KEY = os.getenv(\"WCD_TEST_KEY\")\n\nclient = Client(\n    url=WEAVIATE_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WEAVIATE_API_KEY),\n)\n\n# Define the collection schema\ncollection_name = \"DemoProducts\"\ntry:\n    client.collections.delete(collection_name)  # Delete if it already exists\nexcept:\n    pass\n\ndemo_products = client.collections.create(\n    name=collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n    ],\n)\n\n# Prepare batch objects\nbatch_objects = []\nfor i in range(50):\n    obj = {\n        \"name\": f\"Product {i}\",\n        \"description\": f\"Description {i}\",\n    }\n    batch_objects.append(obj)\n\n# Batch import objects\nwith demo_products.batch.dynamic() as batch:\n    batch.add_objects(batch_objects)\n\n# Print the number of objects in the collection\nobject_count = demo_products.aggregate.over_all().total_count()\nprint(f\"Number of objects in the collection: {object_count}\")\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the Weaviate Cloud URL and API key from environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n2. **Collection Creation**: It defines a collection named \"DemoProducts\" with two text properties: `name` and `description`.\n3. **Batch Import**: It generates 50 simple objects and imports them in a batch.\n4. **Object Count**: Finally, it retrieves and prints the total number of objects in the collection.\n\nMake sure the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` are set before running the script.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:11: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 11, in <module>\n    client = Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:47:12.583635",
      "duration": 6.000443935394287,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to achieve the task you described. The code connects to Weaviate Cloud using environment variables, creates a collection named \"DemoProducts\", batch imports 50 arbitrary objects, and then prints the number of objects in the collection.\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Auth\n\n# Retrieve Weaviate Cloud credentials from environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_wcs(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\", \"\")  # Optional: for hybrid search\n    }\n)\n\n# Define the collection schema\ncollection_name = \"DemoProducts\"\nclient.collections.create(\n    name=collection_name,\n    properties=[\n        {\"name\": \"name\", \"dataType\": [\"text\"]},\n        {\"name\": \"description\", \"dataType\": [\"text\"]},\n    ],\n)\n\n# Prepare 50 arbitrary objects for batch import\ndata_objects = [\n    {\n        \"name\": f\"Product {i}\",\n        \"description\": f\"Description {i}\"\n    }\n    for i in range(50)\n]\n\n# Batch import objects into the collection\nwith client.collections.get(collection_name).batch.dynamic() as batch:\n    for obj in data_objects:\n        batch.add_object(properties=obj)\n        if batch.number_errors > 0:\n            print(f\"Errors occurred during batch import: {batch.errors}\")\n            break\n\n# Check for failed objects\nfailed_objects = client.collections.get(collection_name).batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\n# Print the number of objects in the collection\nobject_count = client.collections.get(collection_name).aggregate.total()\nprint(f\"Number of objects in {collection_name}: {object_count}\")\n\n# Close the client connection\nclient.close()\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the Weaviate Cloud URL and API key from environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n2. **Connection**: It connects to Weaviate Cloud using `weaviate.connect_to_wcs`.\n3. **Collection Creation**: The `DemoProducts` collection is created with `name` and `description` properties of type `text`.\n4. **Batch Import**: 50 objects are generated and imported in batches using `batch.add_object`.\n5. **Error Handling**: Errors during batch import are checked and printed.\n6. **Object Count**: The total number of objects in the collection is retrieved using `aggregate.total()` and printed.\n7. **Cleanup**: The client connection is closed to free up resources.\n\nMake sure to install the Weaviate Python client library using `pip install weaviate-client` before running the code.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 3, in <module>\n    from weaviate import Auth\nImportError: cannot import name 'Auth' from 'weaviate' (/usr/local/lib/python3.9/site-packages/weaviate/__init__.py)\n",
      "exit_code": 1
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:47:19.486905",
      "duration": 6.212140798568726,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here\u2019s the Python code to create a collection named \"DemoProducts\" with the specified properties, batch import 50 objects, and print the number of objects in the collection using the latest Weaviate client syntax. The code connects to Weaviate Cloud using environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Client\nfrom weaviate.classes.config import Configure, Property, DataType\nfrom weaviate.classes.data import DataObject\n\n# Connect to Weaviate Cloud\nclient = Client(\n    url=os.environ[\"WCD_TEST_URL\"],\n    auth_client_secret=weaviate.AuthApiKey(os.environ[\"WCD_TEST_KEY\"]),\n)\n\n# Create the \"DemoProducts\" collection\nclient.collections.create(\n    name=\"DemoProducts\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n    ],\n    vector_config=Configure.Vectors.text2vec_openai(),  # Optional: Add vectorization\n)\n\n# Batch import 50 objects\ndemo_products = client.collections.get(\"DemoProducts\")\nwith demo_products.batch.fixed_size(batch_size=50) as batch:\n    for i in range(50):\n        batch.add_object(\n            properties={\n                \"name\": f\"Product {i}\",\n                \"description\": f\"Description {i}\",\n            }\n        )\n\n# Print the number of objects in the collection\ncount = demo_products.aggregate.over_all().total_count\nprint(f\"Number of objects in the collection: {count}\")\n\n# Close the client\nclient.close()\n```\n\n### Explanation:\n1. **Connection to Weaviate Cloud**:\n   - Uses `Client` with `url` and `auth_client_secret` to connect to Weaviate Cloud using the provided environment variables.\n\n2. **Collection Creation**:\n   - Creates a collection named \"DemoProducts\" with two properties: `name` and `description`, both of type `TEXT`.\n   - Optionally, adds vectorization using OpenAI's `text2vec-openai` model.\n\n3. **Batch Import**:\n   - Uses a fixed-size batch to import 50 objects into the collection. Each object has a `name` and `description` with incremental values.\n\n4. **Counting Objects**:\n   - Uses the `aggregate.over_all().total_count` method to get the total number of objects in the collection and prints it.\n\n5. **Closing the Client**:\n   - Ensures the client connection is closed after operations are complete.\n\nMake sure the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` are set before running the script.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:8: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 8, in <module>\n    client = Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T20:47:25.079380",
      "duration": 5.158510208129883,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to query the `WineReview` collection and find wines that best match the query \"dessert wine\", with a limit of 2 results. The code uses the `text2vec-openai` vectorizer and connects to Weaviate Cloud using the provided environment variables.\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Client\nfrom weaviate.util import generate_uuid5\n\n# Connect to Weaviate Cloud\nclient = Client(\n    url=os.getenv(\"WCD_TEST_URL\"),\n    auth_client_secret=weaviate.AuthApiKey(api_key=os.getenv(\"WCD_TEST_KEY\")),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")  # Pass OpenAI API key\n    }\n)\n\n# Define the query\nquery = \"dessert wine\"\n\n# Perform the hybrid search (combines BM25 and vector search)\nresponse = client.query.get(\n    class_name=\"WineReview\",\n    properties=[\"title\", \"country\", \"price\", \"points\"],\n    hybrid={\n        \"query\": query,\n        \"alpha\": 0.5  # Balance between vector and keyword search\n    },\n    limit=2  # Limit to 2 results\n)\n\n# Extract and print the results\nfor result in response[\"data\"][\"Get\"][\"WineReview\"]:\n    print(f\"Title: {result['title']}\")\n    print(f\"Country: {result['country']}\")\n    print(f\"Price: {result['price']}\")\n    print(f\"Points: {result['points']}\")\n    print(\"-\" * 40)\n```\n\n### Explanation:\n1. **Weaviate Client Initialization**:\n   - The client is initialized with the Weaviate Cloud URL (`WCD_TEST_URL`) and API key (`WCD_TEST_KEY`).\n   - The OpenAI API key (`OPENAI_API_KEY`) is passed in the `additional_headers` to enable the `text2vec-openai` vectorizer.\n\n2. **Hybrid Search**:\n   - The query uses a hybrid search approach, combining BM25 (keyword search) and vector search (`alpha=0.5`).\n   - The `limit=2` parameter ensures only the top 2 matching results are returned.\n\n3. **Result Extraction**:\n   - The code extracts and prints the `title`, `country`, `price`, and `points` of each matching wine.\n\n### Prerequisites:\n- Ensure the environment variables `WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY` are set in your environment.\n- Install the Weaviate Python client: `pip install weaviate-client`.\n\nThis code will output the details of the top 2 wines that best match the query \"dessert wine\" from the `WineReview` collection.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:7: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 7, in <module>\n    client = Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:47:31.075862",
      "duration": 5.60405707359314,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to query the `WineReview` collection for wines that best match the query \"dessert wine\", with a limit of 2 results. The code uses the environment variables `WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY` as specified.\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Retrieve environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    headers={\n        \"X-OpenAI-API-Key\": OPENAI_API_KEY\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Query for wines matching \"dessert wine\" with a limit of 2 results\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2,\n    return_properties=[\"title\", \"country\", \"price\", \"points\"]  # Specify properties to return\n)\n\n# Print the desired properties of each matching wine\nfor obj in response.objects:\n    print(f\"Title: {obj.properties['title']}\")\n    print(f\"Country: {obj.properties['country']}\")\n    print(f\"Price: {obj.properties['price']}\")\n    print(f\"Points: {obj.properties['points']}\")\n    print(\"-\" * 40)\n\n# Close the client connection\nclient.close()\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the necessary environment variables (`WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY`).\n2. **Weaviate Connection**: It connects to the Weaviate Cloud instance using the provided URL and API key, and includes the OpenAI API key in the headers for vectorization.\n3. **Collection Access**: It accesses the `WineReview` collection.\n4. **Query Execution**: It performs a `near_text` query with the search term \"dessert wine\" and limits the results to 2. The `return_properties` parameter specifies which fields to retrieve.\n5. **Result Printing**: It prints the `title`, `country`, `price`, and `points` of each matching wine.\n6. **Connection Closure**: Finally, it closes the Weaviate client connection.\n\nMake sure the environment variables are correctly set in your environment before running the script.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:47:37.369052",
      "duration": 5.925315856933594,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to query the `WineReview` collection and find wines that best match the query \"dessert wine\", with a limit of maximum 2 results. The code also prints the title, country, price, and points of each matching wine.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import MetadataQuery\nfrom weaviate.classes.config import Configure\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.classes.init.Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\n# Get the WineReview collection\nwine_collection = client.collections.get(\"WineReview\")\n\n# Perform a semantic search for \"dessert wine\" with a limit of 2 results\nresponse = wine_collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2,\n    return_metadata=MetadataQuery(distance=True)\n)\n\n# Print the results\nfor obj in response.objects:\n    properties = obj.properties\n    print(f\"Title: {properties['title']}\")\n    print(f\"Country: {properties['country']}\")\n    print(f\"Price: {properties['price']}\")\n    print(f\"Points: {properties['points']}\")\n    print(f\"Distance: {obj.metadata.distance}\\n\")\n\n# Close the client\nclient.close()\n```\n\n### Explanation:\n1. **Connection to Weaviate Cloud**: The code connects to Weaviate Cloud using the provided environment variables (`WCD_TEST_URL` and `WCD_TEST_KEY`). It also includes the OpenAI API key for vectorization.\n2. **Collection Access**: The `WineReview` collection is accessed using `client.collections.get(\"WineReview\")`.\n3. **Semantic Search**: The `near_text` method is used to perform a semantic search for the query \"dessert wine\". The `limit` parameter is set to 2 to retrieve a maximum of 2 results.\n4. **Result Printing**: The code iterates over the search results and prints the `title`, `country`, `price`, and `points` of each matching wine, along with the distance score.\n5. **Client Closure**: The client is closed at the end to release resources.\n\nMake sure the environment variables (`WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY`) are properly set before running the script.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\nDistance: 0.4766477346420288\n\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\nDistance: 0.4812379479408264\n\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T20:47:45.367872",
      "duration": 7.589271783828735,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to perform the specified query:\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Client\nfrom weaviate.util import generate_uuid5\n\n# Connect to Weaviate Cloud\nclient = Client(\n    url=os.getenv(\"WCD_TEST_URL\"),\n    auth_client_secret=weaviate.AuthApiKey(api_key=os.getenv(\"WCD_TEST_KEY\")),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")\n    }\n)\n\n# Define the query\nquery = \"\"\"\n{\n  Get {\n    WineReview(\n      hybrid: { query: \"pair with steak\", alpha: 0.5 }\n      where: {\n        operator: And\n        path: [\"price\", \"points\", \"review_body\"]\n        value: [\n          { operator: LessThan, value: 50 },\n          { operator: GreaterThan, value: 90 },\n          {\n            operator: Like\n            value: [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n            operator: Or\n          }\n        ]\n      }\n      limit: 5\n    ) {\n      title\n      country\n      price\n      points\n    }\n  }\n}\n\"\"\"\n\n# Execute the query\nresponse = client.query.raw(query)\n\n# Extract and print results\nresults = response[\"data\"][\"Get\"][\"WineReview\"]\nfor wine in results:\n    print(f\"Title: {wine['title']}\")\n    print(f\"Country: {wine['country']}\")\n    print(f\"Price: {wine['price']}\")\n    print(f\"Points: {wine['points']}\")\n    print(\"-\" * 40)\n```\n\n### Explanation:\n1. **Connection to Weaviate Cloud**:\n   - Uses `weaviate.Client` with the URL and API key from environment variables (`WCD_TEST_URL` and `WCD_TEST_KEY`).\n   - Includes the OpenAI API key in the headers for the `text2vec-openai` vectorizer.\n\n2. **Query Construction**:\n   - Performs a **hybrid search** with `query: \"pair with steak\"` and `alpha: 0.5`.\n   - Applies filters using the `where` clause:\n     - `price < 50`.\n     - `points > 90`.\n     - `review_body` contains at least one of the specified substrings (`spice`, `fruit`, etc.) using the `Like` operator with `Or`.\n   - Limits the results to 5 using `limit: 5`.\n\n3. **Result Extraction**:\n   - Extracts and prints the `title`, `country`, `price`, and `points` for each matching wine.\n\n### Notes:\n- Ensure the `weaviate-client` Python package is installed (`pip install weaviate-client`).\n- Replace the `query` string with the appropriate GraphQL syntax if the schema or requirements differ.\n- Error handling and environment variable checks are omitted for brevity but should be added in production code.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:7: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 7, in <module>\n    client = Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T20:47:55.577816",
      "duration": 9.819196939468384,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to achieve the desired query. The code connects to Weaviate Cloud, performs a hybrid search on the `WineReview` collection, and filters the results based on the specified criteria. It then prints the `title`, `country`, `price`, and `points` of each matching wine.\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\nimport os\n\n# Retrieve environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    headers={\n        \"X-OpenAI-API-Key\": OPENAI_API_KEY\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform hybrid search with filters\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    filters=Filter.by_properties(\n        [\n            Filter.by_property(\"price\").less_than(50),\n            Filter.by_property(\"points\").greater_than(90),\n            Filter.by_property(\"review_body\").contains_any(\n                [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n            ),\n        ]\n    ).as_operator(Filter.Operator.AND),\n    return_metadata=True,\n)\n\n# Print the results\nfor obj in response.objects:\n    wine = obj.properties\n    print(f\"Title: {wine['title']}\")\n    print(f\"Country: {wine['country']}\")\n    print(f\"Price: {wine['price']}\")\n    print(f\"Points: {wine['points']}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(\"-\" * 40)\n\n# Close the client\nclient.close()\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the necessary environment variables (`WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY`).\n2. **Weaviate Connection**: It connects to the Weaviate Cloud instance using the provided URL and API key.\n3. **Collection Access**: It accesses the `WineReview` collection.\n4. **Hybrid Search**: It performs a hybrid search with the query `\"pair with steak\"`, a limit of 5 results, and an alpha value of 0.5.\n5. **Filters**: It applies filters to ensure:\n   - `price` is less than 50.\n   - `points` is greater than 90.\n   - `review_body` contains at least one of the specified substrings.\n6. **Results**: It prints the `title`, `country`, `price`, and `points` of each matching wine, along with the search score.\n7. **Close Connection**: Finally, it closes the Weaviate client connection.\n\nMake sure the environment variables are correctly set in your environment before running the code.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 28, in <module>\n    filters=Filter.by_properties(\nAttributeError: type object 'Filter' has no attribute 'by_properties'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T20:48:07.082092",
      "duration": 11.121641874313354,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to perform the requested query:\n\n```python\nimport weaviate\nfrom weaviate.classes.query import Filter, HybridFusion\nfrom weaviate.classes.config import Configure\nimport os\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.classes.init.Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\n# Get the WineReview collection\nwine_collection = client.collections.get(\"WineReview\")\n\n# Define the hybrid search query with filters\nresponse = wine_collection.query.hybrid(\n    query=\"pair with steak\",\n    alpha=0.5,\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    filters=Filter.by_property(\"price\").less_than(50) &\n           Filter.by_property(\"points\").greater_than(90) &\n           (Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])),\n    return_properties=[\"title\", \"country\", \"price\", \"points\"]\n)\n\n# Print the results\nfor wine in response.objects:\n    print(f\"Title: {wine.properties['title']}\")\n    print(f\"Country: {wine.properties['country']}\")\n    print(f\"Price: {wine.properties['price']}\")\n    print(f\"Points: {wine.properties['points']}\")\n    print(\"---\")\n\n# Close the client\nclient.close()\n```\n\n### Explanation:\n1. **Connection to Weaviate Cloud**: The code connects to Weaviate Cloud using the provided environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`. The `OPENAI_API_KEY` is also included in the headers for the `text2vec-openai` vectorizer.\n\n2. **Collection Access**: The `WineReview` collection is accessed using `client.collections.get(\"WineReview\")`.\n\n3. **Hybrid Search**: The `query.hybrid` method is used to perform a hybrid search with `alpha=0.5`, balancing between keyword and vector search.\n\n4. **Filters**: The `filters` parameter ensures that only wines with a price less than 50, points greater than 90, and a review body containing at least one of the specified substrings are returned.\n\n5. **Result Properties**: The `return_properties` parameter specifies that only the `title`, `country`, `price`, and `points` fields are returned for each matching wine.\n\n6. **Output**: The results are printed in a formatted manner.\n\nMake sure the environment variables `WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY` are set before running the script.",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: 40.0\nPoints: 92\n---\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: 49.0\nPoints: 91\n---\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: 27.0\nPoints: 91\n---\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: 25.0\nPoints: 93\n---\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: 0.0\nPoints: 92\n---\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    }
  },
  "anthropic/claude-sonnet-4-20250514": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:48:13.158251",
      "duration": 6.057076930999756,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "Here's Python code using the latest Weaviate client syntax to connect to Weaviate Cloud and check if the server is ready:\n\n```python\nimport os\nimport weaviate\n\n# Get environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=weaviate.auth.AuthApiKey(wcd_key)\n)\n\ntry:\n    # Check if the server is ready\n    if client.is_ready():\n        print(\"Weaviate server is ready to accept requests!\")\n    else:\n        print(\"Weaviate server is not ready.\")\n        \nexcept Exception as e:\n    print(f\"Error checking server readiness: {e}\")\n    \nfinally:\n    # Close the connection\n    client.close()\n```\n\nThis code:\n1. Imports the necessary modules\n2. Retrieves the environment variables for the Weaviate Cloud URL and API key\n3. Connects to Weaviate Cloud using the latest client syntax with `connect_to_weaviate_cloud()`\n4. Uses API key authentication with `weaviate.auth.AuthApiKey()`\n5. Checks if the server is ready using `client.is_ready()`\n6. Properly closes the connection when done\n\nMake sure you have the latest Weaviate Python client installed:\n```bash\npip install weaviate-client\n```",
      "stdout": "Weaviate server is ready to accept requests!\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:48:17.629471",
      "duration": 4.4522669315338135,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to connect to Weaviate Cloud using environment variables:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\"))\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready()\n\n# Close the connection\nclient.close()\n```\n\nThis code:\n1. Imports the necessary modules including `os` for environment variables\n2. Uses `os.getenv()` to retrieve the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables\n3. Connects to the Weaviate Cloud instance using these credentials\n4. Checks if the server is ready using `client.is_ready()`\n5. Closes the connection when done",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:48:26.483654",
      "duration": 8.83641791343689,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "Here's Python code using the latest Weaviate client syntax to create the \"DemoProducts\" collection:\n\n```python\nimport weaviate\nimport os\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=weaviate.auth.AuthApiKey(os.getenv(\"WCD_TEST_KEY\"))\n)\n\ntry:\n    # Check if collection exists and delete it if it does\n    if client.collections.exists(\"DemoProducts\"):\n        client.collections.delete(\"DemoProducts\")\n        print(\"Existing 'DemoProducts' collection deleted.\")\n    \n    # Create the DemoProducts collection with specified properties\n    client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL)\n        ]\n    )\n    \n    print(\"'DemoProducts' collection created successfully!\")\n    \n    # Verify the collection was created\n    collection = client.collections.get(\"DemoProducts\")\n    print(f\"Collection '{collection.name}' is ready to use.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Imports**: Imports the necessary Weaviate client modules and os for environment variables\n2. **Connection**: Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n3. **Collection Management**: Checks if the \"DemoProducts\" collection already exists and deletes it if found\n4. **Collection Creation**: Creates a new \"DemoProducts\" collection with the four specified properties:\n   - `name` (text)\n   - `description` (text) \n   - `price` (number)\n   - `in_stock` (boolean)\n5. **Error Handling**: Includes try-except-finally blocks for proper error handling and connection cleanup\n6. **Verification**: Confirms the collection was created successfully\n\nMake sure you have the Weaviate Python client installed:\n```bash\npip install weaviate-client\n```\n\nAnd ensure your environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` are properly set before running the code.",
      "stdout": "Existing 'DemoProducts' collection deleted.\n'DemoProducts' collection created successfully!\nCollection 'DemoProducts' is ready to use.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:48:33.184817",
      "duration": 6.682286024093628,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to create the \"DemoProducts\" collection:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\"))\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n    print(f\"Deleted existing collection: {collection_name}\")\n\n# Create the new collection with the specified properties\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n```\n\nThis code:\n\n1. **Imports the necessary modules** from the Weaviate client library\n2. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n3. **Checks if the collection exists** and deletes it if it does\n4. **Creates the new collection** with the four specified properties:\n   - `name` (text)\n   - `description` (text) \n   - `price` (number)\n   - `in_stock` (boolean)\n5. **Prints confirmation** and closes the connection\n\nMake sure you have the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` set in your environment before running this code.",
      "stdout": "Deleted existing collection: DemoProducts\nCreated collection: DemoProducts\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:48:42.484770",
      "duration": 9.280884027481079,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to create the \"DemoProducts\" collection using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\ntry:\n    # Check if the collection already exists and delete it if it does\n    if client.collections.exists(\"DemoProducts\"):\n        print(\"Collection 'DemoProducts' already exists. Deleting it...\")\n        client.collections.delete(\"DemoProducts\")\n        print(\"Collection 'DemoProducts' deleted successfully.\")\n    \n    # Create the DemoProducts collection with the specified properties\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n    \n    print(\"Collection 'DemoProducts' created successfully with properties:\")\n    print(\"- name (text)\")\n    print(\"- description (text)\")\n    print(\"- price (number)\")\n    print(\"- in_stock (boolean)\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the `connect_to_weaviate_cloud()` method with the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Checks if the collection exists** using `client.collections.exists()`\n3. **Deletes the existing collection** if it exists using `client.collections.delete()`\n4. **Creates the new collection** with the specified properties:\n   - `name` as a TEXT property\n   - `description` as a TEXT property  \n   - `price` as a NUMBER property (floating point)\n   - `in_stock` as a BOOL property\n5. **Properly closes the connection** using a try/finally block\n\nMake sure you have the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` set before running this code.",
      "stdout": "Collection 'DemoProducts' already exists. Deleting it...\nCollection 'DemoProducts' deleted successfully.\nCollection 'DemoProducts' created successfully with properties:\n- name (text)\n- description (text)\n- price (number)\n- in_stock (boolean)\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T20:48:55.209077",
      "duration": 12.075101852416992,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Here's Python code using the latest Weaviate client syntax to accomplish your requirements:\n\n```python\nimport weaviate\nimport os\nfrom weaviate.classes.config import Configure\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=weaviate.auth.AuthApiKey(os.getenv(\"WCD_TEST_KEY\"))\n)\n\ntry:\n    # Create the collection with the specified properties\n    collection = client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            weaviate.classes.config.Property(\n                name=\"name\",\n                data_type=weaviate.classes.config.DataType.TEXT\n            ),\n            weaviate.classes.config.Property(\n                name=\"description\", \n                data_type=weaviate.classes.config.DataType.TEXT\n            )\n        ]\n    )\n    print(\"Collection 'DemoProducts' created successfully!\")\n    \n    # Get reference to the collection\n    demo_products = client.collections.get(\"DemoProducts\")\n    \n    # Prepare 50 objects for batch import\n    objects_to_insert = []\n    for i in range(1, 51):\n        objects_to_insert.append({\n            \"name\": f\"Product {i}\",\n            \"description\": f\"Description {i}\"\n        })\n    \n    # Batch import the objects\n    response = demo_products.data.insert_many(objects_to_insert)\n    \n    # Check for any errors during insertion\n    if response.has_errors:\n        print(\"Some objects failed to insert:\")\n        for error in response.errors:\n            print(f\"Error: {error}\")\n    else:\n        print(f\"Successfully inserted {len(objects_to_insert)} objects!\")\n    \n    # Print the number of objects in the collection\n    total_objects = demo_products.aggregate.over_all(total_count=True)\n    print(f\"Total number of objects in 'DemoProducts' collection: {total_objects.total_count}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n\n2. **Creates a collection** named \"DemoProducts\" with two text properties:\n   - `name` (text property)\n   - `description` (text property)\n\n3. **Batch imports 50 objects** with the simple structure you specified:\n   - Product 1, Product 2, ..., Product 50\n   - Description 1, Description 2, ..., Description 50\n\n4. **Prints the total count** of objects in the collection\n\n5. **Handles errors** and ensures the client connection is properly closed\n\nMake sure you have the required environment variables set:\n```bash\nexport WCD_TEST_URL=\"your-weaviate-cloud-url\"\nexport WCD_TEST_KEY=\"your-api-key\"\n```\n\nAnd install the Weaviate client if you haven't already:\n```bash\npip install weaviate-client\n```\n\nThe code uses the latest Weaviate Python client (v4) syntax with proper error handling and resource cleanup.",
      "stdout": "An error occurred: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'class name DemoProducts already exists'}]}.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T20:49:08.060989",
      "duration": 12.155640125274658,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to accomplish your requirements:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.auth import Auth\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\")),\n)\n\ntry:\n    # Create the collection if it doesn't exist\n    if not client.collections.exists(\"DemoProducts\"):\n        client.collections.create(\n            name=\"DemoProducts\",\n            properties=[\n                weaviate.classes.Property(name=\"name\", data_type=weaviate.classes.DataType.TEXT),\n                weaviate.classes.Property(name=\"description\", data_type=weaviate.classes.DataType.TEXT),\n            ]\n        )\n        print(\"Collection 'DemoProducts' created.\")\n    else:\n        print(\"Collection 'DemoProducts' already exists.\")\n\n    # Get the collection\n    collection = client.collections.get(\"DemoProducts\")\n\n    # Create 50 arbitrary objects\n    data_rows = [\n        {\n            \"name\": f\"Product {i}\",\n            \"description\": f\"Description {i}\"\n        } for i in range(1, 51)\n    ]\n\n    # Batch import the objects\n    with collection.batch.dynamic() as batch:\n        for data_row in data_rows:\n            batch.add_object(\n                properties=data_row,\n            )\n            if batch.number_errors > 10:\n                print(\"Batch import stopped due to excessive errors.\")\n                break\n\n    # Check for failed objects\n    failed_objects = collection.batch.failed_objects\n    if failed_objects:\n        print(f\"Number of failed imports: {len(failed_objects)}\")\n        print(f\"First failed object: {failed_objects[0]}\")\n    else:\n        print(\"All objects imported successfully!\")\n\n    # Print the number of objects in the collection\n    print(f\"Number of objects in collection: {len(collection)}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Creates the collection** \"DemoProducts\" with the specified properties (name and description as text properties) if it doesn't already exist\n3. **Generates 50 objects** with the format you specified: `{\"name\": \"Product {i}\", \"description\": \"Description {i}\"}`\n4. **Batch imports** all 50 objects using the dynamic batch functionality\n5. **Handles errors** by checking for failed objects and stopping if there are too many errors\n6. **Prints the total number** of objects in the collection\n7. **Properly closes** the client connection\n\nMake sure you have the required environment variables set:\n- `WCD_TEST_URL`: Your Weaviate Cloud instance URL\n- `WCD_TEST_KEY`: Your Weaviate Cloud API key\n\nAlso ensure you have the latest Weaviate client installed:\n```bash\npip install weaviate-client\n```",
      "stdout": "Collection 'DemoProducts' already exists.\nAll objects imported successfully!\nNumber of objects in collection: 50\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:49:21.449520",
      "duration": 12.741870164871216,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to create a collection, batch import 50 objects, and print the count using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\ntry:\n    # Create the DemoProducts collection with name and description properties\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ]\n    )\n    \n    # Get the collection\n    collection = client.collections.get(\"DemoProducts\")\n    \n    # Batch import 50 objects using fixed_size batch (recommended approach)\n    with collection.batch.fixed_size(batch_size=50) as batch:\n        for i in range(50):\n            batch.add_object(\n                properties={\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"Description {i}\"\n                }\n            )\n    \n    # Check for any batch errors\n    if collection.batch.failed_objects:\n        print(f\"Number of failed objects: {len(collection.batch.failed_objects)}\")\n    \n    # Get the total count of objects in the collection\n    response = collection.query.fetch_objects(limit=0)  # limit=0 to get count without objects\n    total_count = len(list(collection.iterator()))  # Use iterator to get accurate count\n    \n    print(f\"Number of objects in DemoProducts collection: {total_count}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Creates a collection** named \"DemoProducts\" with two text properties: `name` and `description`\n3. **Batch imports 50 objects** using the recommended `fixed_size` batch approach for optimal performance\n4. **Handles errors** by checking for failed objects after the batch operation\n5. **Counts the objects** in the collection using the iterator method for an accurate count\n6. **Prints the total count** of objects in the collection\n7. **Properly closes** the client connection using a try/finally block\n\nThe batch import uses `fixed_size(batch_size=50)` which is the recommended approach for batch operations as it provides good performance while managing memory usage effectively.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\nTraceback (most recent call last):\n  File \"/code/code.py\", line 14, in <module>\n    client.collections.create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/sync.py\", line 107, in create\n    self.__loop.run_until_complete(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/event_loop.py\", line 42, in run_until_complete\n    return fut.result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 446, in result\n    return self.__get_result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 391, in __get_result\n    raise self._exception\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/async_.py\", line 134, in create\n    name = await super()._create(config._to_dict())\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/base.py\", line 27, in _create\n    response = await self._connection.post(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 550, in post\n    return await self.__send(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 505, in __send\n    raise e\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 496, in __send\n    raise UnexpectedStatusCodeError(error_msg, response=res)\nweaviate.exceptions.UnexpectedStatusCodeError: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'class name DemoProducts already exists'}]}.\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:49:33.857024",
      "duration": 12.023459196090698,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to query the 'WineReview' collection:\n\n```python\nimport weaviate\nimport os\nfrom weaviate.classes.query import MetadataQuery\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=weaviate.auth.AuthApiKey(os.getenv(\"WCD_TEST_KEY\")),\n    headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_reviews = client.collections.get(\"WineReview\")\n    \n    # Perform a vector search for \"dessert wine\"\n    response = wine_reviews.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_metadata=MetadataQuery(distance=True)\n    )\n    \n    # Print the results\n    print(f\"Found {len(response.objects)} matching wines:\\n\")\n    \n    for i, wine in enumerate(response.objects, 1):\n        print(f\"Wine {i}:\")\n        print(f\"  Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"  Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"  Price: ${wine.properties.get('price', 'N/A')}\")\n        print(f\"  Points: {wine.properties.get('points', 'N/A')}\")\n        print(f\"  Distance: {wine.metadata.distance:.4f}\")\n        print()\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Imports**: Imports the necessary Weaviate client modules and os for environment variables\n2. **Connection**: Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, and includes the OpenAI API key in the headers\n3. **Query**: Uses `near_text()` to perform a semantic search for \"dessert wine\" with a limit of 2 results\n4. **Results**: Iterates through the results and prints the title, country, price, and points for each matching wine\n5. **Error handling**: Includes try-except-finally blocks for proper error handling and connection cleanup\n6. **Metadata**: Also includes the distance score to show how closely each result matches the query\n\nThe code uses the latest Weaviate Python client (v4) syntax with the `connect_to_weaviate_cloud()` method and the new query interface.",
      "stdout": "Found 2 matching wines:\n\nWine 1:\n  Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price: $24.0\n  Points: 88\n  Distance: 0.4766\n\nWine 2:\n  Title: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price: $40.0\n  Points: 88\n  Distance: 0.4812\n\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:49:45.476614",
      "duration": 11.154249906539917,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to query the 'WineReview' collection for wines matching \"dessert wine\":\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\")),\n    headers={\n        \"X-OpenAI-API-Key\": os.getenv(\"OPENAI_API_KEY\")\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Query for wines that best match \"dessert wine\"\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2\n)\n\n# Print the title, country, price, and points of each matching wine\nfor obj in response.objects:\n    properties = obj.properties\n    print(f\"Title: {properties.get('title', 'N/A')}\")\n    print(f\"Country: {properties.get('country', 'N/A')}\")\n    print(f\"Price: {properties.get('price', 'N/A')}\")\n    print(f\"Points: {properties.get('points', 'N/A')}\")\n    print(\"-\" * 40)\n\nclient.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Sets up OpenAI authentication** using the `OPENAI_API_KEY` environment variable in the headers\n3. **Gets the WineReview collection** from the Weaviate instance\n4. **Performs a semantic search** using `near_text` with the query \"dessert wine\" and limits results to 2\n5. **Extracts and prints** the title, country, price, and points for each matching wine\n6. **Closes the connection** to clean up resources\n\nThe `near_text` query will use the text2vec-openai vectorizer to find wines that are semantically similar to \"dessert wine\", which should return wines that are actually dessert wines or have similar characteristics.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:49:57.680746",
      "duration": 11.723731994628906,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, here's the Python code to query the 'WineReview' collection for wines matching \"dessert wine\":\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Required for text2vec-openai vectorizer\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Perform semantic search for \"dessert wine\" with limit of 2 results\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print the results\n    for wine in response.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: {wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(\"-\" * 40)\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Includes the OpenAI API key** in headers since the collection uses the text2vec-openai vectorizer\n3. **Performs a semantic search** using `near_text()` to find wines that best match \"dessert wine\"\n4. **Limits results to 2** as requested\n5. **Returns only the specified properties**: title, country, price, and points\n6. **Prints the results** in a readable format\n7. **Properly closes the connection** using a try/finally block\n\nThe `near_text()` query will use the text2vec-openai vectorizer to find wines whose vector representations are most similar to the vector representation of \"dessert wine\", which should effectively find wines that are semantically related to dessert wines.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T20:50:11.101507",
      "duration": 13.025233030319214,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to perform the hybrid search with the specified requirements:\n\n```python\nimport weaviate\nimport os\nfrom weaviate.classes.query import HybridFusion\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_wcs(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=weaviate.auth.AuthApiKey(os.getenv(\"WCD_TEST_KEY\")),\n    headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Perform hybrid search with filters\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        limit=5,\n        where=weaviate.classes.query.Filter.by_property(\"price\").less_than(50) &\n              weaviate.classes.query.Filter.by_property(\"points\").greater_than(90) &\n              (weaviate.classes.query.Filter.by_property(\"review_body\").contains_any([\"spice\"]) |\n               weaviate.classes.query.Filter.by_property(\"review_body\").contains_any([\"fruit\"]) |\n               weaviate.classes.query.Filter.by_property(\"review_body\").contains_any([\"berry\"]) |\n               weaviate.classes.query.Filter.by_property(\"review_body\").contains_any([\"cherry\"]) |\n               weaviate.classes.query.Filter.by_property(\"review_body\").contains_any([\"honey\"]))\n    )\n    \n    # Print results\n    print(f\"Found {len(response.objects)} matching wines:\\n\")\n    \n    for i, wine in enumerate(response.objects, 1):\n        print(f\"{i}. Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"   Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"   Price: ${wine.properties.get('price', 'N/A')}\")\n        print(f\"   Points: {wine.properties.get('points', 'N/A')}\")\n        print(\"-\" * 50)\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, and includes the OpenAI API key in the headers.\n\n2. **Performs a hybrid search** with:\n   - Query: \"pair with steak\"\n   - Alpha: 0.5 (equal weighting between vector and keyword search)\n   - Limit: 5 results maximum\n\n3. **Applies filters** to ensure results meet all criteria:\n   - Price less than 50\n   - Points greater than 90\n   - Review body contains at least one of: \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n\n4. **Prints the results** showing the title, country, price, and points for each matching wine.\n\n5. **Properly closes the connection** in the finally block.\n\nThe filter uses the `&` operator for AND conditions and the `|` operator for OR conditions to match wines that contain any of the specified flavor keywords in their review body.",
      "stdout": "An error occurred: hybrid() got an unexpected keyword argument 'where'\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T20:50:21.387379",
      "duration": 9.877999305725098,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to query the 'WineReview' collection:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\")),\n    headers={\n        \"X-OpenAI-API-Key\": os.getenv(\"OPENAI_API_KEY\")\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform hybrid search with filters\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\n# Print the results\nprint(f\"Found {len(response.objects)} matching wines:\\n\")\n\nfor obj in response.objects:\n    properties = obj.properties\n    print(f\"Title: {properties.get('title', 'N/A')}\")\n    print(f\"Country: {properties.get('country', 'N/A')}\")\n    print(f\"Price: ${properties.get('price', 'N/A')}\")\n    print(f\"Points: {properties.get('points', 'N/A')}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(\"-\" * 50)\n\n# Close the connection\nclient.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Sets up OpenAI integration** using the `OPENAI_API_KEY` environment variable\n3. **Performs a hybrid search** with:\n   - Query: \"pair with steak\"\n   - Alpha: 0.5 (balanced between vector and keyword search)\n   - Limit: 5 results maximum\n4. **Applies filters** to ensure:\n   - Price < 50\n   - Points > 90\n   - Review body contains at least one of: \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n5. **Prints the requested information** for each matching wine: title, country, price, and points\n6. **Includes the search score** for reference\n7. **Properly closes the connection** when done\n\nThe hybrid search with alpha=0.5 provides a balanced combination of semantic similarity (vector search) and keyword matching, which should effectively find wines that are semantically related to \"pair with steak\" while meeting all the specified criteria.",
      "stdout": "Found 5 matching wines:\n\nTitle: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.0\nPoints: 92\nScore: 0.5\n--------------------------------------------------\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.0\nPoints: 91\nScore: 0.3765353560447693\n--------------------------------------------------\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.0\nPoints: 91\nScore: 0.04513849690556526\n--------------------------------------------------\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.0\nPoints: 93\nScore: 0.016171861439943314\n--------------------------------------------------\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: $0.0\nPoints: 92\nScore: 0.0010482011130079627\n--------------------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T20:50:39.082742",
      "duration": 17.26168966293335,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, I'll write Python code that connects to Weaviate Cloud, performs a hybrid search on the WineReview collection with the specified filters, and returns the matching results.\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # For text2vec-openai vectorizer\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Perform hybrid search with filters\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,  # Balance between keyword and vector search\n        limit=5,\n        # Apply filters for price, points, and review_body content\n        filters=Filter.all_of([\n            # Price must be less than 50\n            Filter.by_property(\"price\").less_than(50),\n            # Points must be greater than 90\n            Filter.by_property(\"points\").greater_than(90),\n            # Review body must contain at least one of the specified substrings\n            Filter.any_of([\n                Filter.by_property(\"review_body\").like(\"*spice*\"),\n                Filter.by_property(\"review_body\").like(\"*fruit*\"),\n                Filter.by_property(\"review_body\").like(\"*berry*\"),\n                Filter.by_property(\"review_body\").like(\"*cherry*\"),\n                Filter.by_property(\"review_body\").like(\"*honey*\")\n            ])\n        ]),\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print the results\n    print(f\"Found {len(response.objects)} wines that pair well with steak:\\n\")\n    \n    for i, wine in enumerate(response.objects, 1):\n        props = wine.properties\n        print(f\"{i}. Title: {props.get('title', 'N/A')}\")\n        print(f\"   Country: {props.get('country', 'N/A')}\")\n        print(f\"   Price: ${props.get('price', 'N/A')}\")\n        print(f\"   Points: {props.get('points', 'N/A')}\")\n        print()\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, along with the OpenAI API key for the text2vec-openai vectorizer.\n\n2. **Performs a hybrid search** with `alpha=0.5` to balance between semantic (vector) and keyword (BM25) search for the query \"pair with steak\".\n\n3. **Applies multiple filters** using `Filter.all_of()` to ensure all conditions are met:\n   - Price less than 50\n   - Points greater than 90\n   - Review body contains at least one of the specified flavor terms using `Filter.any_of()` with wildcard matching\n\n4. **Limits results to 5** wines maximum as requested.\n\n5. **Returns specific properties** (title, country, price, points) and prints them in a readable format.\n\n6. **Properly closes the connection** using a try/finally block to ensure cleanup.\n\nThe search will find wines that are both semantically and lexically relevant to \"pair with steak\" while meeting all the specified criteria for price, rating, and flavor profile.",
      "stdout": "Found 5 wines that pair well with steak:\n\n1. Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n   Country: US\n   Price: $40.0\n   Points: 92\n\n2. Title: Bink 2014 Pinot Noir (Anderson Valley)\n   Country: US\n   Price: $49.0\n   Points: 91\n\n3. Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n   Country: Argentina\n   Price: $27.0\n   Points: 91\n\n4. Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n   Country: Hungary\n   Price: $25.0\n   Points: 93\n\n5. Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n   Country: Italy\n   Price: $0.0\n   Points: 92\n\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    }
  },
  "anthropic/claude-opus-4-20250514": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:50:51.767688",
      "duration": 12.66612696647644,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "Here's the Python code to connect to Weaviate Cloud using environment variables and check server readiness:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=AuthApiKey(wcd_key)\n)\n\ntry:\n    # Check if the server is ready\n    if client.is_ready():\n        print(\"Weaviate server is ready to accept requests\")\n    else:\n        print(\"Weaviate server is not ready\")\nfinally:\n    # Close the connection\n    client.close()\n```\n\nAlternatively, you can use the context manager approach which automatically handles closing the connection:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud using context manager\nwith weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=AuthApiKey(wcd_key)\n) as client:\n    # Check if the server is ready\n    if client.is_ready():\n        print(\"Weaviate server is ready to accept requests\")\n    else:\n        print(\"Weaviate server is not ready\")\n```\n\nBoth approaches use the latest Weaviate client syntax (v4) with the `connect_to_weaviate_cloud()` function and proper authentication using `AuthApiKey`.",
      "stdout": "Weaviate server is ready to accept requests\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:51:11.010074",
      "duration": 19.222862720489502,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "Here's the Python code to connect to Weaviate Cloud using environment variables and check if the server is ready:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Get environment variables\ncluster_url = os.environ.get(\"WCD_TEST_URL\")\napi_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready()\n\n# Close the connection\nclient.close()\n```\n\nThis code:\n1. Imports the necessary modules (`os` for environment variables, `weaviate` for the client, and `Auth` for authentication)\n2. Retrieves the `WCD_TEST_URL` and `WCD_TEST_KEY` from environment variables\n3. Connects to the Weaviate Cloud instance using the retrieved credentials\n4. Checks if the server is ready using `assert client.is_ready()`\n5. Closes the connection properly",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:51:49.482868",
      "duration": 38.454137086868286,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=weaviate.auth.AuthApiKey(wcd_key)\n)\n\ntry:\n    # Check if collection exists and delete it\n    if client.collections.exists(\"DemoProducts\"):\n        client.collections.delete(\"DemoProducts\")\n        print(\"Existing 'DemoProducts' collection deleted.\")\n    \n    # Create the collection with properties\n    client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            Property(\n                name=\"name\",\n                data_type=DataType.TEXT\n            ),\n            Property(\n                name=\"description\",\n                data_type=DataType.TEXT\n            ),\n            Property(\n                name=\"price\",\n                data_type=DataType.NUMBER\n            ),\n            Property(\n                name=\"in_stock\",\n                data_type=DataType.BOOL\n            )\n        ]\n    )\n    \n    print(\"Collection 'DemoProducts' created successfully!\")\n    \n    # Verify the collection was created\n    collection = client.collections.get(\"DemoProducts\")\n    print(f\"\\nCollection name: {collection.name}\")\n    print(\"Properties:\")\n    for prop in collection.config.get().properties:\n        print(f\"  - {prop.name}: {prop.data_type}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. Imports the necessary modules including the latest Weaviate client\n2. Retrieves the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n3. Connects to Weaviate Cloud using `connect_to_weaviate_cloud()` with API key authentication\n4. Checks if the \"DemoProducts\" collection already exists and deletes it if found\n5. Creates a new collection with the specified properties:\n   - `name` as TEXT\n   - `description` as TEXT\n   - `price` as NUMBER\n   - `in_stock` as BOOL\n6. Verifies the collection was created and prints its properties\n7. Properly closes the client connection in a finally block\n\nMake sure you have the latest Weaviate client installed:\n```bash\npip install weaviate-client>=4.0.0\n```",
      "stdout": "Existing 'DemoProducts' collection deleted.\nCollection 'DemoProducts' created successfully!\n\nCollection name: DemoProducts\nProperties:\n  - name: text\n  - description: text\n  - price: number\n  - in_stock: boolean\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:52:08.037956",
      "duration": 18.536312103271484,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax with the environment variables:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Get environment variables\ncluster_url = os.environ.get(\"WCD_TEST_URL\")\napi_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\ntry:\n    # Create the collection\n    collection_name = \"DemoProducts\"\n\n    # Delete the collection if it already exists (for testing purposes)\n    if client.collections.exists(collection_name):\n        client.collections.delete(collection_name)\n        print(f\"Deleted existing collection: {collection_name}\")\n\n    # Create the collection with specified properties\n    products_collection = client.collections.create(\n        collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n\n    print(f\"Created collection: {products_collection.name}\")\n\nfinally:\n    # Close connection\n    client.close()\n```\n\nThis code:\n1. Imports the necessary modules from the Weaviate client library\n2. Retrieves the `WCD_TEST_URL` and `WCD_TEST_KEY` from environment variables\n3. Connects to the Weaviate Cloud instance using these credentials\n4. Checks if the \"DemoProducts\" collection already exists and deletes it if it does\n5. Creates a new \"DemoProducts\" collection with the four specified properties:\n   - `name` (text)\n   - `description` (text)\n   - `price` (number)\n   - `in_stock` (boolean)\n6. Uses a try-finally block to ensure the connection is properly closed even if an error occurs\n\nMake sure you have set the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` before running this code.",
      "stdout": "Deleted existing collection: DemoProducts\nCreated collection: DemoProducts\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T20:52:41.071013",
      "duration": 33.01455807685852,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, I'll write Python code to create a \"DemoProducts\" collection with the specified properties, connecting to Weaviate Cloud using environment variables. Here's the solution:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\ntry:\n    # Check if the collection already exists and delete it if it does\n    if client.collections.exists(\"DemoProducts\"):\n        client.collections.delete(\"DemoProducts\")\n        print(\"Existing 'DemoProducts' collection deleted.\")\n    \n    # Create the DemoProducts collection with specified properties\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL)\n        ]\n    )\n    \n    print(\"Collection 'DemoProducts' created successfully!\")\n    \n    # Verify the collection was created\n    if client.collections.exists(\"DemoProducts\"):\n        print(\"Collection confirmed to exist.\")\n        \n        # Optional: Get the collection to verify its configuration\n        collection = client.collections.get(\"DemoProducts\")\n        print(f\"Collection name: {collection.name}\")\n\nfinally:\n    # Always close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Checks if the collection exists** using `client.collections.exists()`\n3. **Deletes the existing collection** if it exists using `client.collections.delete()`\n4. **Creates the new collection** with the four specified properties:\n   - `name` (TEXT type)\n   - `description` (TEXT type)\n   - `price` (NUMBER type - for floating point values)\n   - `in_stock` (BOOL type)\n5. **Verifies the creation** and prints confirmation messages\n6. **Properly closes the connection** in the finally block\n\nThe code uses the latest Weaviate Python client v4.x syntax as shown in the examples provided.",
      "stdout": "Existing 'DemoProducts' collection deleted.\nCollection 'DemoProducts' created successfully!\nCollection confirmed to exist.\nCollection name: DemoProducts\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T20:53:10.283468",
      "duration": 28.396985054016113,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Configure, Property, DataType\nfrom weaviate.classes.data import DataObject\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=weaviate.auth.AuthApiKey(wcd_key)\n)\n\ntry:\n    # Create or get the collection\n    if client.collections.exists(\"DemoProducts\"):\n        collection = client.collections.get(\"DemoProducts\")\n    else:\n        collection = client.collections.create(\n            name=\"DemoProducts\",\n            properties=[\n                Property(name=\"name\", data_type=DataType.TEXT),\n                Property(name=\"description\", data_type=DataType.TEXT)\n            ]\n        )\n    \n    # Prepare batch data\n    products = []\n    for i in range(50):\n        products.append(\n            DataObject(\n                properties={\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"Description {i}\"\n                }\n            )\n        )\n    \n    # Batch import the objects\n    collection.data.insert_many(products)\n    \n    # Get and print the number of objects in the collection\n    response = collection.aggregate.over_all(total_count=True)\n    print(f\"Number of objects in the collection: {response.total_count}\")\n    \nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Creates or gets the collection** \"DemoProducts\" with two text properties: \"name\" and \"description\"\n3. **Prepares 50 objects** with simple data following the pattern you specified\n4. **Batch imports** all 50 objects using `insert_many()`\n5. **Queries the collection** to get the total count of objects\n6. **Prints the result** showing the number of objects in the collection\n7. **Properly closes** the client connection\n\nMake sure you have the latest Weaviate client installed:\n```bash\npip install -U weaviate-client\n```\n\nThe code uses the v4 client syntax with proper type hints and the new collection-based API structure.",
      "stdout": "Number of objects in the collection: 50\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T20:53:43.501698",
      "duration": 32.48577404022217,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to accomplish your requirements:\n\n```python\nimport weaviate\nfrom weaviate.auth import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n)\n\n# Get the collection\ncollection = client.collections.get(\"DemoProducts\")\n\n# Create 50 product objects\ndata_rows = [\n    {\n        \"name\": f\"Product {i}\",\n        \"description\": f\"Description {i}\"\n    } for i in range(50)\n]\n\n# Batch import the objects\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\n# Check for failed imports\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\n# Print the number of objects in the collection\nprint(f\"Number of objects in the collection: {len(collection)}\")\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n\n1. Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. Gets the \"DemoProducts\" collection\n3. Creates 50 simple product objects with name and description properties\n4. Uses batch import with dynamic batching to efficiently add all objects\n5. Checks for any failed imports and reports them\n6. Prints the total number of objects in the collection\n7. Properly closes the client connection\n\nMake sure you have the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` set before running this code. Also ensure that the \"DemoProducts\" collection already exists in your Weaviate instance with the appropriate schema defining the \"name\" and \"description\" text properties.",
      "stdout": "Number of objects in the collection: 50\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T20:54:21.647489",
      "duration": 37.482566833496094,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, I'll write Python code to:\n1. Connect to Weaviate Cloud using environment variables\n2. Create a \"DemoProducts\" collection with name and description properties\n3. Batch import 50 products\n4. Print the count of objects\n\nHere's the complete code:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\ntry:\n    # Create the DemoProducts collection with properties\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ]\n    )\n    \n    # Get the collection\n    collection = client.collections.get(\"DemoProducts\")\n    \n    # Batch import 50 products using fixed size batch\n    with collection.batch.fixed_size(batch_size=50) as batch:\n        for i in range(50):\n            batch.add_object(\n                properties={\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"Description {i}\"\n                }\n            )\n    \n    # Check if there were any errors during batch import\n    if collection.batch.failed_objects:\n        print(f\"Warning: {len(collection.batch.failed_objects)} objects failed to import\")\n    \n    # Get the count of objects in the collection\n    # Using aggregate query to count objects\n    response = collection.aggregate.over_all(total_count=True)\n    \n    print(f\"Number of objects in the collection: {response.total_count}\")\n    \nfinally:\n    # Always close the client connection\n    client.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables\n2. Creates a \"DemoProducts\" collection with two text properties: \"name\" and \"description\"\n3. Uses a fixed-size batch import to efficiently add 50 products\n4. Prints the total count of objects in the collection using the aggregate query\n5. Properly closes the connection in a finally block\n\nThe batch import uses the recommended fixed-size batch approach for optimal performance when importing a known number of objects.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\nTraceback (most recent call last):\n  File \"/code/code.py\", line 14, in <module>\n    client.collections.create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/sync.py\", line 107, in create\n    self.__loop.run_until_complete(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/event_loop.py\", line 42, in run_until_complete\n    return fut.result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 446, in result\n    return self.__get_result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 391, in __get_result\n    raise self._exception\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/async_.py\", line 134, in create\n    name = await super()._create(config._to_dict())\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/base.py\", line 27, in _create\n    response = await self._connection.post(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 550, in post\n    return await self.__send(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 505, in __send\n    raise e\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 496, in __send\n    raise UnexpectedStatusCodeError(error_msg, response=res)\nweaviate.exceptions.UnexpectedStatusCodeError: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'class name DemoProducts already exists'}]}.\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:54:54.630722",
      "duration": 32.57450008392334,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.query import MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.auth.AuthApiKey(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Perform near_text search for \"dessert wine\"\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_metadata=MetadataQuery(distance=True)\n    )\n    \n    # Print the results\n    for wine in response.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: {wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(f\"Distance: {wine.metadata.distance}\")\n        print(\"-\" * 50)\n        \nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. Connects to Weaviate Cloud using the provided environment variables\n2. Passes the OpenAI API key in the headers for the text2vec-openai vectorizer\n3. Gets the 'WineReview' collection\n4. Performs a `near_text` query searching for \"dessert wine\" with a limit of 2 results\n5. Prints the title, country, price, and points for each matching wine\n6. Also includes the distance metric to show how closely each result matches the query\n7. Properly closes the client connection when done\n\nThe code uses the latest Weaviate v4 client syntax with the collections API and proper connection handling.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\nDistance: 0.476643443107605\n--------------------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\nDistance: 0.4812176823616028\n--------------------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:55:22.050061",
      "duration": 26.948954105377197,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to query the 'WineReview' collection:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-API-Key\": os.environ[\"OPENAI_API_KEY\"]\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Query for wines that match \"dessert wine\"\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2\n)\n\n# Print the results\nfor obj in response.objects:\n    print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n    print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n    print(f\"Price: {obj.properties.get('price', 'N/A')}\")\n    print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n    print(\"-\" * 50)\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. Includes the OpenAI API key in the headers for the text2vec-openai vectorizer\n3. Gets the 'WineReview' collection\n4. Performs a semantic search using `near_text` for \"dessert wine\" with a limit of 2 results\n5. Prints the title, country, price, and points for each matching wine\n6. Properly closes the client connection\n\nThe `near_text` query will use the text2vec-openai vectorizer to find wines whose descriptions are semantically similar to \"dessert wine\".",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n--------------------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n--------------------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T20:55:57.920719",
      "duration": 35.46403789520264,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, I'll write Python code to query the 'WineReview' collection for dessert wines. Here's the solution:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Required for text2vec-openai\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Query for dessert wines using semantic search\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2\n    )\n    \n    # Print the results\n    for wine in response.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: {wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(\"-\" * 50)\n        \nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the provided environment variables\n2. Includes the OpenAI API key in the headers for the text2vec-openai vectorizer\n3. Gets the 'WineReview' collection\n4. Performs a semantic search using `near_text` with the query \"dessert wine\"\n5. Limits the results to 2 wines\n6. Prints the title, country, price, and points for each matching wine\n7. Properly closes the connection using a try/finally block\n\nThe `near_text` query will use the text2vec-openai vectorizer to find wines that are semantically similar to \"dessert wine\" based on their vector embeddings.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n--------------------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n--------------------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T20:56:39.004760",
      "duration": 40.670981884002686,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.query import Filter\nimport os\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.auth.AuthApiKey(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Perform hybrid search with filters\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        limit=5,\n        where=(\n            Filter.by_property(\"price\").less_than(50) &\n            Filter.by_property(\"points\").greater_than(90) &\n            (\n                Filter.by_property(\"review_body\").contains_any([\"spice\"]) |\n                Filter.by_property(\"review_body\").contains_any([\"fruit\"]) |\n                Filter.by_property(\"review_body\").contains_any([\"berry\"]) |\n                Filter.by_property(\"review_body\").contains_any([\"cherry\"]) |\n                Filter.by_property(\"review_body\").contains_any([\"honey\"])\n            )\n        ),\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print results\n    print(f\"Found {len(response.objects)} wines that pair well with steak:\\n\")\n    \n    for i, wine in enumerate(response.objects, 1):\n        print(f\"{i}. {wine.properties['title']}\")\n        print(f\"   Country: {wine.properties['country']}\")\n        print(f\"   Price: ${wine.properties['price']}\")\n        print(f\"   Points: {wine.properties['points']}\")\n        print()\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. Connects to Weaviate Cloud using the provided environment variables\n2. Sets up the OpenAI API key in the headers for the text2vec-openai vectorizer\n3. Performs a hybrid search with alpha=0.5 on the query \"pair with steak\"\n4. Applies filters to ensure:\n   - Price is less than 50\n   - Points are greater than 90\n   - The review_body contains at least one of the specified substrings\n5. Limits results to 5 wines\n6. Prints the title, country, price, and points for each matching wine\n7. Properly closes the client connection when done\n\nThe hybrid search combines both keyword (BM25) and vector search, with alpha=0.5 giving equal weight to both search methods.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 19, in <module>\n    response = wine_collection.query.hybrid(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/syncify.py\", line 23, in sync_method\n    return _EventLoopSingleton.get_instance().run_until_complete(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/event_loop.py\", line 41, in run_until_complete\n    fut = asyncio.run_coroutine_threadsafe(f(*args, **kwargs), self.loop)\nTypeError: hybrid() got an unexpected keyword argument 'where'\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T20:57:17.552700",
      "duration": 38.15798306465149,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to query the 'WineReview' collection:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-API-Key\": os.environ[\"OPENAI_API_KEY\"]\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform hybrid search\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    where=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\n# Print results\nfor obj in response.objects:\n    print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n    print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n    print(f\"Price: ${obj.properties.get('price', 'N/A')}\")\n    print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(\"-\" * 50)\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. Sets the OpenAI API key from the `OPENAI_API_KEY` environment variable\n3. Gets the 'WineReview' collection\n4. Performs a hybrid search with:\n   - Query: \"pair with steak\"\n   - Limit: 5 results\n   - Alpha: 0.5 (balanced between vector and keyword search)\n   - Filters:\n     - Price less than 50\n     - Points greater than 90\n     - Review body contains at least one of the specified substrings\n5. Prints the title, country, price, and points for each matching wine\n6. Closes the client connection\n\nNote: I used `where` instead of `filters` as that's the correct parameter name in the latest Weaviate client syntax.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 19, in <module>\n    response = collection.query.hybrid(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/syncify.py\", line 23, in sync_method\n    return _EventLoopSingleton.get_instance().run_until_complete(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/event_loop.py\", line 41, in run_until_complete\n    fut = asyncio.run_coroutine_threadsafe(f(*args, **kwargs), self.loop)\nTypeError: hybrid() got an unexpected keyword argument 'where'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "extensive_examples_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T20:58:18.843757",
      "duration": 60.8291757106781,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, I'll write Python code to query the WineReview collection with the specific filters and hybrid search parameters you've requested.\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # For text2vec-openai vectorizer\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Create filters for price < 50 and points > 90\n    price_filter = Filter.by_property(\"price\").less_than(50)\n    points_filter = Filter.by_property(\"points\").greater_than(90)\n    \n    # Create filter for review_body containing at least one of the specified substrings\n    # Using wildcard patterns for substring matching\n    review_filter = Filter.any_of([\n        Filter.by_property(\"review_body\").like(\"*spice*\"),\n        Filter.by_property(\"review_body\").like(\"*fruit*\"),\n        Filter.by_property(\"review_body\").like(\"*berry*\"),\n        Filter.by_property(\"review_body\").like(\"*cherry*\"),\n        Filter.by_property(\"review_body\").like(\"*honey*\")\n    ])\n    \n    # Combine all filters\n    combined_filter = price_filter & points_filter & review_filter\n    \n    # Perform hybrid search with alpha=0.5\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,  # Balance between keyword and vector search\n        where=combined_filter,\n        limit=5,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print the results\n    print(f\"Found {len(response.objects)} wines that pair well with steak:\\n\")\n    \n    for i, wine in enumerate(response.objects, 1):\n        print(f\"Wine {i}:\")\n        print(f\"  Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"  Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"  Price: ${wine.properties.get('price', 'N/A')}\")\n        print(f\"  Points: {wine.properties.get('points', 'N/A')}\")\n        print()\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, with the OpenAI API key for the text2vec-openai vectorizer\n2. **Creates filters** for:\n   - Price less than 50\n   - Points greater than 90\n   - Review body containing at least one of the specified substrings (spice, fruit, berry, cherry, or honey)\n3. **Performs a hybrid search** with:\n   - Query: \"pair with steak\"\n   - Alpha: 0.5 (equal balance between keyword and vector search)\n   - Limit: 5 results maximum\n4. **Prints the results** showing title, country, price, and points for each matching wine\n\nThe hybrid search combines both semantic understanding (vector search) and keyword matching (BM25) to find wines that best match the query \"pair with steak\" while meeting all the specified criteria.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 37, in <module>\n    response = wine_collection.query.hybrid(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/syncify.py\", line 23, in sync_method\n    return _EventLoopSingleton.get_instance().run_until_complete(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/event_loop.py\", line 41, in run_until_complete\n    fut = asyncio.run_coroutine_threadsafe(f(*args, **kwargs), self.loop)\nTypeError: hybrid() got an unexpected keyword argument 'where'\n",
      "exit_code": 1
    }
  },
  "gemini/gemini-2.5-pro": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:58:40.067995",
      "duration": 21.187725067138672,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "Of course. Here is the Python code using the latest `weaviate-client` (v4) syntax to connect to a Weaviate Cloud instance and check its readiness.\n\n### Python Code\n\n```python\nimport os\nimport weaviate\nimport weaviate.classes as wvc\nfrom weaviate.auth import AuthApiKey\n\n# 1. Get Weaviate Cloud credentials from environment variables\ntry:\n    wcd_url = os.environ[\"WCD_TEST_URL\"]\n    wcd_api_key = os.environ[\"WCD_TEST_KEY\"]\nexcept KeyError:\n    print(\"\ud83d\udd34 Error: Make sure WCD_TEST_URL and WCD_TEST_KEY environment variables are set.\")\n    exit(1)\n\nprint(f\"Connecting to Weaviate Cloud at {wcd_url}...\")\n\ntry:\n    # 2. Connect to the Weaviate Cloud instance\n    # The 'with' statement ensures the connection is closed automatically\n    with weaviate.connect_to_wcs(\n        cluster_url=wcd_url,\n        auth_credentials=AuthApiKey(wcd_api_key),\n    ) as client:\n        # 3. Check if the server is ready to accept requests\n        is_ready = client.is_ready()\n\n        # 4. Report the status\n        if is_ready:\n            print(\"\u2705 Weaviate server is ready to accept requests.\")\n        else:\n            print(\"\ud83d\udfe1 Weaviate server is NOT ready.\")\n\nexcept Exception as e:\n    print(f\"\ud83d\udd34 An error occurred during connection: {e}\")\n\n```\n\n### How to Run This Code\n\n1.  **Install the Weaviate client:**\n    If you haven't already, install the Python client library.\n\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set Environment Variables:**\n    Before running the script, you need to set the required environment variables in your terminal.\n\n    *   **On macOS or Linux:**\n        ```bash\n        export WCD_TEST_URL=\"YOUR_WEAVIATE_URL\"\n        export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n\n    *   **On Windows (Command Prompt):**\n        ```bash\n        set WCD_TEST_URL=\"YOUR_WEAVIATE_URL\"\n        set WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n\n    *   **On Windows (PowerShell):**\n        ```powershell\n        $env:WCD_TEST_URL=\"YOUR_WEAVIATE_URL\"\n        $env:WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n    Replace `\"YOUR_WEAVIATE_URL\"` and `\"YOUR_WEAVIATE_API_KEY\"` with your actual credentials.\n\n3.  **Execute the Script:**\n    Save the code above into a file (e.g., `check_weaviate.py`) and run it from your terminal.\n\n    ```bash\n    python check_weaviate.py\n    ```\n\n    **Expected Output (if successful):**\n    ```\n    Connecting to Weaviate Cloud at https://your-cluster-name.weaviate.network...\n    \u2705 Weaviate server is ready to accept requests.\n    ```",
      "stdout": "Connecting to Weaviate Cloud at yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud...\n\u2705 Weaviate server is ready to accept requests.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T20:59:03.197620",
      "duration": 23.092073917388916,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "Of course. Here is the Python code to connect to a Weaviate Cloud instance using environment variables and then check its readiness.\n\nThis code uses the recommended `try...finally` block to ensure the connection is always closed.\n\n```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\n\n# Get Weaviate credentials from environment variables\n# WCD_TEST_URL is the URL of your Weaviate Cloud instance\n# WCD_TEST_KEY is the API key for your Weaviate Cloud instance\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_api_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if the environment variables are set\nif not wcd_url or not wcd_api_key:\n    print(\"Error: WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\nelse:\n    client = None  # Initialize client to ensure it's defined for the finally block\n    try:\n        # Connect to your Weaviate Cloud instance using the environment variables\n        client = weaviate.connect_to_weaviate_cloud(\n            cluster_url=wcd_url,\n            auth_credentials=Auth.api_key(wcd_api_key)\n        )\n\n        # Check if the connection is successful and the server is ready.\n        # The is_ready() method will return True or raise an exception on failure.\n        if client.is_ready():\n            print(f\"Successfully connected and Weaviate is ready at {wcd_url}\")\n\n    except Exception as e:\n        print(f\"An error occurred during connection: {e}\")\n\n    finally:\n        # Close the connection to Weaviate\n        if client:\n            client.close()\n            print(\"Connection to Weaviate closed.\")\n\n```\n\n### How to Run This Code\n\n1.  **Install the Weaviate client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set the environment variables:**\n\n    *   **In Linux/macOS:**\n        ```bash\n        export WCD_TEST_URL=\"https://your-weaviate-instance.weaviate.network\"\n        export WCD_TEST_KEY=\"your-wcd-api-key\"\n        ```\n    *   **In Windows (Command Prompt):**\n        ```bash\n        set WCD_TEST_URL=\"https://your-weaviate-instance.weaviate.network\"\n        set WCD_TEST_KEY=\"your-wcd-api-key\"\n        ```\n    *   **In Windows (PowerShell):**\n        ```powershell\n        $env:WCD_TEST_URL=\"https://your-weaviate-instance.weaviate.network\"\n        $env:WCD_TEST_KEY=\"your-wcd-api-key\"\n        ```\n    Replace the placeholder values with your actual Weaviate Cloud URL and API key.\n\n3.  **Save the code:** Save the Python code above as a file (e.g., `connect_test.py`).\n\n4.  **Execute the script:**\n    ```bash\n    python connect_test.py\n    ```\n\nIf the connection is successful, you will see:\n```\nSuccessfully connected and Weaviate is ready at https://your-weaviate-instance.weaviate.network\nConnection to Weaviate closed.\n```",
      "stdout": "Successfully connected and Weaviate is ready at yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\nConnection to Weaviate closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T20:59:33.371989",
      "duration": 30.136247873306274,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "Of course! Here is the Python code to create the \"DemoProducts\" collection using the latest Weaviate client (v4) syntax.\n\nThis script connects to Weaviate Cloud using environment variables, checks if the collection exists, deletes it if it does, and then creates it with the specified properties.\n\n### Prerequisites\n\n1.  **Install the Weaviate Python Client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set Environment Variables:**\n    You need to set `WCD_TEST_URL` and `WCD_TEST_KEY` in your terminal session before running the script.\n\n    **For Linux/macOS (bash/zsh):**\n    ```bash\n    export WCD_TEST_URL=\"your-weaviate-cloud-url\"\n    export WCD_TEST_KEY=\"your-weaviate-api-key\"\n    ```\n\n    **For Windows (Command Prompt):**\n    ```cmd\n    set WCD_TEST_URL=\"your-weaviate-cloud-url\"\n    set WCD_TEST_KEY=\"your-weaviate-api-key\"\n    ```\n\n    **For Windows (PowerShell):**\n    ```powershell\n    $env:WCD_TEST_URL=\"your-weaviate-cloud-url\"\n    $env:WCD_TEST_KEY=\"your-weaviate-api-key\"\n    ```\n    Replace the placeholder values with your actual Weaviate Cloud URL and API key.\n\n### Python Code\n\nSave the following code as a Python file (e.g., `create_collection.py`):\n\n```python\nimport weaviate\nimport weaviate.classes as wvc\nimport os\n\n# --- 1. Configuration and Connection ---\n# Retrieve connection details from environment variables\ntry:\n    WCD_URL = os.environ[\"WCD_TEST_URL\"]\n    WCD_KEY = os.environ[\"WCD_TEST_KEY\"]\nexcept KeyError:\n    print(\"FATAL: You must set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n    exit(1)\n\nCOLLECTION_NAME = \"DemoProducts\"\n\n# Connect to Weaviate Cloud\n# The connect_to_wcs method is a helper for Weaviate Cloud Services\nclient = weaviate.connect_to_wcs(\n    cluster_url=WCD_URL,\n    auth_credentials=weaviate.auth.AuthApiKey(WCD_KEY),\n)\n\nprint(\"Successfully connected to Weaviate.\")\n\ntry:\n    # --- 2. Delete Collection if it exists ---\n    # This is useful for repeatedly running the script to ensure a clean start\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it.\")\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n\n    # --- 3. Create the Collection ---\n    print(f\"Creating collection '{COLLECTION_NAME}'...\")\n    \n    products_collection = client.collections.create(\n        name=COLLECTION_NAME,\n        \n        # Define the properties of the collection objects\n        properties=[\n            wvc.config.Property(\n                name=\"name\",\n                data_type=wvc.config.DataType.TEXT,\n                description=\"The name of the product\",\n            ),\n            wvc.config.Property(\n                name=\"description\",\n                data_type=wvc.config.DataType.TEXT,\n                description=\"A detailed description of the product\",\n            ),\n            wvc.config.Property(\n                name=\"price\",\n                data_type=wvc.config.DataType.NUMBER,\n                description=\"The price of the product\",\n            ),\n            wvc.config.Property(\n                name=\"in_stock\",\n                data_type=wvc.config.DataType.BOOL,\n                description=\"Whether the product is currently in stock\",\n            ),\n        ],\n\n        # Define vectorizer settings.\n        # We use a default transformer model from HuggingFace, which is a good\n        # starting point if you don't have an OpenAI/Cohere API key.\n        # If your instance doesn't have a text2vec module, use:\n        # vectorizer_config=wvc.config.Configure.Vectorizer.none()\n        vectorizer_config=wvc.config.Configure.Vectorizer.text2vec_transformers()\n    )\n\n    print(f\"Collection '{COLLECTION_NAME}' created successfully!\")\n    \n    # You can inspect the created collection configuration\n    # config = client.collections.get(COLLECTION_NAME).config.get()\n    # print(\"\\nCollection Config:\")\n    # print(config)\n\nfinally:\n    # --- 4. Close the connection ---\n    # It's a good practice to close the client connection\n    client.close()\n    print(\"Connection closed.\")\n\n```\n\n### How to Run the Script\n\n1.  Make sure you have set your environment variables as described in the \"Prerequisites\" section.\n2.  Save the code above to a file named `create_collection.py`.\n3.  Run the script from your terminal:\n    ```bash\n    python create_collection.py\n    ```\n\n**Expected Output (on the first run):**\n\n```\nSuccessfully connected to Weaviate.\nCreating collection 'DemoProducts'...\nCollection 'DemoProducts' created successfully!\nConnection closed.\n```\n\n**Expected Output (on subsequent runs):**\n\n```\nSuccessfully connected to Weaviate.\nCollection 'DemoProducts' already exists. Deleting it.\nCollection 'DemoProducts' deleted.\nCreating collection 'DemoProducts'...\nCollection 'DemoProducts' created successfully!\nConnection closed.\n```",
      "stdout": "Successfully connected to Weaviate.\nCollection 'DemoProducts' already exists. Deleting it.\nCollection 'DemoProducts' deleted.\nCreating collection 'DemoProducts'...\nConnection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\nTraceback (most recent call last):\n  File \"/code/code.py\", line 36, in <module>\n    products_collection = client.collections.create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/sync.py\", line 107, in create\n    self.__loop.run_until_complete(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/event_loop.py\", line 42, in run_until_complete\n    return fut.result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 446, in result\n    return self.__get_result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 391, in __get_result\n    raise self._exception\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/async_.py\", line 134, in create\n    name = await super()._create(config._to_dict())\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/base.py\", line 27, in _create\n    response = await self._connection.post(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 550, in post\n    return await self.__send(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 505, in __send\n    raise e\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 496, in __send\n    raise UnexpectedStatusCodeError(error_msg, response=res)\nweaviate.exceptions.UnexpectedStatusCodeError: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'vectorizer: no module with name \"text2vec-transformers\" present'}]}.\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T21:00:04.041706",
      "duration": 30.632167100906372,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "Of course. Here is the Python code to create a \"DemoProducts\" collection in Weaviate Cloud, using environment variables for the connection details.\n\nThis script first checks for the required environment variables. It then connects to your Weaviate instance, deletes the \"DemoProducts\" collection if it already exists, and finally creates it with the specified properties.\n\n### Python Code\n\n```python\nimport os\nimport sys\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# --- Get Weaviate Cloud credentials from environment variables ---\ntry:\n    WCD_URL = os.environ[\"WCD_TEST_URL\"]\n    WCD_API_KEY = os.environ[\"WCD_TEST_KEY\"]\nexcept KeyError:\n    print(\"Error: WCD_TEST_URL and WCD_TEST_KEY environment variables not set.\")\n    sys.exit(1)\n\n\nclient = None  # Initialize client to None\ntry:\n    # --- 1. Connect to Weaviate Cloud ---\n    # The client connects to your Weaviate instance using the provided URL and API key.\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_URL,\n        auth_credentials=Auth.api_key(WCD_API_KEY)\n    )\n    print(\"Successfully connected to Weaviate.\")\n\n    collection_name = \"DemoProducts\"\n\n    # --- 2. Delete the collection if it already exists ---\n    # This is useful for running the script multiple times to ensure a clean start.\n    if client.collections.exists(collection_name):\n        print(f\"Collection '{collection_name}' already exists. Deleting it.\")\n        client.collections.delete(collection_name)\n        print(f\"Collection '{collection_name}' deleted.\")\n\n    # --- 3. Create the collection ---\n    # The collection is created with a specific name and a list of properties.\n    # Each property has a name and a data type.\n    print(f\"Creating collection '{collection_name}'...\")\n    products_collection = client.collections.create(\n        name=collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n\n    print(f\"\\nSuccessfully created collection: '{products_collection.name}'\")\n    # You can optionally inspect the created collection's configuration\n    config = products_collection.config.get()\n    print(\"Collection schema:\")\n    print(config.properties)\n\n\nexcept Exception as e:\n    print(f\"\\nAn error occurred: {e}\")\n\nfinally:\n    # --- 4. Close the connection ---\n    # It's important to close the connection to release resources.\n    if client:\n        client.close()\n        print(\"\\nConnection to Weaviate closed.\")\n```\n\n### How to Run the Code\n\n1.  **Install the Weaviate client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set environment variables:**\n    Before running the script, set the required environment variables in your terminal.\n\n    *   **On macOS/Linux:**\n        ```bash\n        export WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n\n    *   **On Windows (Command Prompt):**\n        ```bash\n        set WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        set WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n\n    *   **On Windows (PowerShell):**\n        ```powershell\n        $env:WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        $env:WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n    Replace the placeholder values with your actual Weaviate Cloud URL and API key.\n\n3.  **Execute the script:**\n    Save the code as a Python file (e.g., `create_collection.py`) and run it from your terminal:\n    ```bash\n    python create_collection.py\n    ```\n\nYou should see output confirming the connection, the deletion of any pre-existing collection, the creation of the new collection, and finally, the connection being closed.",
      "stdout": "Successfully connected to Weaviate.\nCreating collection 'DemoProducts'...\n\nSuccessfully created collection: 'DemoProducts'\nCollection schema:\n[_Property(name='name', description=None, data_type=<DataType.TEXT: 'text'>, index_filterable=True, index_range_filters=False, index_searchable=True, nested_properties=None, tokenization=<Tokenization.WORD: 'word'>, vectorizer_config=None, vectorizer='none', vectorizer_configs=None), _Property(name='description', description=None, data_type=<DataType.TEXT: 'text'>, index_filterable=True, index_range_filters=False, index_searchable=True, nested_properties=None, tokenization=<Tokenization.WORD: 'word'>, vectorizer_config=None, vectorizer='none', vectorizer_configs=None), _Property(name='price', description=None, data_type=<DataType.NUMBER: 'number'>, index_filterable=True, index_range_filters=False, index_searchable=False, nested_properties=None, tokenization=None, vectorizer_config=None, vectorizer='none', vectorizer_configs=None), _Property(name='in_stock', description=None, data_type=<DataType.BOOL: 'boolean'>, index_filterable=True, index_range_filters=False, index_searchable=False, nested_properties=None, tokenization=None, vectorizer_config=None, vectorizer='none', vectorizer_configs=None)]\n\nConnection to Weaviate closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T21:00:18.452127",
      "duration": 14.371115922927856,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# This script assumes you have the following environment variables set:\n# WCD_TEST_URL: The URL of your Weaviate Cloud instance.\n# WCD_TEST_KEY: The API key for your Weaviate Cloud instance.\n\n# Define the collection name\nCOLLECTION_NAME = \"DemoProducts\"\n\ntry:\n    # Connect to Weaviate Cloud\n    # For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    )\n    print(\"Successfully connected to Weaviate.\")\n\n    # Check if the collection already exists\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it.\")\n        # Delete the existing collection\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n\n    # Create the \"DemoProducts\" collection with specified properties\n    # For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n    print(f\"Creating collection '{COLLECTION_NAME}'...\")\n    products_collection = client.collections.create(\n        name=COLLECTION_NAME,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n\n    print(f\"Collection '{COLLECTION_NAME}' created successfully.\")\n    print(\"Collection schema:\")\n    # You can inspect the collection's configuration like this:\n    config = products_collection.config.get()\n    print(config)\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Ensure the client is closed\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"Client closed.\")\n```",
      "stdout": "Successfully connected to Weaviate.\nCollection 'DemoProducts' already exists. Deleting it.\nCollection 'DemoProducts' deleted.\nCreating collection 'DemoProducts'...\nCollection 'DemoProducts' created successfully.\nCollection schema:\n_CollectionConfig(name='DemoProducts', description=None, generative_config=None, inverted_index_config=_InvertedIndexConfig(bm25=_BM25Config(b=0.75, k1=1.2), cleanup_interval_seconds=60, index_null_state=False, index_property_length=False, index_timestamps=False, stopwords=_StopwordsConfig(preset=<StopwordsPreset.EN: 'en'>, additions=None, removals=None)), multi_tenancy_config=_MultiTenancyConfig(enabled=False, auto_tenant_creation=False, auto_tenant_activation=False), properties=[_Property(name='name', description=None, data_type=<DataType.TEXT: 'text'>, index_filterable=True, index_range_filters=False, index_searchable=True, nested_properties=None, tokenization=<Tokenization.WORD: 'word'>, vectorizer_config=None, vectorizer='none', vectorizer_configs=None), _Property(name='description', description=None, data_type=<DataType.TEXT: 'text'>, index_filterable=True, index_range_filters=False, index_searchable=True, nested_properties=None, tokenization=<Tokenization.WORD: 'word'>, vectorizer_config=None, vectorizer='none', vectorizer_configs=None), _Property(name='price', description=None, data_type=<DataType.NUMBER: 'number'>, index_filterable=True, index_range_filters=False, index_searchable=False, nested_properties=None, tokenization=None, vectorizer_config=None, vectorizer='none', vectorizer_configs=None), _Property(name='in_stock', description=None, data_type=<DataType.BOOL: 'boolean'>, index_filterable=True, index_range_filters=False, index_searchable=False, nested_properties=None, tokenization=None, vectorizer_config=None, vectorizer='none', vectorizer_configs=None)], references=[], replication_config=_ReplicationConfig(factor=1, async_enabled=False, deletion_strategy=<ReplicationDeletionStrategy.NO_AUTOMATED_RESOLUTION: 'NoAutomatedResolution'>), reranker_config=None, sharding_config=_ShardingConfig(virtual_per_physical=128, desired_count=1, actual_count=1, desired_virtual_count=128, actual_virtual_count=128, key='_id', strategy='hash', function='murmur3'), vector_index_config=_VectorIndexConfigHNSW(multi_vector=None, quantizer=None, cleanup_interval_seconds=300, distance_metric=<VectorDistances.COSINE: 'cosine'>, dynamic_ef_min=100, dynamic_ef_max=500, dynamic_ef_factor=8, ef=-1, ef_construction=128, filter_strategy=<VectorFilterStrategy.SWEEPING: 'sweeping'>, flat_search_cutoff=40000, max_connections=32, skip=False, vector_cache_max_objects=1000000000000), vector_index_type=<VectorIndexType.HNSW: 'hnsw'>, vectorizer_config=None, vectorizer=<Vectorizers.NONE: 'none'>, vector_config=None)\nClient closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T21:00:52.858675",
      "duration": 33.60910201072693,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Of course! Here is the Python code using the latest Weaviate Python client (v4) to connect to Weaviate Cloud, create a collection, batch import 50 objects, and then verify the count.\n\n### Prerequisites\n\n1.  **Install the Weaviate client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set Environment Variables:**\n    Before running the script, make sure you have set the required environment variables in your terminal or system.\n\n    *   **For Linux/macOS:**\n        ```bash\n        export WCD_TEST_URL=\"YOUR-WEAVIATE-CLOUD-URL\"\n        export WCD_TEST_KEY=\"YOUR-WEAVIATE-API-KEY\"\n        ```\n    *   **For Windows (Command Prompt):**\n        ```bash\n        set WCD_TEST_URL=\"YOUR-WEAVIATE-CLOUD-URL\"\n        set WCD_TEST_KEY=\"YOUR-WEAVIATE-API-KEY\"\n        ```\n    *   **For Windows (PowerShell):**\n        ```bash\n        $env:WCD_TEST_URL=\"YOUR-WEAVIATE-CLOUD-URL\"\n        $env:WCD_TEST_KEY=\"YOUR-WEAVIATE-API-KEY\"\n        ```\n\n    Replace `YOUR-WEAVIATE-CLOUD-URL` and `YOUR-WEAVIATE-API-KEY` with your actual credentials from your Weaviate Cloud instance.\n\n### Python Code\n\n```python\nimport os\nimport weaviate\nimport weaviate.classes as wvc\n\n# 1. Get credentials from environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_api_key = os.getenv(\"WCD_TEST_KEY\")\nCOLLECTION_NAME = \"DemoProducts\"\n\n# Check if the environment variables are set\nif not wcd_url or not wcd_api_key:\n    print(\"Error: WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n    exit(1)\n\n# The client is the main entry point to Weaviate\n# This code will connect to your Weaviate Cloud (WCS) instance\nclient = None\ntry:\n    # 2. Connect to Weaviate Cloud\n    print(f\"Connecting to Weaviate Cloud at {wcd_url}...\")\n    client = weaviate.connect_to_wcs(\n        cluster_url=wcd_url,\n        auth_credentials=weaviate.auth.AuthApiKey(wcd_api_key),\n    )\n    print(\"Connection successful.\")\n\n    # For a clean run, we delete the collection if it already exists\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it.\")\n        client.collections.delete(COLLECTION_NAME)\n\n    # 3. Create the \"DemoProducts\" collection\n    print(f\"Creating collection '{COLLECTION_NAME}'...\")\n    products = client.collections.create(\n        name=COLLECTION_NAME,\n        # Define the properties of the objects in this collection\n        properties=[\n            wvc.config.Property(name=\"name\", data_type=wvc.config.DataType.TEXT),\n            wvc.config.Property(name=\"description\", data_type=wvc.config.DataType.TEXT),\n        ],\n        # By default, a vectorizer is configured. For this simple example,\n        # you can explicitly set it to None if you don't need vectors.\n        # If you have a vectorizer module enabled (e.g., text2vec-openai),\n        # Weaviate will automatically create vectors for the text properties.\n        # vectorizer_config=wvc.config.Configure.Vectorizer.none()\n    )\n    print(f\"Collection '{COLLECTION_NAME}' created successfully.\")\n\n\n    # 4. Prepare objects for batch import\n    print(\"Preparing 50 objects for batch import...\")\n    objects_to_add = []\n    for i in range(1, 51):  # Create 50 objects\n        objects_to_add.append({\n            \"name\": f\"Product {i}\",\n            \"description\": f\"This is the description for product number {i}.\"\n        })\n\n    # 5. Batch import the objects\n    print(f\"Starting batch import of {len(objects_to_add)} objects...\")\n    # The `insert_many` method handles batching automatically.\n    batch_result = products.data.insert_many(objects_to_add)\n\n    # Check for errors\n    if batch_result.has_errors:\n        print(\"There were errors during the batch import:\")\n        for item in batch_result.errors:\n            print(f\"  - At index {item['index']}: {item['message']}\")\n    else:\n        print(\"Batch import completed successfully.\")\n\n    # 6. Get and print the number of objects in the collection\n    # The aggregate query is the modern way to get counts and other stats\n    aggregate_response = products.aggregate.over_all(total_count=True)\n\n    print(\"-\" * 20)\n    print(f\"Total number of objects in '{COLLECTION_NAME}': {aggregate_response.total_count}\")\n    print(\"-\" * 20)\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # 7. Close the connection to Weaviate\n    if client:\n        client.close()\n        print(\"Connection to Weaviate closed.\")\n\n```\n\n### How the Code Works\n\n1.  **Environment Variables**: The script securely fetches your Weaviate URL and API key from environment variables using `os.getenv()`. This is better practice than hardcoding credentials.\n2.  **Connect to Weaviate**: It uses `weaviate.connect_to_wcs()` with an `AuthApiKey` object to establish a connection to your Weaviate Cloud instance.\n3.  **Create Collection**:\n    *   It first checks if the collection `DemoProducts` exists and deletes it to ensure the script is repeatable.\n    *   `client.collections.create()` is used to define the new collection.\n    *   The `properties` are defined using `weaviate.classes.config.Property`, specifying the name and `DataType` for each field (`name` and `description`).\n4.  **Prepare Data**: A simple `for` loop generates a list of 50 Python dictionaries, each representing a product object.\n5.  **Batch Import**:\n    *   The `products.data.insert_many()` method is called with the list of objects. This is the modern, efficient way to perform batch imports. The client handles the underlying batching logic for you.\n    *   The result of the operation is checked for errors.\n6.  **Count Objects**: To verify the import, `products.aggregate.over_all(total_count=True)` is used. This is a highly efficient way to get the total count of objects without retrieving the objects themselves.\n7.  **Close Connection**: The `finally` block ensures that `client.close()` is always called, which gracefully terminates the connection to your Weaviate instance.",
      "stdout": "Connecting to Weaviate Cloud at yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud...\nConnection successful.\nCollection 'DemoProducts' already exists. Deleting it.\nCreating collection 'DemoProducts'...\nCollection 'DemoProducts' created successfully.\nPreparing 50 objects for batch import...\nStarting batch import of 50 objects...\nBatch import completed successfully.\n--------------------\nTotal number of objects in 'DemoProducts': 50\n--------------------\nConnection to Weaviate closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T21:01:25.551923",
      "duration": 31.95564293861389,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Of course. Here is the Python code to create a \"DemoProducts\" collection, batch-import 50 objects, and then print the total object count, using the latest Weaviate Python client (v4) syntax and connecting via environment variables.\n\n### Prerequisites\n\n1.  **Install Libraries**: Make sure you have the `weaviate-client` library installed.\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set Environment Variables**: Before running the script, set the required environment variables in your terminal.\n\n    *   **Linux/macOS**:\n        ```bash\n        export WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n\n    *   **Windows (Command Prompt)**:\n        ```bash\n        set WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        set WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n\n    *   **Windows (PowerShell)**:\n        ```powershell\n        $env:WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        $env:WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n\n### Python Code\n\n```python\nimport weaviate\nimport weaviate.classes as wvc\nfrom weaviate.auth import AuthApiKey\nimport os\nimport sys\n\n# --- 1. Get Connection Details from Environment Variables ---\ntry:\n    WCD_URL = os.environ[\"WCD_TEST_URL\"]\n    WCD_API_KEY = os.environ[\"WCD_TEST_KEY\"]\nexcept KeyError:\n    print(\"You must set the WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n    sys.exit(1)\n\n# --- 2. Connect to Weaviate Cloud ---\nprint(f\"Connecting to Weaviate at {WCD_URL}...\")\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_URL,\n    auth_credentials=AuthApiKey(api_key=WCD_API_KEY),\n)\n\ntry:\n    # Define the collection name\n    collection_name = \"DemoProducts\"\n\n    # --- 3. Recreate the Collection ---\n    # To ensure the script is runnable multiple times, we first delete the collection\n    # if it already exists.\n    if client.collections.exists(collection_name):\n        print(f\"Deleting existing collection: '{collection_name}'\")\n        client.collections.delete(collection_name)\n\n    print(f\"Creating new collection: '{collection_name}'\")\n    # Create the collection with the specified properties\n    products = client.collections.create(\n        name=collection_name,\n        properties=[\n            wvc.config.Property(name=\"name\", data_type=wvc.config.DataType.TEXT),\n            wvc.config.Property(name=\"description\", data_type=wvc.config.DataType.TEXT),\n        ]\n    )\n    print(f\"Collection '{collection_name}' created successfully.\")\n\n    # --- 4. Generate Data for Batch Import ---\n    print(\"Generating 50 objects for import...\")\n    data_objects = [\n        {\n            \"name\": f\"Product {i+1}\",\n            \"description\": f\"This is the description for product number {i+1}.\"\n        }\n        for i in range(50)\n    ]\n\n    # --- 5. Batch Import the Objects ---\n    print(\"Starting batch import...\")\n    # Use the collection's batch context manager for efficient importing\n    with products.batch.dynamic() as batch:\n        for data_obj in data_objects:\n            batch.add_object(\n                properties=data_obj\n            )\n\n    # Check for any errors during the batch import\n    if products.batch.failed_objects:\n        print(f\"Number of failed imports: {len(products.batch.failed_objects)}\")\n        print(f\"First failed object: {products.batch.failed_objects[0].message}\")\n    else:\n        print(\"Batch import completed successfully.\")\n\n    # --- 6. Print the Number of Objects in the Collection ---\n    # The modern way to get a count is using the aggregate API\n    response = products.aggregate.over_all(total_count=True)\n\n    print(\"-\" * 20)\n    print(f\"Total number of objects in '{collection_name}': {response.total_count}\")\n    print(\"-\" * 20)\n\nfinally:\n    # --- 7. Close the Connection ---\n    print(\"Closing the client connection.\")\n    client.close()\n\n```\n\n### How to Run the Code\n\n1.  Save the code above as a Python file (e.g., `import_products.py`).\n2.  Set your environment variables as described in the \"Prerequisites\" section.\n3.  Run the script from your terminal:\n    ```bash\n    python import_products.py\n    ```\n\n### Expected Output\n\nYou will see an output similar to this, confirming each step of the process:\n\n```\nConnecting to Weaviate at https://your-cluster-name.weaviate.network...\nDeleting existing collection: 'DemoProducts'\nCreating new collection: 'DemoProducts'\nCollection 'DemoProducts' created successfully.\nGenerating 50 objects for import...\nStarting batch import...\nBatch import completed successfully.\n--------------------\nTotal number of objects in 'DemoProducts': 50\n--------------------\nClosing the client connection.\n```",
      "stdout": "Connecting to Weaviate at yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud...\nDeleting existing collection: 'DemoProducts'\nCreating new collection: 'DemoProducts'\nCollection 'DemoProducts' created successfully.\nGenerating 50 objects for import...\nStarting batch import...\nBatch import completed successfully.\n--------------------\nTotal number of objects in 'DemoProducts': 50\n--------------------\nClosing the client connection.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T21:01:44.994614",
      "duration": 18.76244831085205,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Get Weaviate Cloud connection details from environment variables\n# WCD_TEST_URL is the URL of your Weaviate Cloud instance\n# WCD_TEST_KEY is the API key for your Weaviate Cloud instance\ntry:\n    url = os.environ[\"WCD_TEST_URL\"]\n    api_key = os.environ[\"WCD_TEST_KEY\"]\nexcept KeyError:\n    print(\"Please set the WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n    exit(1)\n\n# Define the collection name\nCOLLECTION_NAME = \"DemoProducts\"\n\n# Connect to Weaviate Cloud\n# For more information on client instantiation, see:\n# https://weaviate.io/developers/weaviate/client-libraries/python\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=url,\n    auth_credentials=Auth.api_key(api_key),\n)\n\nprint(\"Client connected to Weaviate Cloud.\")\n\ntry:\n    # 1. Create the collection\n    # For more information on collection management, see:\n    # https://weaviate.io/developers/weaviate/manage-data/collections\n    \n    # Clean up previous runs by deleting the collection if it exists\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Deleting existing collection: {COLLECTION_NAME}\")\n        client.collections.delete(COLLECTION_NAME)\n\n    print(f\"Creating collection: {COLLECTION_NAME}\")\n    products = client.collections.create(\n        name=COLLECTION_NAME,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ]\n    )\n\n    # 2. Batch import 50 objects\n    # For more information on batch importing, see:\n    # https://weaviate.io/developers/weaviate/manage-data/import\n    print(\"Starting batch import of 50 objects...\")\n\n    # Use a context manager for batching. It will automatically send the batch\n    # when the batch size is reached or when the context manager exits.\n    with products.batch.fixed_size(batch_size=10) as batch:\n        for i in range(50):\n            product_object = {\n                \"name\": f\"Product {i}\",\n                \"description\": f\"This is the description for product {i}.\"\n            }\n            batch.add_object(\n                properties=product_object\n            )\n\n    print(\"Batch import completed.\")\n\n    # 3. Get the total number of objects in the collection\n    # For more information on aggregations, see:\n    # https://weaviate.io/developers/weaviate/search/aggregate\n    response = products.aggregate.over_all(total_count=True)\n    \n    # Print the result\n    print(f\"\\nNumber of objects in '{COLLECTION_NAME}': {response.total_count}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n    print(\"\\nClient connection closed.\")\n```",
      "stdout": "Client connected to Weaviate Cloud.\nDeleting existing collection: DemoProducts\nCreating collection: DemoProducts\nStarting batch import of 50 objects...\nBatch import completed.\n\nNumber of objects in 'DemoProducts': 50\n\nClient connection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:02:14.111627",
      "duration": 28.629097938537598,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Of course. Here is the Python code to query the 'WineReview' collection for \"dessert wine\" using the latest Weaviate client syntax.\n\nThis script connects to Weaviate Cloud, performs a vector search using the `text2vec-openai` module, and prints the results.\n\n### Prerequisites\n\n1.  **Install libraries:**\n    ```bash\n    pip install weaviate-client python-dotenv\n    ```\n\n2.  **Environment Variables:**\n    Create a file named `.env` in the same directory as your Python script and add your credentials:\n    ```.env\n    # Weaviate Cloud credentials\n    WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n    WCD_TEST_KEY=\"YOUR_WEAVIATE_CLOUD_API_KEY\"\n\n    # OpenAI API Key for the vectorizer\n    OPENAI_API_KEY=\"YOUR_OPENAI_API_KEY\"\n    ```\n\n### Python Code\n\n```python\nimport os\nimport weaviate\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\n\n# --- Connection setup ---\n# Check for necessary environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_key = os.getenv(\"WCD_TEST_KEY\")\nopenai_key = os.getenv(\"OPENAI_API_KEY\")\n\nif not all([wcd_url, wcd_key, openai_key]):\n    print(\n        \"Error: Missing environment variables.\"\n        \"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY.\"\n    )\n    exit(1)\n\n# The headers are used to pass the OpenAI API key to the text2vec-openai module\n# Weaviate will use this key to vectorize the query \"dessert wine\".\nheaders = {\n    \"X-OpenAI-Api-Key\": openai_key\n}\n\n# Connect to Weaviate Cloud\n# The latest client syntax uses `weaviate.connect_to_wcs` for cloud instances\ntry:\n    client = weaviate.connect_to_wcs(\n        cluster_url=wcd_url,\n        auth_credentials=weaviate.auth.AuthApiKey(api_key=wcd_key),\n        headers=headers\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\n\n    # --- Query Execution ---\n    # Get a reference to the 'WineReview' collection\n    reviews = client.collections.get(\"WineReview\")\n\n    # Define the search query\n    query_text = \"dessert wine\"\n    print(f\"\\nSearching for wines similar to: '{query_text}'...\")\n\n    # Execute the vector search (near_text) query\n    response = reviews.query.near_text(\n        query=query_text,\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # --- Print Results ---\n    print(f\"Found {len(response.objects)} matching wines:\\n\")\n\n    if not response.objects:\n        print(\"No results found.\")\n    else:\n        for i, wine in enumerate(response.objects):\n            # The properties of each object are in the .properties attribute\n            properties = wine.properties\n            print(f\"--- Result {i+1} ---\")\n            print(f\"  Title:   {properties.get('title')}\")\n            print(f\"  Country: {properties.get('country')}\")\n            print(f\"  Price:   ${properties.get('price'):.2f}\" if properties.get('price') else \"Price: N/A\")\n            print(f\"  Points:  {properties.get('points')}\")\n            print(\"-\" * 15 + \"\\n\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the connection to Weaviate\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"Connection to Weaviate closed.\")\n```\n\n### How the Code Works\n\n1.  **Environment Setup**: It uses `python-dotenv` to load the `WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY` from your `.env` file into the environment.\n2.  **Connection**: It uses the `weaviate.connect_to_wcs()` helper function, which is the modern way to connect to a Weaviate Cloud (WCS) instance.\n3.  **API Key Header**: The OpenAI API key is passed in the `headers` dictionary. Weaviate's `text2vec-openai` module, running on the server, will use this key to convert your query string `\"dessert wine\"` into a vector.\n4.  **Collection Reference**: `client.collections.get(\"WineReview\")` gets an object that represents your collection, allowing you to perform operations on it.\n5.  **Vector Search**: The `reviews.query.near_text()` method performs the core vector search.\n    *   `query=\"dessert wine\"`: This is the text that will be vectorized by OpenAI and used to find similar items in your `WineReview` collection.\n    *   `limit=2`: This restricts the output to the top 2 most relevant results.\n    *   `return_properties=[...]`: This specifies which fields from the matching objects should be returned.\n6.  **Result Handling**: The code iterates through the `response.objects` list, accessing the data for each wine from the `.properties` attribute and printing it in a user-friendly format.\n7.  **Connection Closing**: The `finally` block ensures that `client.close()` is always called, properly closing the connection to your Weaviate instance, even if an error occurs.",
      "stdout": "Successfully connected to Weaviate Cloud.\n\nSearching for wines similar to: 'dessert wine'...\nFound 2 matching wines:\n\n--- Result 1 ---\n  Title:   Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price:   $24.00\n  Points:  88\n---------------\n\n--- Result 2 ---\n  Title:   Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price:   $40.00\n  Points:  88\n---------------\n\nConnection to Weaviate closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:02:35.771637",
      "duration": 21.244331121444702,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "Here is the Python code to query the 'WineReview' collection for wines that best match \"dessert wine\".\n\nThis script uses the latest Weaviate Python client (v4) syntax and connects to Weaviate Cloud using credentials stored in environment variables.\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# --- Load environment variables ---\ntry:\n    WCD_URL = os.environ[\"WCD_TEST_URL\"]\n    WCD_API_KEY = os.environ[\"WCD_TEST_KEY\"]\n    OPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\nexcept KeyError as e:\n    print(f\"Error: Environment variable {e} not set.\")\n    print(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY.\")\n    exit(1)\n\n# Define client and collection name for use in the script\nclient = None\ncollection_name = \"WineReview\"\n\ntry:\n    # --- Connect to Weaviate Cloud ---\n    # The Weaviate client requires the OpenAI API key in the headers\n    # to access the text2vec-openai vectorizer module.\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_URL,\n        auth_credentials=Auth.api_key(WCD_API_KEY),\n        headers={\n            \"X-OpenAI-API-Key\": OPENAI_API_KEY\n        }\n    )\n\n    print(\"Successfully connected to Weaviate.\")\n\n    # --- Get the collection object ---\n    reviews = client.collections.get(collection_name)\n    \n    query_text = \"dessert wine\"\n\n    # --- Perform the nearText query ---\n    response = reviews.query.near_text(\n        query=query_text,\n        limit=2\n    )\n\n    # --- Print the results ---\n    print(f\"\\nTop {len(response.objects)} results for '{query_text}':\\n\")\n\n    if not response.objects:\n        print(\"No results found.\")\n    else:\n        for item in response.objects:\n            # Access the properties of each returned object\n            properties = item.properties\n            \n            print(f\"  Title: {properties.get('title')}\")\n            print(f\"  Country: {properties.get('country')}\")\n            \n            # Format price nicely, handling cases where it might be missing\n            price = properties.get('price')\n            price_str = f\"${price:.2f}\" if price is not None else \"N/A\"\n            print(f\"  Price: {price_str}\")\n            \n            print(f\"  Points: {properties.get('points')}\")\n            print(\"-\" * 25)\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # --- Close the connection ---\n    # It's good practice to close the connection when you're done.\n    if client:\n        client.close()\n        print(\"\\nConnection to Weaviate closed.\")\n\n```\n\n### To run this code:\n\n1.  **Install the necessary library:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set the environment variables** in your terminal before running the script:\n\n    *   **Linux/macOS:**\n        ```bash\n        export WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        export OPENAI_API_KEY=\"YOUR_OPENAI_API_KEY\"\n        ```\n    *   **Windows (Command Prompt):**\n        ```bash\n        set WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        set WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        set OPENAI_API_KEY=\"YOUR_OPENAI_API_KEY\"\n        ```\n    *   **Windows (PowerShell):**\n        ```powershell\n        $env:WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        $env:WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        $env:OPENAI_API_KEY=\"YOUR_OPENAI_API_KEY\"\n        ```\n    Replace the placeholder values with your actual credentials.\n\n3.  **Save the code** as a Python file (e.g., `query_wines.py`).\n\n4.  **Execute the script:**\n    ```bash\n    python query_wines.py\n    ```",
      "stdout": "Successfully connected to Weaviate.\n\nTop 2 results for 'dessert wine':\n\n  Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price: $24.00\n  Points: 88\n-------------------------\n  Title: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price: $40.00\n  Points: 88\n-------------------------\n\nConnection to Weaviate closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:03:01.775582",
      "duration": 25.51286292076111,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\n\n# Get environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_api_key = os.getenv(\"WCD_TEST_KEY\")\nopenai_api_key = os.getenv(\"OPENAI_API_KEY\")\n\n# Check if all required environment variables are set\nif not all([wcd_url, wcd_api_key, openai_api_key]):\n    print(\"Error: Make sure WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY environment variables are set.\")\n    exit(1)\n\ntry:\n    # Connect to your Weaviate Cloud instance\n    # The 'with' statement ensures the client is closed automatically\n    with weaviate.connect_to_weaviate_cloud(\n        cluster_url=wcd_url,\n        auth_credentials=Auth.api_key(wcd_api_key),\n        headers={\n            # The API key for the vectorizer, in this case text2vec-openai\n            \"X-OpenAI-Api-Key\": openai_api_key,\n        }\n    ) as client:\n\n        # Get a reference to the WineReview collection\n        wine_reviews = client.collections.get(\"WineReview\")\n\n        # Perform a semantic search using near_text for \"dessert wine\"\n        # For more information on semantic search, see: https://weaviate.io/developers/weaviate/search/semantic\n        response = wine_reviews.query.near_text(\n            query=\"dessert wine\",\n            limit=2\n        )\n\n        # Print the results\n        print(\"Top 2 wine matches for 'dessert wine':\")\n        if not response.objects:\n            print(\"No results found.\")\n        else:\n            for item in response.objects:\n                # Access the properties of each wine review object\n                wine = item.properties\n                print(f\"\\n  - Title: {wine.get('title')}\")\n                print(f\"    Country: {wine.get('country')}\")\n                \n                price = wine.get('price')\n                # Format price if it exists\n                price_str = f\"${price:.2f}\" if price is not None else \"N/A\"\n                print(f\"    Price: {price_str}\")\n                \n                print(f\"    Points: {wine.get('points')}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\n```",
      "stdout": "Top 2 wine matches for 'dessert wine':\n\n  - Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n    Country: US\n    Price: $24.00\n    Points: 88\n\n  - Title: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n    Country: US\n    Price: $40.00\n    Points: 88\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T21:03:36.536228",
      "duration": 34.27471208572388,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Of course. Here is the Python code to perform the specified hybrid search on the 'WineReview' collection using the latest Weaviate client syntax (v4).\n\n### Prerequisites\n\n1.  **Install Libraries**: Make sure you have the necessary Python libraries installed.\n    ```bash\n    pip install weaviate-client python-dotenv\n    ```\n\n2.  **Set Environment Variables**: Create a file named `.env` in the same directory as your script and add your credentials. The code will load them automatically.\n\n    **.env file**\n    ```\n    # Weaviate Cloud Credentials\n    WCD_TEST_URL=\"your-weaviate-cloud-url\"\n    WCD_TEST_KEY=\"your-weaviate-cloud-api-key\"\n\n    # OpenAI API Key for the vectorizer\n    OPENAI_API_KEY=\"your-openai-api-key\"\n    ```\n\n### Python Code\n\nThis script connects to your Weaviate Cloud instance, builds a multi-part filter, executes the hybrid query, and prints the formatted results.\n\n```python\nimport weaviate\nimport weaviate.classes.query as wvc # Alias for convenience\nimport os\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\n\n# --- 1. Get credentials and check for their existence ---\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_api_key = os.getenv(\"WCD_TEST_KEY\")\nopenai_api_key = os.getenv(\"OPENAI_API_KEY\")\n\nif not all([wcd_url, wcd_api_key, openai_api_key]):\n    print(\"Error: Missing one or more environment variables.\")\n    print(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY.\")\n    exit()\n\n# --- 2. Connect to Weaviate Cloud ---\ntry:\n    # Use weaviate.auth.AuthApiKey for API key authentication\n    auth_config = weaviate.auth.AuthApiKey(api_key=wcd_api_key)\n\n    # Instantiate the client\n    client = weaviate.connect_to_wcs(\n        cluster_url=wcd_url,\n        auth_credentials=auth_config,\n        # Pass the OpenAI API key in the headers for the text2vec-openai vectorizer\n        headers={\n            \"X-OpenAI-Api-Key\": openai_api_key\n        }\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\n    print(f\"Client is ready: {client.is_ready()}\")\n\n    # --- 3. Get a handle to the 'WineReview' collection ---\n    reviews = client.collections.get(\"WineReview\")\n\n    # --- 4. Define the filters ---\n    # We need to combine multiple conditions using AND (all_of) and OR (any_of)\n\n    # Filter for review_body containing one of the specified substrings.\n    # The 'like' operator with wildcards (*) is used for substring matching.\n    review_body_filter = wvc.Filter.any_of([\n        wvc.Filter.by_property(\"review_body\").like(\"*spice*\"),\n        wvc.Filter.by_property(\"review_body\").like(\"*fruit*\"),\n        wvc.Filter.by_property(\"review_body\").like(\"*berry*\"),\n        wvc.Filter.by_property(\"review_body\").like(\"*cherry*\"),\n        wvc.Filter.by_property(\"review_body\").like(\"*honey*\"),\n    ])\n\n    # Combine all filters with an AND condition\n    combined_filter = wvc.Filter.all_of([\n        wvc.Filter.by_property(\"price\").less_than(50),\n        wvc.Filter.by_property(\"points\").greater_than(90),\n        review_body_filter\n    ])\n\n\n    # --- 5. Execute the hybrid query ---\n    print(\"\\nExecuting hybrid query for 'pair with steak'...\\n\")\n    response = reviews.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,  # Equal weight to vector (semantic) and keyword (BM25) search\n        limit=5,\n        filters=combined_filter,\n        # Specify which properties to return for efficiency\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # --- 6. Print the results ---\n    if not response.objects:\n        print(\"No matching wines found with the specified criteria.\")\n    else:\n        print(\"Found matching wines:\")\n        print(\"--------------------\")\n        for item in response.objects:\n            # Access properties through the .properties attribute\n            properties = item.properties\n            print(f\"  Title: {properties.get('title')}\")\n            print(f\"  Country: {properties.get('country')}\")\n            print(f\"  Price: ${properties.get('price'):.2f}\")\n            print(f\"  Points: {properties.get('points')}\")\n            print(\"--------------------\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # --- 7. Close the connection ---\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"\\nConnection to Weaviate closed.\")\n\n```\n\n### Explanation\n\n1.  **Environment Setup**: The code first loads your credentials from the `.env` file using `python-dotenv`. It includes a check to ensure all required variables are present.\n2.  **Connection**: It establishes a secure connection to your Weaviate Cloud Services (WCS) instance using `weaviate.connect_to_wcs`. The WCS API key is passed via `auth_credentials`, and the OpenAI API key is passed via `headers`, which the Weaviate instance will use for vectorization.\n3.  **Collection Handle**: `client.collections.get(\"WineReview\")` gets an object that allows you to interact with your specific collection.\n4.  **Filter Construction**: This is a key part of the query.\n    *   We use `weaviate.classes.query` (aliased as `wvc`) to build filter objects.\n    *   `Filter.any_of([...])` creates an `OR` condition. We use it to check if the `review_body` contains *any* of the required keywords. The `like` operator with `*` wildcards is used for substring matching.\n    *   `Filter.all_of([...])` creates an `AND` condition, combining the price, points, and the nested `review_body` filter.\n5.  **Hybrid Query**: The `.query.hybrid()` method is called on the collection object.\n    *   `query`: The text for the search.\n    *   `alpha=0.5`: This balances the keyword-based (BM25) search and the vector-based (semantic) search equally.\n    *   `limit=5`: Sets the maximum number of results to return.\n    *   `filters=combined_filter`: Applies our complex filter to the search results.\n    *   `return_properties`: Specifies exactly which data fields to retrieve, which is more efficient than fetching all properties.\n6.  **Result Processing**: The code iterates through `response.objects`. Each `item` in this list contains the data for a single result, accessible via `item.properties`.\n7.  **Connection Closing**: The `finally` block ensures that `client.close()` is always called, properly terminating the connection to your Weaviate instance.",
      "stdout": "Successfully connected to Weaviate Cloud.\nClient is ready: True\n\nExecuting hybrid query for 'pair with steak'...\n\nFound matching wines:\n--------------------\n  Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price: $40.00\n  Points: 92\n--------------------\n  Title: Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price: $49.00\n  Points: 91\n--------------------\n  Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price: $27.00\n  Points: 91\n--------------------\n  Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price: $25.00\n  Points: 93\n--------------------\n  Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price: $0.00\n  Points: 92\n--------------------\n\nConnection to Weaviate closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T21:04:11.232865",
      "duration": 34.21325063705444,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "Here is the Python code to perform the specified hybrid search on the 'WineReview' collection using the latest Weaviate client syntax.\n\nThis script connects to your Weaviate Cloud instance, executes a hybrid search for wines that match \"pair with steak\", and applies multiple filters for price, points, and keywords in the review.\n\n### Prerequisites\n1.  **Install Weaviate Client:**\n    ```bash\n    pip install weaviate-client\n    ```\n2.  **Set Environment Variables:**\n    Ensure you have set the following environment variables in your system or terminal session:\n    ```bash\n    export WCD_TEST_URL=\"your-weaviate-cloud-url\"\n    export WCD_TEST_KEY=\"your-weaviate-cloud-api-key\"\n    export OPENAI_API_KEY=\"your-openai-api-key\"\n    ```\n\n### Python Code\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\nimport os\nimport sys\n\n# --- 1. Connect to Weaviate Cloud ---\n# Get credentials from environment variables\ntry:\n    WCD_URL = os.environ[\"WCD_TEST_URL\"]\n    WCD_KEY = os.environ[\"WCD_TEST_KEY\"]\n    OPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\nexcept KeyError:\n    print(\"Error: Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY environment variables.\")\n    sys.exit(1)\n\ntry:\n    # Connect to your Weaviate instance\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_URL,\n        auth_credentials=Auth.api_key(WCD_KEY),\n        headers={\n            # The 'text2vec-openai' vectorizer requires the OpenAI API key\n            \"X-OpenAI-API-Key\": OPENAI_API_KEY\n        },\n    )\n\n    # --- 2. Get the 'WineReview' collection ---\n    wine_reviews = client.collections.get(\"WineReview\")\n\n    # --- 3. Define the filters for the query ---\n    # We combine multiple conditions using the '&' (AND) operator.\n    wine_filters = (\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    )\n\n    # --- 4. Execute the hybrid search query ---\n    response = wine_reviews.query.hybrid(\n        query=\"pair with steak\",\n        limit=5,\n        alpha=0.5,  # 0.5 means an equal balance between vector and keyword search\n        filters=wine_filters,\n    )\n\n    # --- 5. Print the results ---\n    print(\"Found wines that pair with steak (price < 50, points > 90):\")\n    if not response.objects:\n        print(\"No matching wines found.\")\n    else:\n        for i, item in enumerate(response.objects):\n            # Access the properties of each returned object\n            properties = item.properties\n            print(f\"\\n--- Result {i+1} ---\")\n            print(f\"  Title: {properties.get('title', 'N/A')}\")\n            print(f\"  Country: {properties.get('country', 'N/A')}\")\n            \n            # Safely get and format the price\n            price = properties.get('price')\n            if price is not None:\n                print(f\"  Price: ${price:.2f}\")\n            else:\n                print(\"  Price: N/A\")\n            \n            print(f\"  Points: {properties.get('points', 'N/A')}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # --- 6. Close the connection ---\n    # It's a good practice to close the connection when you're done\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"\\nConnection to Weaviate closed.\")\n\n```\n\n### Explanation\n\n1.  **Connection**: The script connects to your Weaviate Cloud instance using `weaviate.connect_to_weaviate_cloud`. It passes the necessary `cluster_url`, `auth_credentials`, and a `headers` dictionary containing the `X-OpenAI-API-Key`, which is required by the `text2vec-openai` vectorizer.\n2.  **Collection Handle**: It gets a reference to the `WineReview` collection using `client.collections.get(\"WineReview\")`.\n3.  **Filtering**: It constructs a complex filter by chaining multiple `Filter` conditions with the `&` operator, ensuring all conditions must be met (logical AND).\n    *   `Filter.by_property(\"price\").less_than(50)`: Filters for wines with a price below 50.\n    *   `Filter.by_property(\"points\").greater_than(90)`: Filters for wines with a rating above 90.\n    *   `Filter.by_property(\"review_body\").contains_any([...])`: Filters for reviews that include at least one of the specified keywords.\n4.  **Hybrid Query**: The `collection.query.hybrid()` method is called with:\n    *   `query`: The text to search for, \"pair with steak\".\n    *   `limit`: The maximum number of results to return (5).\n    *   `alpha`: Set to `0.5` for an even blend of vector (semantic) search and keyword (BM25) search.\n    *   `filters`: The combined filter object created in the previous step.\n5.  **Output**: The script iterates through `response.objects` and prints the requested properties (`title`, `country`, `price`, `points`) for each matching wine in a formatted way.\n6.  **Cleanup**: The `try...finally` block ensures that the client connection is properly closed at the end of the script, even if an error occurs.",
      "stdout": "Found wines that pair with steak (price < 50, points > 90):\n\n--- Result 1 ---\n  Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price: $40.00\n  Points: 92\n\n--- Result 2 ---\n  Title: Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price: $49.00\n  Points: 91\n\n--- Result 3 ---\n  Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price: $27.00\n  Points: 91\n\n--- Result 4 ---\n  Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price: $25.00\n  Points: 93\n\n--- Result 5 ---\n  Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price: $0.00\n  Points: 92\n\nConnection to Weaviate closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T21:04:39.521672",
      "duration": 27.782668113708496,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\n\n# This script performs a hybrid search on a 'WineReview' collection in Weaviate.\n# It finds up to 5 wines that are a good match for \"pair with steak\",\n# applying specific filters on price, points, and review content.\n\n# Ensure your environment variables are set before running the script:\n# os.environ[\"WCD_TEST_URL\"] = \"YOUR_WCD_URL\"\n# os.environ[\"WCD_TEST_KEY\"] = \"YOUR_WCD_API_KEY\"\n# os.environ[\"OPENAI_API_KEY\"] = \"YOUR_OPENAI_API_KEY\"\n\ntry:\n    # 1. Connect to Weaviate Cloud\n    # The client connects to the Weaviate instance specified by the WCD_TEST_URL\n    # and authenticates with the WCD_TEST_KEY.\n    # The OpenAI API key is passed in the headers for the text2vec-openai vectorizer.\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.getenv(\"WCD_TEST_URL\"),\n        auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\")),\n        headers={\n            \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")\n        }\n    )\n    print(\"Successfully connected to Weaviate.\")\n\n    # 2. Get the 'WineReview' collection object\n    # For more information on collections, see:\n    # https://weaviate.io/developers/weaviate/manage-data/collections\n    wine_reviews = client.collections.get(\"WineReview\")\n\n    # 3. Define the search filters\n    # The query requires multiple conditions to be met. We build a filter for each\n    # and then combine them.\n    # For more information on filtering, see:\n    # https://weaviate.io/developers/weaviate/search/filters\n\n    # Filter for price less than 50\n    price_filter = Filter.by_property(\"price\").less_than(50)\n\n    # Filter for points greater than 90\n    points_filter = Filter.by_property(\"points\").greater_than(90)\n\n    # Create a list of keyword filters for the review body.\n    # The `like` operator with wildcards (*) allows for substring matching.\n    keyword_filters = [\n        Filter.by_property(\"review_body\").like(\"*spice*\"),\n        Filter.by_property(\"review_body\").like(\"*fruit*\"),\n        Filter.by_property(\"review_body\").like(\"*berry*\"),\n        Filter.by_property(\"review_body\").like(\"*cherry*\"),\n        Filter.by_property(\"review_body\").like(\"*honey*\"),\n    ]\n    # Combine the keyword filters using an OR condition with `Filter.any_of`.\n    # This means an object will be included if its review_body matches AT LEAST ONE of these patterns.\n    review_body_filter = Filter.any_of(keyword_filters)\n\n    # Combine all individual filters using an AND condition with `Filter.all_of`.\n    # An object must satisfy the price, points, AND review body conditions to be returned.\n    combined_filter = Filter.all_of([\n        price_filter,\n        points_filter,\n        review_body_filter\n    ])\n\n    # 4. Execute the hybrid search query\n    # Hybrid search combines vector search (semantic) and keyword search (BM25).\n    # The `alpha` parameter balances the two: alpha=0 is pure keyword, alpha=1 is pure vector.\n    # For more information on hybrid search, see:\n    # https://weaviate.io/developers/weaviate/search/hybrid\n    response = wine_reviews.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        limit=5,\n        filters=combined_filter,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # 5. Print the results\n    print(\"\\n--- Query Results ---\")\n    print(\"Wines that pair with steak (price < 50, points > 90):\")\n\n    if not response.objects:\n        print(\"No matching wines found.\")\n    else:\n        for i, obj in enumerate(response.objects):\n            properties = obj.properties\n            print(f\"\\nResult {i+1}:\")\n            print(f\"  Title: {properties.get('title')}\")\n            print(f\"  Country: {properties.get('country')}\")\n            print(f\"  Price: ${properties.get('price')}\")\n            print(f\"  Points: {properties.get('points')}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n    print(\"Please check your environment variables (WCD_TEST_URL, WCD_TEST_KEY, OPENAI_API_KEY) and collection name.\")\n\nfinally:\n    # 6. Close the client connection\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"\\nConnection to Weaviate closed.\")\n```",
      "stdout": "Successfully connected to Weaviate.\n\n--- Query Results ---\nWines that pair with steak (price < 50, points > 90):\n\nResult 1:\n  Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price: $40.0\n  Points: 92\n\nResult 2:\n  Title: Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price: $49.0\n  Points: 91\n\nResult 3:\n  Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price: $27.0\n  Points: 91\n\nResult 4:\n  Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price: $25.0\n  Points: 93\n\nResult 5:\n  Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price: $0.0\n  Points: 92\n\nConnection to Weaviate closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    }
  },
  "gemini/gemini-2.5-flash": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T21:04:47.549627",
      "duration": 7.99111795425415,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "To connect to Weaviate Cloud using environment variables and check server readiness with the latest `weaviate-client` syntax, you would do the following:\n\nFirst, make sure you have the latest Weaviate client installed:\n`pip install weaviate-client`\n\nThen, set your environment variables (replace with your actual URL and key):\n```bash\nexport WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\nexport WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n```\n\nHere's the Python code:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\nfrom weaviate.exceptions import WeaviateConnectionError\n\nprint(\"Attempting to connect to Weaviate Cloud...\")\n\n# Retrieve environment variables\nweaviate_url = os.getenv(\"WCD_TEST_URL\")\nweaviate_api_key = os.getenv(\"WCD_TEST_KEY\")\n\n# --- Input Validation ---\nif not weaviate_url:\n    print(\"Error: Environment variable WCD_TEST_URL is not set.\")\n    exit(1)\nif not weaviate_api_key:\n    print(\"Error: Environment variable WCD_TEST_KEY is not set.\")\n    exit(1)\n\n# --- Connect to Weaviate Cloud ---\ntry:\n    # Use the 'with' statement for automatic resource management (closing the connection)\n    with weaviate.connect(\n        cluster_url=weaviate_url,\n        auth_credentials=AuthApiKey(weaviate_api_key)\n    ) as client:\n        print(\"\\nSuccessfully connected to Weaviate!\")\n\n        # --- Check Server Readiness ---\n        if client.is_ready():\n            print(\"Weaviate server is ready to accept requests.\")\n        else:\n            print(\"Weaviate server is NOT ready to accept requests.\")\n\nexcept WeaviateConnectionError as e:\n    print(f\"\\nFailed to connect to Weaviate: {e}\")\n    print(\"Please check your WCD_TEST_URL, WCD_TEST_KEY, and network connection.\")\nexcept Exception as e:\n    print(f\"\\nAn unexpected error occurred: {e}\")\n\nprint(\"\\nScript finished.\")\n```",
      "stdout": "Attempting to connect to Weaviate Cloud...\n\nAn unexpected error occurred: 'module' object is not callable\n\nScript finished.\n",
      "stderr": "",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T21:04:52.065841",
      "duration": 4.477972030639648,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Retrieve Weaviate Cloud credentials from environment variables\nweaviate_cloud_url = os.getenv(\"WCD_TEST_URL\")\nweaviate_cloud_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not weaviate_cloud_url:\n    raise ValueError(\"Environment variable WCD_TEST_URL not set.\")\nif not weaviate_cloud_key:\n    raise ValueError(\"Environment variable WCD_TEST_KEY not set.\")\n\nclient = None  # Initialize client to None for the finally block\n\ntry:\n    # Connect to the Weaviate Cloud instance\n    print(f\"Attempting to connect to Weaviate Cloud at URL: {weaviate_cloud_url}\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=weaviate_cloud_url,\n        auth_credentials=Auth.api_key(weaviate_cloud_key)\n    )\n\n    # Check if the server is ready to accept requests\n    if client.is_ready():\n        print(\"Weaviate server is ready to accept requests.\")\n    else:\n        print(\"Weaviate server is NOT ready.\")\n        # Optionally, raise an error if not ready\n        # raise ConnectionError(\"Weaviate server did not report as ready.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n    print(\"Please ensure your WCD_TEST_URL and WCD_TEST_KEY are correct and the instance is running.\")\n\nfinally:\n    # Always close the client connection\n    if client:\n        print(\"Closing Weaviate client connection.\")\n        client.close()\n    else:\n        print(\"Client was not initialized, no connection to close.\")\n\n```",
      "stdout": "Attempting to connect to Weaviate Cloud at URL: yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\nWeaviate server is ready to accept requests.\nClosing Weaviate client connection.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T21:05:04.929472",
      "duration": 12.826225996017456,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "To create a Weaviate collection named \"DemoProducts\" with the specified properties, connect to Weaviate Cloud, and handle existing collections, use the following Python code.\n\nBefore running, ensure you have the `weaviate-client` library installed (`pip install weaviate-client`). Also, set your Weaviate Cloud URL and API key as environment variables: `WCD_TEST_URL` and `WCD_TEST_KEY`.\n\n```bash\nexport WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\nexport WCD_TEST_KEY=\"YOUR_WEAVIATE_CLOUD_API_KEY\"\n```\n\nThen, run the Python script.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType, Collection\n\n# --- Configuration ---\nWEAVIATE_URL = os.environ.get(\"WCD_TEST_URL\")\nWEAVIATE_API_KEY = os.environ.get(\"WCD_TEST_KEY\")\nCOLLECTION_NAME = \"DemoProducts\"\n\n# --- Pre-check environment variables ---\nif not WEAVIATE_URL or not WEAVIATE_API_KEY:\n    print(\"Error: Please set the environment variables WCD_TEST_URL and WCD_TEST_KEY.\")\n    print(\"Example: export WCD_TEST_URL='YOUR_WEAVIATE_CLOUD_URL'\")\n    print(\"Example: export WCD_TEST_KEY='YOUR_WEAVIATE_CLOUD_API_KEY'\")\n    exit(1)\n\nprint(f\"Attempting to connect to Weaviate at: {WEAVIATE_URL}\")\n\nclient = None # Initialize client to None for the finally block\n\ntry:\n    # --- 1. Connect to Weaviate Cloud ---\n    client = weaviate.connect_to_wcs(\n        url=WEAVIATE_URL,\n        auth_credentials=weaviate.classes.Auth.api_key(WEAVIATE_API_KEY),\n        # You can add a `timeout_config` here if needed, e.g., (10, 60)\n    )\n    print(\"Successfully connected to Weaviate!\")\n\n    # --- 2. If the collection already exists, delete it first ---\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it...\")\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n    else:\n        print(f\"Collection '{COLLECTION_NAME}' does not exist. Proceeding to create.\")\n\n    # --- 3. Define the collection schema ---\n    # Using weaviate.classes.config.Collection for schema definition\n    # and weaviate.classes.config.Property for individual properties.\n    products_collection_definition = Collection(\n        name=COLLECTION_NAME,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ],\n        # You can also add vectorizer_config, generatative_config, etc. here if needed.\n        # For simplicity, we'll use default vectorizer (text2vec-contextionary or similar based on cloud setup)\n        # and no generative module for this example.\n    )\n\n    # --- 4. Create the collection ---\n    client.collections.create(products_collection_definition)\n    print(f\"Collection '{COLLECTION_NAME}' created successfully with specified properties.\")\n\n    # --- Optional: Verify the collection creation ---\n    # You can uncomment this section to inspect the created schema\n    # print(\"\\nVerifying collection schema:\")\n    # collection_object = client.collections.get(COLLECTION_NAME)\n    # print(f\"Collection Name: {collection_object.name}\")\n    # print(\"Properties:\")\n    # for prop in collection_object.properties:\n    #     print(f\"  - Name: {prop.name}, DataType: {prop.data_type}\")\n\nexcept weaviate.exceptions.WeaviateConnectionError as e:\n    print(f\"Weaviate connection error: {e}\")\nexcept weaviate.exceptions.WeaviateGRPCError as e:\n    print(f\"Weaviate gRPC error: {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # --- 5. Close the client connection ---\n    if client:\n        client.close()\n        print(\"Weaviate client connection closed.\")\n\n```",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 3, in <module>\n    from weaviate.classes.config import Property, DataType, Collection\nImportError: cannot import name 'Collection' from 'weaviate.classes.config' (/usr/local/lib/python3.9/site-packages/weaviate/classes/config.py)\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T21:05:10.855506",
      "duration": 5.8892810344696045,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# 1. Retrieve Weaviate Cloud URL and API key from environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not WCD_TEST_URL:\n    print(\"Error: WCD_TEST_URL environment variable not set.\")\n    exit(1)\nif not WCD_TEST_KEY:\n    print(\"Error: WCD_TEST_KEY environment variable not set.\")\n    exit(1)\n\n# Connect to the Weaviate Cloud instance\nprint(f\"Connecting to Weaviate Cloud at: {WCD_TEST_URL}\")\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY)\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\nexcept Exception as e:\n    print(f\"Failed to connect to Weaviate Cloud: {e}\")\n    exit(1)\n\n# Define the collection name\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (as per requirement)\nprint(f\"Checking if collection '{collection_name}' already exists...\")\nif client.collections.exists(collection_name):\n    print(f\"Collection '{collection_name}' already exists. Deleting it...\")\n    try:\n        client.collections.delete(collection_name)\n        print(f\"Collection '{collection_name}' deleted successfully.\")\n    except Exception as e:\n        print(f\"Error deleting collection '{collection_name}': {e}\")\n        client.close()\n        exit(1)\nelse:\n    print(f\"Collection '{collection_name}' does not exist. Proceeding to create.\")\n\n# Define the properties for the collection\nproperties_to_add = [\n    Property(name=\"name\", data_type=DataType.TEXT),\n    Property(name=\"description\", data_type=DataType.TEXT),\n    Property(name=\"price\", data_type=DataType.NUMBER),\n    Property(name=\"in_stock\", data_type=DataType.BOOL),\n]\n\n# Create the collection\nprint(f\"Creating collection '{collection_name}' with specified properties...\")\ntry:\n    products_collection = client.collections.create(\n        name=collection_name, # Use 'name' parameter for collection name\n        properties=properties_to_add\n    )\n    print(f\"Collection '{products_collection.name}' created successfully!\")\n    print(\"Properties created:\")\n    for prop in properties_to_add:\n        print(f\"  - Name: {prop.name}, DataType: {prop.data_type}\")\n\nexcept weaviate.exceptions.WeaviateBaseError as e:\n    print(f\"Error creating collection: {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # Close connection\n    print(\"Closing Weaviate connection.\")\n    client.close()\n\n```",
      "stdout": "Connecting to Weaviate Cloud at: yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\nSuccessfully connected to Weaviate Cloud.\nChecking if collection 'DemoProducts' already exists...\nCollection 'DemoProducts' already exists. Deleting it...\nCollection 'DemoProducts' deleted successfully.\nCreating collection 'DemoProducts' with specified properties...\nCollection 'DemoProducts' created successfully!\nProperties created:\nAn unexpected error occurred: 'Property' object has no attribute 'data_type'\nClosing Weaviate connection.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T21:05:18.609378",
      "duration": 7.716861009597778,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Define environment variables (replace with your actual values if not set)\n# For demonstration purposes, you might want to uncomment and set them directly\n# if running outside an environment where they are pre-configured.\n# os.environ[\"WCD_TEST_URL\"] = \"YOUR_WEAVIATE_CLOUD_URL\"\n# os.environ[\"WCD_TEST_KEY\"] = \"YOUR_WEAVIATE_API_KEY\"\n\n# Ensure the environment variables are set\ntry:\n    WEAVIATE_URL = os.environ[\"WCD_TEST_URL\"]\n    WEAVIATE_API_KEY = os.environ[\"WCD_TEST_KEY\"]\nexcept KeyError:\n    print(\"Please set the environment variables WCD_TEST_URL and WCD_TEST_KEY.\")\n    print(\"Example: export WCD_TEST_URL='https://YOUR_CLUSTER_URL.weaviate.cloud'\")\n    print(\"Example: export WCD_TEST_KEY='YOUR_API_KEY'\")\n    exit(1)\n\nCOLLECTION_NAME = \"DemoProducts\"\n\n# Connect to Weaviate Cloud using the environment variables\nprint(f\"Connecting to Weaviate Cloud at {WEAVIATE_URL}...\")\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WEAVIATE_URL,\n    auth_credentials=Auth.api_key(WEAVIATE_API_KEY)\n)\n\ntry:\n    # Check if the collection already exists\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it...\")\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n    else:\n        print(f\"Collection '{COLLECTION_NAME}' does not exist. Proceeding to create.\")\n\n    # Define the properties for the \"DemoProducts\" collection\n    product_properties = [\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n\n    # Create the \"DemoProducts\" collection\n    # We will use a default vectorizer (e.g., text2vec-weaviate) which is often\n    # suitable for basic text properties if not specified, or you can explicitly\n    # configure one if needed. For this example, we'll keep it simple as the\n    # prompt didn't specify vectorizer requirements.\n    # If a vectorizer is required, add `vector_config=Configure.Vectors.text2vec_weaviate()` or similar.\n    client.collections.create(\n        name=COLLECTION_NAME,\n        properties=product_properties,\n        # Optional: You can add a vectorizer here if desired, e.g.:\n        # vector_config=Configure.Vectors.text2vec_weaviate(),\n        # For a collection focusing on product data, a text-based vectorizer\n        # would typically be used on 'name' and 'description' properties.\n    )\n\n    print(f\"Collection '{COLLECTION_NAME}' created successfully with specified properties.\")\n\n    # Verify the creation by listing collections or getting the collection details\n    print(\"\\nVerifying collection creation:\")\n    if client.collections.exists(COLLECTION_NAME):\n        collection_obj = client.collections.get(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' exists.\")\n        print(\"Properties:\")\n        # Note: The `properties` attribute of `collection_obj.config` directly gives a list of `Property` objects\n        # from which you can extract name and data_type.\n        for prop in collection_obj.config.get().properties:\n            print(f\"- Name: {prop.name}, Data Type: {prop.data_type}\")\n    else:\n        print(f\"Failed to find collection '{COLLECTION_NAME}' after creation attempt.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    # Ensure the client connection is closed\n    if client.is_connected():\n        client.close()\n        print(\"\\nWeaviate client connection closed.\")\n\n```",
      "stdout": "Connecting to Weaviate Cloud at yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud...\nCollection 'DemoProducts' already exists. Deleting it...\nCollection 'DemoProducts' deleted.\nCollection 'DemoProducts' created successfully with specified properties.\n\nVerifying collection creation:\nCollection 'DemoProducts' exists.\nProperties:\n- Name: name, Data Type: text\n- Name: description, Data Type: text\n- Name: price, Data Type: number\n- Name: in_stock, Data Type: boolean\n\nWeaviate client connection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:05:32.708149",
      "duration": 13.44242525100708,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "This Python code will connect to your Weaviate Cloud instance, create a new collection (or recreate it if it already exists), batch import 50 objects, and then print the total number of objects in the collection.\n\nMake sure you have the `weaviate-client` library installed:\n`pip install weaviate-client`\n\nBefore running the script, set your environment variables:\nFor Linux/macOS:\n```bash\nexport WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\nexport WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\npython your_script_name.py\n```\n\nFor Windows (Command Prompt):\n```cmd\nset WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\nset WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\npython your_script_name.py\n```\n\nFor Windows (PowerShell):\n```powershell\n$env:WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n$env:WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\npython your_script_name.py\n```\n\nReplace `\"YOUR_WEAVIATE_CLUSTER_URL\"` and `\"YOUR_WEAVIATE_API_KEY\"` with your actual Weaviate Cloud credentials.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.exceptions import WeaviateCollectionAlreadyExistsError\n\n# --- Configuration ---\nWEAVIATE_CLUSTER_URL = os.getenv(\"WCD_TEST_URL\")\nWEAVIATE_API_KEY = os.getenv(\"WCD_TEST_KEY\")\nCOLLECTION_NAME = \"DemoProducts\"\nNUM_OBJECTS_TO_IMPORT = 50\n\n# --- Validate Environment Variables ---\nif not WEAVIATE_CLUSTER_URL:\n    print(\"Error: WCD_TEST_URL environment variable not set.\")\n    exit(1)\nif not WEAVIATE_API_KEY:\n    print(\"Error: WCD_TEST_KEY environment variable not set.\")\n    exit(1)\n\nprint(f\"Connecting to Weaviate Cloud at: {WEAVIATE_CLUSTER_URL[:30]}...\")\n\nclient = None # Initialize client to None for finally block\n\ntry:\n    # --- Connect to Weaviate Cloud ---\n    # The new client syntax uses connect_to_weaviate_cloud for WCD instances\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WEAVIATE_CLUSTER_URL,\n        api_key=WEAVIATE_API_KEY\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\n\n    # --- Define and Create Collection ---\n    # Check if the collection already exists and delete it for a clean run\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it...\")\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n\n    print(f\"Creating collection '{COLLECTION_NAME}'...\")\n    products_collection = client.collections.create(\n        name=COLLECTION_NAME,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT)\n        ],\n        # You can add vectorizer_config, generative_config etc. here if needed\n        # vectorizer_config=weaviate.classes.config.Configure.Vectorizer.text2vec_contextionary(),\n        # generative_config=weaviate.classes.config.Configure.Generative.palm()\n    )\n    print(f\"Collection '{COLLECTION_NAME}' created successfully.\")\n\n    # --- Prepare Objects for Batch Import ---\n    data_objects_to_import = []\n    for i in range(NUM_OBJECTS_TO_IMPORT):\n        data_objects_to_import.append({\n            \"name\": f\"Product {i + 1}\",\n            \"description\": f\"This is the description for Product number {i + 1}. It is an arbitrary product for demonstration purposes.\"\n        })\n\n    print(f\"Preparing to batch import {len(data_objects_to_import)} objects...\")\n\n    # --- Batch Import Objects ---\n    # Use insert_many for efficient batch importing\n    inserted_uuids = products_collection.data.insert_many(data_objects_to_import)\n    print(f\"Batch import completed. Inserted {len(inserted_uuids)} objects.\")\n    # print(f\"UUIDs of inserted objects: {inserted_uuids}\") # Uncomment to see UUIDs\n\n    # --- Get and Print Number of Objects ---\n    # Use the aggregate method to get collection statistics like total count\n    aggregate_results = products_collection.query.aggregate()\n    total_objects = aggregate_results.total_count\n\n    print(f\"\\n--- Import Summary ---\")\n    print(f\"Total number of objects in '{COLLECTION_NAME}': {total_objects}\")\n\nexcept WeaviateCollectionAlreadyExistsError:\n    print(f\"Error: Collection '{COLLECTION_NAME}' already exists and could not be deleted/recreated. \"\n          \"Please ensure the client has necessary permissions or manually delete it.\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    # --- Close the client connection ---\n    if client and client.is_connected():\n        client.close()\n        print(\"Weaviate client connection closed.\")\n```",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 4, in <module>\n    from weaviate.exceptions import WeaviateCollectionAlreadyExistsError\nImportError: cannot import name 'WeaviateCollectionAlreadyExistsError' from 'weaviate.exceptions' (/usr/local/lib/python3.9/site-packages/weaviate/exceptions.py)\n",
      "exit_code": 1
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:05:44.477741",
      "duration": 11.043129920959473,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.exceptions import WeaviateClosedError\n\n# 1. Get Weaviate Cloud credentials from environment variables\nWCD_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_KEY = os.getenv(\"WCD_TEST_KEY\")\n\nif not WCD_URL or not WCD_KEY:\n    print(\"Error: WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n    print(\"Please set them before running the script.\")\n    exit(1)\n\nCOLLECTION_NAME = \"DemoProducts\"\nNUM_OBJECTS_TO_IMPORT = 50\n\nclient = None  # Initialize client to None for finally block\n\ntry:\n    # 2. Connect to Weaviate Cloud\n    print(f\"Connecting to Weaviate Cloud at: {WCD_URL}...\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_URL,\n        auth_credentials=weaviate.Auth.api_key(WCD_KEY),\n    )\n    print(\"Connection successful!\")\n\n    # 3. Handle the collection: Delete if it exists, then create it\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it...\")\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n\n    print(f\"Creating collection '{COLLECTION_NAME}'...\")\n    collection = client.collections.create(\n        name=COLLECTION_NAME,\n        properties=[\n            weaviate.CollectionProperty(name=\"name\", data_type=weaviate.config.DataType.TEXT),\n            weaviate.CollectionProperty(name=\"description\", data_type=weaviate.config.DataType.TEXT),\n        ],\n        # Example: Disable vector indexing if not needed for this collection type\n        # vectorizer_config=weaviate.collections.classes.config.Configure.Vectorizer.none(),\n        # inverted_index_config=weaviate.collections.classes.config.Configure.inverted_index(\n        #     bm25_token_weights_for_properties=[\"name\", \"description\"]\n        # )\n    )\n    print(f\"Collection '{COLLECTION_NAME}' created successfully.\")\n\n    # 4. Prepare arbitrary objects for import\n    print(f\"Preparing {NUM_OBJECTS_TO_IMPORT} objects for import...\")\n    data_rows = [\n        {\n            \"name\": f\"Product {i+1}\",\n            \"description\": f\"This is the description for Product {i+1}. It's a fantastic item!\"\n        }\n        for i in range(NUM_OBJECTS_TO_IMPORT)\n    ]\n\n    # 5. Batch import objects\n    print(f\"Starting batch import of {NUM_OBJECTS_TO_IMPORT} objects...\")\n    with collection.batch.dynamic() as batch:\n        for i, data_row in enumerate(data_rows):\n            batch.add_object(\n                properties=data_row,\n                # You can also add a UUID explicitly if needed, e.g., uuid=generate_uuid_from_string(f\"product-{i}\")\n            )\n            if batch.number_errors > 0 and batch.number_errors > NUM_OBJECTS_TO_IMPORT * 0.1: # Stop if more than 10% errors\n                print(f\"Batch import stopped due to excessive errors ({batch.number_errors} errors).\")\n                break\n        print(f\"Batching complete. Number of objects added to batch: {batch.number_objects_added}.\")\n    \n    # Check for failed objects after the batch is processed (context manager handles flushing)\n    failed_objects = collection.batch.failed_objects\n    if failed_objects:\n        print(f\"\\n--- Batch Import Summary ---\")\n        print(f\"Number of objects successfully imported: {batch.number_objects_added - len(failed_objects)}\")\n        print(f\"Number of failed imports: {len(failed_objects)}\")\n        if len(failed_objects) > 0:\n            print(f\"First failed object: {failed_objects[0]}\")\n    else:\n        print(f\"\\nAll {batch.number_objects_added} objects seem to have been imported successfully.\")\n\n\n    # 6. Print the number of objects in the collection\n    print(f\"\\nRetrieving total count of objects in '{COLLECTION_NAME}'...\")\n    total_objects = len(collection)\n    print(f\"Total number of objects in '{COLLECTION_NAME}': {total_objects}\")\n\nexcept WeaviateClosedError as e:\n    print(f\"Error: The Weaviate client connection was already closed. {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\n\nfinally:\n    # 7. Close the client connection\n    if client:\n        print(\"Closing Weaviate client connection...\")\n        client.close()\n        print(\"Client connection closed.\")\n    else:\n        print(\"Client was not initialized, no connection to close.\")\n\n```",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 3, in <module>\n    from weaviate.exceptions import WeaviateClosedError\nImportError: cannot import name 'WeaviateClosedError' from 'weaviate.exceptions' (/usr/local/lib/python3.9/site-packages/weaviate/exceptions.py)\n",
      "exit_code": 1
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:06:02.110399",
      "duration": 16.958043098449707,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\nimport os\n\n# --- Configuration ---\n# Connect to Weaviate Cloud using environment variables\n# Ensure WCD_TEST_URL and WCD_TEST_KEY are set in your environment\n# Example:\n# export WCD_TEST_URL=\"https://YOUR_CLUSTER_URL.weaviate.cloud\"\n# export WCD_TEST_KEY=\"YOUR_API_KEY\"\n\ntry:\n    WEAVIATE_URL = os.environ[\"WCD_TEST_URL\"]\n    WEAVIATE_API_KEY = os.environ[\"WCD_TEST_KEY\"]\nexcept KeyError:\n    print(\"Error: WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n    print(\"Please set these variables before running the script.\")\n    print(\"Example: export WCD_TEST_URL='YOUR_CLUSTER_URL' && export WCD_TEST_KEY='YOUR_API_KEY'\")\n    exit(1)\n\nCOLLECTION_NAME = \"DemoProducts\"\nNUM_OBJECTS_TO_IMPORT = 50\n\n# --- Weaviate Client Connection ---\n# Using a context manager ensures the client connection is automatically closed\n# when exiting the 'with' block.\nwith weaviate.connect_to_weaviate_cloud(\n    cluster_url=WEAVIATE_URL,\n    auth_credentials=Auth.api_key(WEAVIATE_API_KEY)\n) as client:\n    print(f\"Connected to Weaviate Cloud at: {WEAVIATE_URL}\")\n\n    # --- Collection Management: Create or Recreate Collection ---\n    # Check if the collection already exists and delete it to ensure a clean slate\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it...\")\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n\n    print(f\"Creating collection '{COLLECTION_NAME}'...\")\n    client.collections.create(\n        name=COLLECTION_NAME,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ],\n        # It's good practice to configure a vectorizer for text properties.\n        # text2vec-weaviate is a convenient choice for Weaviate Cloud as it's often\n        # built-in and doesn't require additional API keys.\n        vector_config=Configure.Vectors.text2vec_weaviate()\n    )\n    print(f\"Collection '{COLLECTION_NAME}' created successfully.\")\n\n    # Get a reference to the collection for data operations\n    demo_products_collection = client.collections.get(COLLECTION_NAME)\n\n    # --- Data Operations: Batch Import Objects ---\n    print(f\"Starting batch import of {NUM_OBJECTS_TO_IMPORT} objects into '{COLLECTION_NAME}'...\")\n\n    # Using 'fixed_size' batching for efficient data import.\n    # The 'batch_size' determines how many objects are sent in one request.\n    with demo_products_collection.batch.fixed_size(batch_size=20) as batch:\n        for i in range(1, NUM_OBJECTS_TO_IMPORT + 1):\n            properties = {\n                \"name\": f\"Product {i}\",\n                \"description\": f\"This is the description for Product {i}. It details its features and benefits.\"\n            }\n            batch.add_object(properties=properties)\n\n    print(\"Batch import process finished.\")\n\n    # Check for any errors during the batch import\n    if demo_products_collection.batch.failed_objects:\n        print(f\"WARNING: {len(demo_products_collection.batch.failed_objects)} objects failed to import.\")\n        for error in demo_products_collection.batch.failed_objects:\n            print(f\"- {error.message} (Object properties: {error.object_.properties})\")\n    else:\n        print(\"All objects successfully imported in the batch.\")\n\n    # --- Query: Print Number of Objects ---\n    print(f\"Retrieving the number of objects in '{COLLECTION_NAME}'...\")\n    try:\n        # Use the aggregate API to get collection-level statistics, including total count.\n        # `total_count=True` specifically requests the object count.\n        results = demo_products_collection.aggregate.over_all(total_count=True)\n        object_count = results.total_count\n        print(f\"\\nTotal number of objects in '{COLLECTION_NAME}' collection: {object_count}\")\n    except Exception as e:\n        print(f\"An error occurred while trying to get the object count: {e}\")\n\nprint(\"Client connection closed automatically.\")\n```",
      "stdout": "Connected to Weaviate Cloud at: yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\nCollection 'DemoProducts' already exists. Deleting it...\nCollection 'DemoProducts' deleted.\nCreating collection 'DemoProducts'...\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 51, in <module>\n    vector_config=Configure.Vectors.text2vec_weaviate()\nAttributeError: type object 'Configure' has no attribute 'Vectors'\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T21:06:14.081071",
      "duration": 11.45724630355835,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "To query the 'WineReview' collection in Weaviate for wines that best match \"dessert wine\" and retrieve the top 2 results, you'll need to use the `weaviate-client` library. The code will connect to your Weaviate Cloud instance using environment variables, set the OpenAI API key for the vectorizer, and then perform a `near_text` query.\n\n```python\nimport weaviate\nimport os\n\n# 1. Load environment variables for Weaviate Cloud and OpenAI API Key\nWEAVIATE_URL = os.environ.get(\"WCD_TEST_URL\")\nWEAVIATE_API_KEY = os.environ.get(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\n\n# Check if all necessary environment variables are set\nif not all([WEAVIATE_URL, WEAVIATE_API_KEY, OPENAI_API_KEY]):\n    print(\"Error: Missing one or more required environment variables.\")\n    print(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY.\")\n    print(\"\\nExample (Bash/Zsh):\")\n    print(\"export WCD_TEST_URL='YOUR_WEAVIATE_CLUSTER_URL'\")\n    print(\"export WCD_TEST_KEY='YOUR_WEAVIATE_API_KEY'\")\n    print(\"export OPENAI_API_KEY='YOUR_OPENAI_API_KEY'\")\n    exit(1)\n\nclient = None\ntry:\n    # 2. Connect to Weaviate Cloud\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_wcs(\n        cluster_url=WEAVIATE_URL,\n        api_key=WEAVIATE_API_KEY,\n        # Pass OpenAI API key in headers as required by text2vec-openai vectorizer\n        headers={\"X-OpenAI-Api-Key\": OPENAI_API_KEY}\n    )\n    print(\"Successfully connected to Weaviate.\")\n\n    # 3. Define the collection and query parameters\n    collection_name = \"WineReview\"\n    query_text = \"dessert wine\"\n    limit_results = 2\n    # Properties to retrieve from the matching objects\n    properties_to_return = [\"title\", \"country\", \"price\", \"points\"]\n\n    # 4. Get the collection object\n    print(f\"\\nAccessing collection: '{collection_name}'...\")\n    wine_review_collection = client.collections.get(collection_name)\n\n    # 5. Perform the near_text query\n    print(f\"Searching for wines best matching '{query_text}' (limit: {limit_results})...\")\n    response = wine_review_collection.query.near_text(\n        query=query_text,\n        limit=limit_results,\n        return_properties=properties_to_return\n    )\n\n    # 6. Process and print the results\n    if response.objects:\n        print(f\"\\nFound {len(response.objects)} matching wines:\")\n        for i, obj in enumerate(response.objects):\n            print(f\"\\n--- Result {i+1} ---\")\n            print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n            print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n            # Handle cases where 'price' might be None or missing\n            price = obj.properties.get('price')\n            print(f\"Price: ${price:.2f}\" if isinstance(price, (int, float)) else \"Price: N/A\")\n            print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n    else:\n        print(\"\\nNo matching wines found for the query.\")\n\nexcept weaviate.exceptions.WeaviateConnectionError as e:\n    print(f\"Error connecting to Weaviate: {e}\")\nexcept weaviate.exceptions.WeaviateGRPCError as e:\n    print(f\"Weaviate GRPC error during query: {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # 7. Close the Weaviate connection\n    if client:\n        print(\"\\nClosing Weaviate connection...\")\n        client.close()\n        print(\"Connection closed.\")\n\n```",
      "stdout": "Connecting to Weaviate Cloud...\n",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 23, in <module>\n    client = weaviate.connect_to_wcs(\nTypeError: connect_to_wcs() got an unexpected keyword argument 'api_key'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/code/code.py\", line 66, in <module>\n    except weaviate.exceptions.WeaviateGRPCError as e:\nAttributeError: module 'weaviate.exceptions' has no attribute 'WeaviateGRPCError'\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:06:27.468383",
      "duration": 12.885395288467407,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# 1. Get Weaviate Cloud and OpenAI API keys from environment variables\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\n\n# Ensure all necessary environment variables are set\nif not WCD_TEST_URL:\n    raise ValueError(\"WCD_TEST_URL environment variable not set.\")\nif not WCD_TEST_KEY:\n    raise ValueError(\"WCD_TEST_KEY environment variable not set.\")\nif not OPENAI_API_KEY:\n    raise ValueError(\"OPENAI_API_KEY environment variable not set. Please set it to your OpenAI API key.\")\n\nclient = None # Initialize client to None for the finally block\n\ntry:\n    # 2. Connect to Weaviate Cloud\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY),\n        headers={\n            \"X-OpenAI-API-Key\": OPENAI_API_KEY # Pass OpenAI API key for text2vec-openai vectorizer\n        },\n    )\n    print(\"Successfully connected to Weaviate.\")\n\n    # 3. Get the 'WineReview' collection\n    print(\"Accessing 'WineReview' collection...\")\n    wine_collection = client.collections.get(\"WineReview\")\n    print(\"Collection 'WineReview' accessed.\")\n\n    # 4. Define the query parameters\n    query_text = \"dessert wine\"\n    max_results = 2\n    # Specify which properties to return for each object\n    properties_to_return = [\"title\", \"country\", \"price\", \"points\"]\n\n    print(f\"\\nQuerying the 'WineReview' collection for wines matching '{query_text}'...\")\n    print(f\"Limiting results to {max_results} and returning properties: {', '.join(properties_to_return)}.\")\n\n    # 5. Perform the near_text query\n    response = wine_collection.query.near_text(\n        query=query_text,\n        limit=max_results,\n        return_properties=properties_to_return # Return only specified properties\n    )\n\n    # 6. Print the results\n    if response.objects:\n        print(\"\\n--- Matching Wines ---\")\n        for i, obj in enumerate(response.objects):\n            props = obj.properties # obj.properties will contain only the returned properties\n            print(f\"\\nResult {i+1}:\")\n            print(f\"  Title: {props.get('title', 'N/A')}\")\n            print(f\"  Country: {props.get('country', 'N/A')}\")\n            \n            # Format price if it's a number, otherwise print as is\n            price_val = props.get('price')\n            if isinstance(price_val, (int, float)):\n                print(f\"  Price: ${price_val:.2f}\")\n            else:\n                print(f\"  Price: {price_val if price_val is not None else 'N/A'}\")\n            \n            print(f\"  Points: {props.get('points', 'N/A')}\")\n            print(\"-\" * 30)\n    else:\n        print(\"\\nNo matching wines found for your query.\")\n\nexcept Exception as e:\n    print(f\"\\nAn error occurred: {e}\")\n\nfinally:\n    # 7. Close the Weaviate client connection\n    if client:\n        client.close()\n        print(\"\\nWeaviate client connection closed.\")\n\n```",
      "stdout": "Connecting to Weaviate Cloud...\nSuccessfully connected to Weaviate.\nAccessing 'WineReview' collection...\nCollection 'WineReview' accessed.\n\nQuerying the 'WineReview' collection for wines matching 'dessert wine'...\nLimiting results to 2 and returning properties: title, country, price, points.\n\n--- Matching Wines ---\n\nResult 1:\n  Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price: $24.00\n  Points: 88\n------------------------------\n\nResult 2:\n  Title: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price: $40.00\n  Points: 88\n------------------------------\n\nWeaviate client connection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:06:34.093673",
      "duration": 6.2065110206604,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType # Not strictly needed for query, but good for context\n\n# 1. Connect to Weaviate Cloud\n# The API key for Weaviate Cloud is WCD_TEST_KEY\n# The URL for Weaviate Cloud is WCD_TEST_URL\n# The OpenAI API key for text2vec-openai is OPENAI_API_KEY\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\n            \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n        }\n    )\n\n    # 2. Get the 'WineReview' collection\n    wine_review_collection = client.collections.get(\"WineReview\")\n\n    # 3. Query the collection for wines matching \"dessert wine\"\n    #    - Use near_text for semantic search.\n    #    - Limit the results to 2.\n    #    - Return specific properties: title, country, price, points.\n    print(\"Searching for wines that best match 'dessert wine'...\")\n    response = wine_review_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # 4. Print the details of each matching wine\n    if response.objects:\n        print(f\"\\nFound {len(response.objects)} matching wines:\")\n        for i, wine in enumerate(response.objects):\n            print(f\"\\n--- Wine {i+1} ---\")\n            print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n            print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n            print(f\"Price: ${wine.properties.get('price', 'N/A')}\")\n            print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n    else:\n        print(\"\\nNo matching wines found.\")\n\nexcept KeyError as e:\n    print(f\"Error: Environment variable not set. Please ensure {e} is set.\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    # Ensure the client connection is closed\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"\\nWeaviate client connection closed.\")\n\n```",
      "stdout": "Searching for wines that best match 'dessert wine'...\n\nFound 2 matching wines:\n\n--- Wine 1 ---\nTitle: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: $24.0\nPoints: 88\n\n--- Wine 2 ---\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: $40.0\nPoints: 88\n\nWeaviate client connection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T21:06:51.527235",
      "duration": 17.036185026168823,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "To query the 'WineReview' collection in Weaviate Cloud using the latest client syntax, perform a hybrid search, apply multiple filters, and return specific properties, you can use the following Python code:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import Filter\nfrom weaviate.auth import AuthApiKey\n\n# Load environment variables\n# Ensure these are set in your environment before running the script\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Check if environment variables are set\nif not all([WCD_TEST_URL, WCD_TEST_KEY, OPENAI_API_KEY]):\n    raise ValueError(\n        \"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY environment variables.\"\n        \"Example: export WCD_TEST_URL='YOUR_WEAVIATE_CLUSTER_URL'\"\n        \"         export WCD_TEST_KEY='YOUR_WEAVIATE_API_KEY'\"\n        \"         export OPENAI_API_KEY='YOUR_OPENAI_API_KEY'\"\n    )\n\nclient = None  # Initialize client to None for finally block\n\ntry:\n    # Connect to Weaviate Cloud\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_wcs(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=AuthApiKey(WCD_TEST_KEY),\n        # Pass OpenAI API key as a header for the text2vec-openai vectorizer\n        headers={\n            \"X-OpenAI-Api-Key\": OPENAI_API_KEY\n        }\n    )\n    print(\"Successfully connected to Weaviate.\")\n\n    # Get the WineReview collection object\n    wine_review_collection = client.collections.get(\"WineReview\")\n\n    # Define the query parameters\n    query_text = \"pair with steak\"\n    limit_results = 5\n    properties_to_return = [\"title\", \"country\", \"price\", \"points\"]\n\n    # Define the filters\n    # 1. Price less than 50\n    filter_price = Filter.by_property(\"price\").less_than(50)\n\n    # 2. Points greater than 90\n    filter_points = Filter.by_property(\"points\").greater_than(90)\n\n    # 3. Review body contains at least one of the specified substrings\n    # The 'contains_any' method checks for any of the given strings as substrings.\n    filter_review_body = Filter.by_property(\"review_body\").contains_any(\n        [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n    )\n\n    # Combine all filters with AND logic using the & operator\n    combined_filter = filter_price & filter_points & filter_review_body\n\n    # Perform the hybrid search\n    print(f\"\\nSearching for wines matching '{query_text}' with hybrid search (alpha=0.5)...\")\n    print(f\"Applying filters: Price < 50, Points > 90, Review contains 'spice', 'fruit', 'berry', 'cherry', or 'honey'.\")\n    print(f\"Maximum {limit_results} results.\")\n\n    response = wine_review_collection.query.hybrid(\n        query=query_text,\n        alpha=0.5,  # 0.5 for balanced hybrid search (keyword + vector)\n        filters=combined_filter,\n        limit=limit_results,\n        return_properties=properties_to_return\n    )\n\n    # Process and print the results\n    if response.objects:\n        print(f\"\\nFound {len(response.objects)} matching wines:\")\n        for i, wine in enumerate(response.objects):\n            print(f\"\\n--- Result {i+1} ---\")\n            print(f\"Title: {wine.properties['title']}\")\n            print(f\"Country: {wine.properties['country']}\")\n            print(f\"Price: ${wine.properties['price']:.2f}\")\n            print(f\"Points: {wine.properties['points']}\")\n    else:\n        print(\"\\nNo wines found matching the specified criteria.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    # Ensure the client connection is closed\n    if client:\n        client.close()\n        print(\"\\nWeaviate connection closed.\")\n```",
      "stdout": "Connecting to Weaviate Cloud...\nSuccessfully connected to Weaviate.\n\nSearching for wines matching 'pair with steak' with hybrid search (alpha=0.5)...\nApplying filters: Price < 50, Points > 90, Review contains 'spice', 'fruit', 'berry', 'cherry', or 'honey'.\nMaximum 5 results.\n\nFound 5 matching wines:\n\n--- Result 1 ---\nTitle: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.00\nPoints: 92\n\n--- Result 2 ---\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.00\nPoints: 91\n\n--- Result 3 ---\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.00\nPoints: 91\n\n--- Result 4 ---\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.00\nPoints: 93\n\n--- Result 5 ---\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: $0.00\nPoints: 92\n\nWeaviate connection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T21:07:08.867349",
      "duration": 16.914157152175903,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "To query the 'WineReview' collection in Weaviate Cloud, find wines that best match \"pair with steak\" using hybrid search (alpha=0.5), and filter for specific price, points, and review body content, you can use the following Python code.\n\nThis script connects to your Weaviate Cloud instance using environment variables for the cluster URL and API keys, performs the search, and prints the requested details for up to 5 matching wines.\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\nimport os\n\n# --- 1. Get Weaviate and OpenAI API keys from environment variables ---\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\n\n# Ensure all required environment variables are set\nif not all([WCD_TEST_URL, WCD_TEST_KEY, OPENAI_API_KEY]):\n    print(\"Error: Please set the following environment variables:\")\n    print(\"  - WCD_TEST_URL (Weaviate Cloud URL)\")\n    print(\"  - WCD_TEST_KEY (Weaviate Cloud API Key)\")\n    print(\"  - OPENAI_API_KEY (OpenAI API Key for text2vec-openai vectorizer)\")\n    exit(1)\n\nclient = None  # Initialize client to None for safe cleanup in finally block\n\ntry:\n    # --- 2. Connect to Weaviate Cloud ---\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY),\n        headers={\n            \"X-OpenAI-API-Key\": OPENAI_API_KEY\n        },\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\n\n    # --- 3. Get the 'WineReview' collection ---\n    # Ensure the collection name matches your Weaviate schema\n    collection = client.collections.get(\"WineReview\")\n    print(f\"Targeting collection: '{collection.name}'\")\n\n    # --- 4. Perform the hybrid search query ---\n    print(\"\\nSearching for wines that 'pair with steak' under specific criteria...\")\n    response = collection.query.hybrid(\n        query=\"pair with steak\",\n        limit=5,  # Limit results to a maximum of 5\n        alpha=0.5, # Hybrid search alpha value\n        filters=(\n            # Price less than 50\n            Filter.by_property(\"price\").less_than(50) &\n            # Points greater than 90\n            Filter.by_property(\"points\").greater_than(90) &\n            # Review body contains any of the specified keywords\n            Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n        ),\n        # Explicitly request only the properties needed for output\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # --- 5. Print the results ---\n    if response.objects:\n        print(\"\\n--- Matching Wines (Top 5 Results) ---\")\n        for i, obj in enumerate(response.objects):\n            props = obj.properties\n            print(f\"\\nResult {i+1}:\")\n            print(f\"  Title: {props.get('title', 'N/A')}\")\n            print(f\"  Country: {props.get('country', 'N/A')}\")\n            print(f\"  Price: ${props.get('price', 'N/A')}\")\n            print(f\"  Points: {props.get('points', 'N/A')}\")\n    else:\n        print(\"\\nNo wines found matching all specified criteria.\")\n\nexcept weaviate.exceptions.WeaviateConnectionError as e:\n    print(f\"Error: Could not connect to Weaviate. Check your URL and network. Details: {e}\")\nexcept weaviate.exceptions.WeaviateAuthError as e:\n    print(f\"Error: Authentication failed. Check your Weaviate API key or OpenAI API key. Details: {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # --- 6. Close the Weaviate client connection ---\n    if client and client.is_connected():\n        client.close()\n        print(\"\\nWeaviate client connection closed.\")\n\n```",
      "stdout": "Connecting to Weaviate Cloud...\nSuccessfully connected to Weaviate Cloud.\nTargeting collection: 'WineReview'\n\nSearching for wines that 'pair with steak' under specific criteria...\n\n--- Matching Wines (Top 5 Results) ---\n\nResult 1:\n  Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price: $40.0\n  Points: 92\n\nResult 2:\n  Title: Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price: $49.0\n  Points: 91\n\nResult 3:\n  Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price: $27.0\n  Points: 91\n\nResult 4:\n  Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price: $25.0\n  Points: 93\n\nResult 5:\n  Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price: $0.0\n  Points: 92\n\nWeaviate client connection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T21:07:19.112601",
      "duration": 9.824696063995361,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\n\n# Ensure environment variables are set\n# Example:\n# os.environ['WCD_TEST_URL'] = 'YOUR_WEAVIATE_CLUSTER_URL'\n# os.environ['WCD_TEST_KEY'] = 'YOUR_WEAVIATE_API_KEY'\n# os.environ['OPENAI_API_KEY'] = 'YOUR_OPENAI_API_KEY'\n\n# 1. Connect to Weaviate Cloud\nclient = None\ntry:\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\n            \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n        }\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\n\n    # 2. Get the 'WineReview' collection\n    wine_collection = client.collections.get(\"WineReview\")\n    print(\"Accessing 'WineReview' collection.\")\n\n    # Define the search query\n    query_text = \"pair with steak\"\n    limit_results = 5\n    hybrid_alpha = 0.5 # Balance between keyword and vector search\n\n    # 3. Define the filters\n    # Filter for price less than 50 and points greater than 90\n    price_and_points_filter = (\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90)\n    )\n\n    # Filter for review_body containing specific substrings\n    review_body_keywords_filter = Filter.any_of(\n        filters=[\n            Filter.by_property(\"review_body\").like(\"*spice*\"),\n            Filter.by_property(\"review_body\").like(\"*fruit*\"),\n            Filter.by_property(\"review_body\").like(\"*berry*\"),\n            Filter.by_property(\"review_body\").like(\"*cherry*\"),\n            Filter.by_property(\"review_body\").like(\"*honey*\")\n        ]\n    )\n\n    # Combine all filters using logical AND\n    combined_filters = price_and_points_filter & review_body_keywords_filter\n\n    print(f\"\\nSearching for wines matching '{query_text}' with the following criteria:\")\n    print(f\"- Price < 50, Points > 90\")\n    print(f\"- Review body contains 'spice', 'fruit', 'berry', 'cherry', or 'honey'\")\n    print(f\"- Hybrid search (alpha={hybrid_alpha}), max {limit_results} results\")\n\n    # 4. Perform the hybrid search with filters and desired return properties\n    response = wine_collection.query.hybrid(\n        query=query_text,\n        alpha=hybrid_alpha,\n        limit=limit_results,\n        filters=combined_filters,\n        return_properties=[\"title\", \"country\", \"price\", \"points\", \"review_body\"] # Include review_body to verify filter\n    )\n\n    # 5. Print the results\n    if response.objects:\n        print(\"\\n--- Matching Wines ---\")\n        for i, obj in enumerate(response.objects):\n            print(f\"\\nResult {i+1}:\")\n            print(f\"  Title: {obj.properties.get('title', 'N/A')}\")\n            print(f\"  Country: {obj.properties.get('country', 'N/A')}\")\n            print(f\"  Price: {obj.properties.get('price', 'N/A')}\")\n            print(f\"  Points: {obj.properties.get('points', 'N/A')}\")\n            # Optional: Print the relevant part of review_body for verification\n            # print(f\"  Review Body Snippet: {obj.properties.get('review_body', 'N/A')[:150]}...\")\n    else:\n        print(\"\\nNo wines found matching the specified criteria.\")\n\nexcept KeyError as e:\n    print(f\"Error: Environment variable {e} not set. Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY.\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    if client:\n        client.close()\n        print(\"\\nWeaviate client connection closed.\")\n\n```",
      "stdout": "Connecting to Weaviate Cloud...\nSuccessfully connected to Weaviate Cloud.\nAccessing 'WineReview' collection.\n\nSearching for wines matching 'pair with steak' with the following criteria:\n- Price < 50, Points > 90\n- Review body contains 'spice', 'fruit', 'berry', 'cherry', or 'honey'\n- Hybrid search (alpha=0.5), max 5 results\n\n--- Matching Wines ---\n\nResult 1:\n  Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price: 40.0\n  Points: 92\n\nResult 2:\n  Title: Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price: 49.0\n  Points: 91\n\nResult 3:\n  Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price: 27.0\n  Points: 91\n\nResult 4:\n  Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price: 25.0\n  Points: 93\n\nResult 5:\n  Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price: 0.0\n  Points: 92\n\nWeaviate client connection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    }
  },
  "gemini/gemini-2.5-flash-lite": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T21:07:21.048822",
      "duration": 1.8985621929168701,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get Weaviate Cloud credentials from environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not weaviate_url or not weaviate_api_key:\n    raise EnvironmentError(\n        \"Please set the WCD_TEST_URL and WCD_TEST_KEY environment variables.\"\n    )\n\n# Initialize the Weaviate client\nclient = weaviate.Client(\n    url=weaviate_url,\n    auth_client_secret=weaviate.AuthApiKey(api_key=weaviate_api_key),\n)\n\n# Check if the server is ready\ntry:\n    if client.is_ready():\n        print(\"Weaviate server is ready to accept requests.\")\n    else:\n        print(\"Weaviate server is not ready.\")\nexcept Exception as e:\n    print(f\"An error occurred while checking server readiness: {e}\")\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:15: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 15, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T21:07:23.281770",
      "duration": 2.195481777191162,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\n\n# Get the Weaviate Cloud URL and API key from environment variables\ncluster_url = os.environ.get(\"WCD_TEST_URL\")\napi_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Check if the environment variables are set\nif not cluster_url:\n    raise ValueError(\"WCD_TEST_URL environment variable not set.\")\nif not api_key:\n    raise ValueError(\"WCD_TEST_KEY environment variable not set.\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready()\n\n# Close the client connection\nclient.close()\n\nprint(\"Successfully connected to Weaviate Cloud and confirmed server readiness.\")\n```",
      "stdout": "Successfully connected to Weaviate Cloud and confirmed server readiness.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T21:07:29.708014",
      "duration": 6.385200023651123,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get Weaviate Cloud connection details from environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_key = os.environ.get(\"WCD_TEST_KEY\")\n\nif not weaviate_url or not weaviate_key:\n    raise EnvironmentError(\n        \"Please set the WCD_TEST_URL and WCD_TEST_KEY environment variables.\"\n    )\n\n# Initialize the Weaviate client\nclient = weaviate.Client(\n    url=weaviate_url,\n    auth_client_secret=weaviate.AuthApiKey(weaviate_key),\n)\n\ncollection_name = \"DemoProducts\"\n\n# 1. Check if the collection exists and delete it if it does\nif client.collections.exists(collection_name):\n    print(f\"Collection '{collection_name}' already exists. Deleting it.\")\n    client.collections.delete(collection_name)\n    print(f\"Collection '{collection_name}' deleted.\")\nelse:\n    print(f\"Collection '{collection_name}' does not exist.\")\n\n# 2. Define the schema for the \"DemoProducts\" collection\ncollection_schema = {\n    \"name\": collection_name,\n    \"properties\": [\n        {\"name\": \"name\", \"dataType\": [\"text\"]},\n        {\"name\": \"description\", \"dataType\": [\"text\"]},\n        {\"name\": \"price\", \"dataType\": [\"number\"]},\n        {\"name\": \"in_stock\", \"dataType\": [\"boolean\"]},\n    ],\n    \"vectorizer\": \"text2vec-contextionary\",  # Or another preferred vectorizer\n    \"moduleConfig\": {\n        \"text2vec-contextionary\": {\n            \"vectorizer\": \"text2vec-contextionary\",\n            \"vectorIndexType\": \"hnsw\",\n        }\n    },\n}\n\n# 3. Create the collection\ntry:\n    client.collections.create(collection_schema)\n    print(f\"Collection '{collection_name}' created successfully.\")\nexcept Exception as e:\n    print(f\"Error creating collection: {e}\")\n\n# Optional: Verify the collection creation\nif client.collections.exists(collection_name):\n    print(f\"Verification: Collection '{collection_name}' exists.\")\nelse:\n    print(f\"Verification: Collection '{collection_name}' does not exist.\")\n\n# Optional: Print the schema of the created collection\ntry:\n    schema = client.collections.get(collection_name)\n    print(f\"\\nSchema of '{collection_name}':\")\n    print(schema)\nexcept Exception as e:\n    print(f\"Error getting schema for '{collection_name}': {e}\")\n```\n\n**Explanation:**\n\n1.  **Import necessary libraries:**\n    *   `os`: To access environment variables.\n    *   `weaviate`: The Weaviate client library.\n\n2.  **Get Connection Details:**\n    *   It retrieves `WCD_TEST_URL` and `WCD_TEST_KEY` from your environment variables.\n    *   It includes a check to ensure these variables are set, raising an `EnvironmentError` if they are not.\n\n3.  **Initialize Weaviate Client:**\n    *   `weaviate.Client()` is used to create a client instance.\n    *   `url`: Set to your Weaviate Cloud URL.\n    *   `auth_client_secret`: Uses `weaviate.AuthApiKey()` to provide your API key for authentication.\n\n4.  **Define Collection Name:**\n    *   `collection_name = \"DemoProducts\"` sets the name of the collection you want to create.\n\n5.  **Check and Delete Existing Collection:**\n    *   `client.collections.exists(collection_name)` checks if a collection with the specified name already exists.\n    *   If it exists, `client.collections.delete(collection_name)` is called to remove it. This ensures a clean slate for creating the new collection.\n\n6.  **Define Collection Schema:**\n    *   `collection_schema` is a Python dictionary representing the desired structure of your collection.\n    *   `name`: The name of the collection.\n    *   `properties`: A list of dictionaries, where each dictionary defines a property:\n        *   `name`: The name of the property (e.g., \"name\", \"description\").\n        *   `dataType`: A list containing the data type of the property (e.g., `[\"text\"]`, `[\"number\"]`, `[\"boolean\"]`).\n    *   `vectorizer`: Specifies the vectorization module to use. `text2vec-contextionary` is a common choice for text data. You can replace this with other available vectorizers if needed.\n    *   `moduleConfig`: Configuration specific to the chosen vectorizer.\n\n7.  **Create the Collection:**\n    *   `client.collections.create(collection_schema)` sends a request to Weaviate to create the collection with the defined schema.\n    *   A `try-except` block is used to catch any potential errors during the creation process.\n\n8.  **Verification (Optional):**\n    *   The code includes optional steps to verify if the collection was created successfully by checking its existence again and printing its schema.\n\n**Before running this code:**\n\n1.  **Install the Weaviate client:**\n    ```bash\n    pip install weaviate-client\n    ```\n2.  **Set Environment Variables:** Make sure you have set your Weaviate Cloud URL and API key as environment variables:\n    *   **Linux/macOS:**\n        ```bash\n        export WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n        export WCD_TEST_KEY=\"YOUR_WEAVIATE_CLOUD_API_KEY\"\n        ```\n    *   **Windows (Command Prompt):**\n        ```cmd\n        set WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n        set WCD_TEST_KEY=\"YOUR_WEAVIATE_CLOUD_API_KEY\"\n        ```\n    *   **Windows (PowerShell):**\n        ```powershell\n        $env:WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n        $env:WCD_TEST_KEY=\"YOUR_WEAVIATE_CLOUD_API_KEY\"\n        ```\n    Replace `\"YOUR_WEAVIATE_CLOUD_URL\"` and `\"YOUR_WEAVIATE_CLOUD_API_KEY\"` with your actual Weaviate Cloud credentials.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:14: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 14, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T21:07:32.651045",
      "duration": 2.906733751296997,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Retrieve Weaviate Cloud URL and API key from environment variables\ncluster_url = os.environ.get(\"WCD_TEST_URL\")\napi_key = os.environ.get(\"WCD_TEST_KEY\")\n\nif not cluster_url or not api_key:\n    raise ValueError(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Define the collection name\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    print(f\"Deleting existing collection: {collection_name}\")\n    client.collections.delete(collection_name)\n    print(f\"Collection '{collection_name}' deleted.\")\n\n# Create the collection with specified properties\nprint(f\"Creating collection: {collection_name}\")\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Collection '{products_collection.name}' created successfully.\")\n\n# Close connection\nclient.close()\nprint(\"Connection to Weaviate closed.\")\n```",
      "stdout": "Creating collection: DemoProducts\nCollection 'DemoProducts' created successfully.\nConnection to Weaviate closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T21:07:36.660869",
      "duration": 3.973729133605957,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.classes.init import Auth\nimport os\n\n# Retrieve Weaviate Cloud URL and API key from environment variables\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\n\n# Define the collection name\ncollection_name = \"DemoProducts\"\n\n# 1. Client Instantiation\n# Connect to Weaviate Cloud using environment variables\nif WCD_TEST_URL and WCD_TEST_KEY:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    )\nelse:\n    raise ValueError(\"WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n\n# Use a try-finally block to ensure the client is closed\ntry:\n    # 2. Collection Management\n    # Check if the collection already exists and delete it if it does\n    if client.collections.exists(collection_name):\n        print(f\"Collection '{collection_name}' already exists. Deleting it.\")\n        client.collections.delete(collection_name)\n        print(f\"Collection '{collection_name}' deleted.\")\n\n    # Create the \"DemoProducts\" collection with specified properties\n    print(f\"Creating collection '{collection_name}'...\")\n    client.collections.create(\n        collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n    print(f\"Collection '{collection_name}' created successfully.\")\n\n    # Optional: Verify the collection was created\n    if client.collections.exists(collection_name):\n        print(f\"Collection '{collection_name}' now exists.\")\n        collection_config = client.collections.get(collection_name).config\n        print(\"Collection configuration:\")\n        print(f\"  Name: {collection_config.name}\")\n        print(\"  Properties:\")\n        for prop in collection_config.properties:\n            print(f\"    - Name: {prop.name}, Data Type: {prop.data_type}\")\n    else:\n        print(f\"Failed to verify creation of collection '{collection_name}'.\")\n\nfinally:\n    # Close the client connection\n    client.close()\n    print(\"Weaviate client connection closed.\")\n\n```",
      "stdout": "Collection 'DemoProducts' already exists. Deleting it.\nCollection 'DemoProducts' deleted.\nCreating collection 'DemoProducts'...\nCollection 'DemoProducts' created successfully.\nCollection 'DemoProducts' now exists.\nCollection configuration:\nWeaviate client connection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\nTraceback (most recent call last):\n  File \"/code/code.py\", line 50, in <module>\n    print(f\"  Name: {collection_config.name}\")\nAttributeError: '_ConfigCollection' object has no attribute 'name'\n",
      "exit_code": 1
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:07:41.103266",
      "duration": 3.726564884185791,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get Weaviate Cloud credentials from environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\n\nif not weaviate_url or not weaviate_api_key:\n    raise ValueError(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n\n# Initialize the Weaviate client\nclient = weaviate.Client(\n    url=weaviate_url,\n    auth_client_secret=weaviate.AuthApiKey(api_key=weaviate_api_key),\n)\n\n# Define the collection schema\nclass_name = \"DemoProducts\"\nschema = {\n    \"classes\": [\n        {\n            \"class\": class_name,\n            \"properties\": [\n                {\n                    \"name\": \"name\",\n                    \"dataType\": [\"text\"],\n                },\n                {\n                    \"name\": \"description\",\n                    \"dataType\": [\"text\"],\n                },\n            ],\n        }\n    ]\n}\n\n# Create the collection if it doesn't exist\nif not client.schema.exists(class_name):\n    client.schema.create(schema)\n    print(f\"Collection '{class_name}' created.\")\nelse:\n    print(f\"Collection '{class_name}' already exists.\")\n\n# Generate and batch import 50 arbitrary objects\nobjects_to_import = []\nfor i in range(50):\n    objects_to_import.append({\n        \"name\": f\"Product {i+1}\",\n        \"description\": f\"This is the description for product {i+1}.\",\n    })\n\n# Use the batch client for efficient importing\nwith client.batch.configure(\n    batch_size=10,  # Adjust batch size as needed\n    # Other potential configurations:\n    # dynamic=True, # If properties can change\n    # update_frequency=10,\n    # alphanumeric_fallback=True,\n) as batch:\n    for obj in objects_to_import:\n        batch.add_object(obj, class_name=class_name)\n\nprint(f\"Batch imported {len(objects_to_import)} objects into '{class_name}'.\")\n\n# Print the number of objects in the collection\ntry:\n    total_objects = client.query.aggregate(class_name).with_total_count().do()\n    if total_objects and \"data\" in total_objects and \"Get\" in total_objects[\"data\"] and class_name in total_objects[\"data\"][\"Get\"] and \"totalNumberOfObjects\" in total_objects[\"data\"][\"Get\"][class_name]:\n        count = total_objects[\"data\"][\"Get\"][class_name][\"totalNumberOfObjects\"]\n        print(f\"Number of objects in '{class_name}': {count}\")\n    else:\n        print(f\"Could not retrieve the total number of objects in '{class_name}'. The result was: {total_objects}\")\nexcept Exception as e:\n    print(f\"An error occurred while fetching the object count: {e}\")\n\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:12: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 12, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T21:07:45.420167",
      "duration": 3.6328041553497314,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nimport os\n\n# Get Weaviate Cloud credentials from environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    raise EnvironmentError(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n\n# Connect to Weaviate Cloud\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=weaviate.Auth.api_key(WCD_TEST_KEY),\n    )\nexcept Exception as e:\n    print(f\"Error connecting to Weaviate Cloud: {e}\")\n    exit()\n\ncollection_name = \"DemoProducts\"\n\n# Check if the collection exists, create it if not\ntry:\n    if not client.collections.exists(collection_name):\n        client.collections.create(\n            collection_name,\n            properties=[\n                weaviate.Property(name=\"name\", data_type=weaviate.DataType.TEXT),\n                weaviate.Property(name=\"description\", data_type=weaviate.DataType.TEXT),\n            ],\n        )\n        print(f\"Collection '{collection_name}' created.\")\n    else:\n        print(f\"Collection '{collection_name}' already exists.\")\nexcept Exception as e:\n    print(f\"Error creating or checking collection: {e}\")\n    client.close()\n    exit()\n\n# Get the collection\ntry:\n    collection = client.collections.get(collection_name)\nexcept Exception as e:\n    print(f\"Error getting collection '{collection_name}': {e}\")\n    client.close()\n    exit()\n\n# Generate 50 arbitrary objects\ndata_rows = [\n    {\"name\": f\"Product {i+1}\", \"description\": f\"This is a description for Product {i+1}\"}\n    for i in range(50)\n]\n\n# Batch import objects\nprint(\"Starting batch import of 50 objects...\")\ntry:\n    with collection.batch.dynamic() as batch:\n        for data_row in data_rows:\n            batch.add_object(\n                properties=data_row,\n            )\n            # Optional: Add a check for errors to stop early if needed\n            # if batch.number_errors > 10:\n            #     print(\"Batch import stopped due to excessive errors.\")\n            #     break\n    print(\"Batch import completed.\")\n\n    failed_objects = collection.batch.failed_objects\n    if failed_objects:\n        print(f\"Number of failed imports: {len(failed_objects)}\")\n        # Print the first failed object if any\n        if failed_objects:\n            print(f\"First failed object: {failed_objects[0]}\")\nexcept Exception as e:\n    print(f\"An error occurred during batch import: {e}\")\n\n\n# Print the number of objects in the collection\ntry:\n    num_objects = len(collection)\n    print(f\"Number of objects in the '{collection_name}' collection: {num_objects}\")\nexcept Exception as e:\n    print(f\"Error getting the count of objects: {e}\")\n\n# Close the client connection\nclient.close()\nprint(\"Weaviate client connection closed.\")\n```",
      "stdout": "Error connecting to Weaviate Cloud: module weaviate has no attribute Auth\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:07:49.406675",
      "duration": 3.3070781230926514,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    )\nexcept KeyError as e:\n    print(f\"Error: Environment variable {e} not set.\")\n    print(\"Please set WCD_TEST_URL and WCD_TEST_KEY to connect to Weaviate Cloud.\")\n    exit()\n\ncollection_name = \"DemoProducts\"\n\n# Define the collection schema\nclient.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n    ]\n)\n\n# Get the collection object\ncollection = client.collections.get(collection_name)\n\n# Batch import 50 arbitrary objects\nbatch_size = 50\nobjects_to_import = []\nfor i in range(batch_size):\n    objects_to_import.append(\n        {\n            \"name\": f\"Product {i}\",\n            \"description\": f\"Description for product {i}\"\n        }\n    )\n\n# Use the batch.add_objects method for efficient batch import\n# The fixed_size batcher is generally recommended for predictable performance\nwith collection.batch.fixed_size(batch_size=batch_size) as batch:\n    for obj_data in objects_to_import:\n        batch.add_object(properties=obj_data)\n\n# Print the number of objects in the collection\ncount_response = client.query.aggregate(collection_name).with_fields(\"totalNumberOfObjects\").do()\ntotal_objects = count_response[\"data\"][\"Aggregate\"][collection_name][0][\"totalNumberOfObjects\"]\n\nprint(f\"Number of objects in the '{collection_name}' collection: {total_objects}\")\n\n# Close the client connection\nclient.close()\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\nTraceback (most recent call last):\n  File \"/code/code.py\", line 20, in <module>\n    client.collections.create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/sync.py\", line 107, in create\n    self.__loop.run_until_complete(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/event_loop.py\", line 42, in run_until_complete\n    return fut.result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 446, in result\n    return self.__get_result()\n  File \"/usr/local/lib/python3.9/concurrent/futures/_base.py\", line 391, in __get_result\n    raise self._exception\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/async_.py\", line 134, in create\n    name = await super()._create(config._to_dict())\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/base.py\", line 27, in _create\n    response = await self._connection.post(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 550, in post\n    return await self.__send(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 505, in __send\n    raise e\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 496, in __send\n    raise UnexpectedStatusCodeError(error_msg, response=res)\nweaviate.exceptions.UnexpectedStatusCodeError: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'class name DemoProducts already exists'}]}.\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:314: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n/usr/local/lib/python3.9/asyncio/selector_events.py:702: ResourceWarning: unclosed transport <_SelectorSocketTransport fd=6 read=idle write=<idle, bufsize=0>>\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T21:07:58.413141",
      "duration": 8.5503568649292,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\ndef query_wine_reviews():\n    \"\"\"\n    Queries the 'WineReview' collection in Weaviate for dessert wines\n    and prints the details of the best matching results.\n    \"\"\"\n\n    # Get Weaviate Cloud connection details from environment variables\n    weaviate_url = os.environ.get(\"WCD_TEST_URL\")\n    weaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\n    openai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n\n    if not all([weaviate_url, weaviate_api_key, openai_api_key]):\n        print(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY environment variables.\")\n        return\n\n    # Initialize Weaviate client\n    client = weaviate.Client(\n        url=weaviate_url,\n        auth_client_secret=weaviate.AuthApiKey(weaviate_api_key),\n        additional_headers={\n            \"X-OpenAI-Api-Key\": openai_api_key,\n        }\n    )\n\n    # Define the query and the collection name\n    query_text = \"dessert wine\"\n    collection_name = \"WineReview\"\n\n    try:\n        # Build the GraphQL query\n        response = (\n            client.query\n            .get(collection_name, [\"title\", \"country\", \"price\", \"points\"])\n            .with_near_text({\"concepts\": [query_text]})\n            .with_limit(2)\n            .do()\n        )\n\n        # Process and print the results\n        if \"data\" in response and \"Get\" in response[\"data\"] and collection_name in response[\"data\"][\"Get\"]:\n            wines = response[\"data\"][\"Get\"][collection_name]\n            if wines:\n                print(f\"Top {len(wines)} wines matching '{query_text}':\\n\")\n                for wine in wines:\n                    print(f\"Title: {wine.get('title', 'N/A')}\")\n                    print(f\"Country: {wine.get('country', 'N/A')}\")\n                    print(f\"Price: {wine.get('price', 'N/A')}\")\n                    print(f\"Points: {wine.get('points', 'N/A')}\")\n                    print(\"-\" * 20)\n            else:\n                print(f\"No wines found matching '{query_text}'.\")\n        else:\n            print(\"Error: Unexpected response format from Weaviate.\")\n            print(response)\n\n    except weaviate.exceptions.UnexpectedStatusCodeException as e:\n        print(f\"An error occurred: {e}\")\n        print(\"Please ensure the collection 'WineReview' exists and is configured with text2vec-openai.\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    query_wine_reviews()\n```\n\n**Explanation:**\n\n1.  **Import Libraries:**\n    *   `os`: Used to access environment variables.\n    *   `weaviate`: The Weaviate Python client library.\n\n2.  **`query_wine_reviews()` Function:**\n    *   **Get Environment Variables:** It retrieves the Weaviate Cloud URL (`WCD_TEST_URL`), Weaviate API Key (`WCD_TEST_KEY`), and OpenAI API Key (`OPENAI_API_KEY`) from the environment.\n    *   **Environment Variable Check:** It verifies if all necessary environment variables are set. If not, it prints an error message and exits.\n    *   **Initialize Weaviate Client:**\n        *   `weaviate.Client()` is used to establish a connection to your Weaviate Cloud instance.\n        *   `url=weaviate_url`: Specifies the URL of your Weaviate instance.\n        *   `auth_client_secret=weaviate.AuthApiKey(weaviate_api_key)`: Provides the API key for authentication.\n        *   `additional_headers={\"X-OpenAI-Api-Key\": openai_api_key}`: This is crucial for setting the OpenAI API key. The `text2vec-openai` module requires this header to communicate with the OpenAI API for generating embeddings.\n    *   **Define Query and Collection:**\n        *   `query_text = \"dessert wine\"`: The natural language query for wines.\n        *   `collection_name = \"WineReview\"`: The name of the Weaviate collection to query.\n    *   **Build and Execute GraphQL Query:**\n        *   `client.query.get(collection_name, [\"title\", \"country\", \"price\", \"points\"])`: This starts building a `GET` query for the `WineReview` collection and specifies the properties to retrieve (`title`, `country`, `price`, `points`).\n        *   `.with_near_text({\"concepts\": [query_text]})`: This is the core of the semantic search.\n            *   `with_near_text()` is used for vector-based similarity search.\n            *   `{\"concepts\": [query_text]}` tells Weaviate to use the `query_text` to find similar objects based on their vectors. Since the collection is configured with `text2vec-openai`, this will use OpenAI to generate an embedding for \"dessert wine\" and find wines with similar embeddings.\n        *   `.with_limit(2)`: This limits the number of returned results to a maximum of 2.\n        *   `.do()`: Executes the constructed query against the Weaviate instance.\n    *   **Process and Print Results:**\n        *   The code checks the structure of the `response` to ensure it's as expected.\n        *   It extracts the list of `wines` from the response.\n        *   If wines are found, it iterates through them and prints the `title`, `country`, `price`, and `points` of each wine. It uses `.get(key, 'N/A')` to safely access properties, providing 'N/A' if a property is missing.\n        *   If no wines are found, it prints a message indicating that.\n    *   **Error Handling:**\n        *   `weaviate.exceptions.UnexpectedStatusCodeException`: Catches errors related to the Weaviate API response, often indicating issues with the collection configuration or query.\n        *   `Exception`: Catches any other unexpected errors that might occur during the process.\n\n3.  **`if __name__ == \"__main__\":` Block:**\n    *   This ensures that the `query_wine_reviews()` function is called only when the script is executed directly (not when imported as a module).\n\n**Before Running:**\n\n1.  **Install Weaviate Client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set Environment Variables:**\n    You need to set the following environment variables in your terminal or system configuration before running the Python script:\n\n    *   **`WCD_TEST_URL`**: The URL of your Weaviate Cloud instance (e.g., `https://your-instance-name.weaviate.network`).\n    *   **`WCD_TEST_KEY`**: Your API key for your Weaviate Cloud instance.\n    *   **`OPENAI_API_KEY`**: Your OpenAI API key.\n\n    **Example (Linux/macOS):**\n    ```bash\n    export WCD_TEST_URL=\"https://your-instance-name.weaviate.network\"\n    export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n    export OPENAI_API_KEY=\"YOUR_OPENAI_API_KEY\"\n    ```\n\n    **Example (Windows):**\n    ```cmd\n    set WCD_TEST_URL=https://your-instance-name.weaviate.network\n    set WCD_TEST_KEY=YOUR_WEAVIATE_API_KEY\n    set OPENAI_API_KEY=YOUR_OPENAI_API_KEY\n    ```\n\n3.  **Ensure `WineReview` Collection Exists:**\n    Make sure you have a Weaviate collection named `WineReview` that is configured with the `text2vec-openai` vectorizer. If you haven't created it yet, you'll need to do so using the Weaviate schema API.\n\nThis code provides a clear and robust way to perform semantic search against your Weaviate data, leveraging the power of OpenAI embeddings for understanding the query's meaning.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:20: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 66, in <module>\n    query_wine_reviews()\n  File \"/code/code.py\", line 20, in query_wine_reviews\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:08:02.533507",
      "duration": 3.6997830867767334,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Retrieve Weaviate Cloud connection details from environment variables\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\n\n# Retrieve OpenAI API key from environment variable\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\n\n# Check if all required environment variables are set\nif not all([WCD_TEST_URL, WCD_TEST_KEY, OPENAI_API_KEY]):\n    raise ValueError(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY environment variables.\")\n\ntry:\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY),\n        headers={\n            \"X-OpenAI-API-Key\": OPENAI_API_KEY\n        },\n    )\n\n    # Get the 'WineReview' collection\n    collection = client.collections.get(\"WineReview\")\n\n    # Query the collection for wines that best match \"dessert wine\"\n    response = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        # Specify which properties to retrieve in the response\n        include_vector=False,  # We don't need the vector for this query\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n    )\n\n    # Print the title, country, price, and points of each matching wine\n    if response.objects:\n        print(\"Matching wines:\")\n        for obj in response.objects:\n            print(f\"- Title: {obj.properties.get('title')}\")\n            print(f\"  Country: {obj.properties.get('country')}\")\n            print(f\"  Price: {obj.properties.get('price')}\")\n            print(f\"  Points: {obj.properties.get('points')}\")\n    else:\n        print(\"No matching wines found.\")\n\nexcept weaviate.UnexpectedStatusCodeException as e:\n    print(f\"Weaviate client error: {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # Close the client connection\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"Weaviate client connection closed.\")\n```",
      "stdout": "Matching wines:\n- Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price: 24.0\n  Points: 88\n- Title: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price: 40.0\n  Points: 88\nWeaviate client connection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T21:08:05.915767",
      "duration": 2.9590210914611816,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.query import Query  # Import Query explicitly if needed for type hinting, though not strictly necessary here\nimport os\n\n# Connect to Weaviate Cloud\n# Ensure WCD_TEST_URL and WCD_TEST_KEY environment variables are set\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        # Inject the OpenAI API key for the text2vec-openai vectorizer\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\n# Define the query and limit\nsearch_query = \"dessert wine\"\nmax_results = 2\n\n# Get the 'WineReview' collection\nwine_reviews_collection = client.collections.get(\"WineReview\")\n\n# Perform a semantic search\n# The text2vec-openai vectorizer will be used to generate embeddings for the search query\nresponse = wine_reviews_collection.query.near_text(\n    query=search_query,\n    limit=max_results,\n    # Specify which properties to return for each matching wine\n    return_properties=[\"title\", \"country\", \"price\", \"points\"]\n)\n\n# Print the results\nif response.objects:\n    print(f\"Found {len(response.objects)} wines matching '{search_query}':\\n\")\n    for wine in response.objects:\n        properties = wine.properties\n        print(f\"Title: {properties.get('title', 'N/A')}\")\n        print(f\"Country: {properties.get('country', 'N/A')}\")\n        print(f\"Price: {properties.get('price', 'N/A')}\")\n        print(f\"Points: {properties.get('points', 'N/A')}\")\n        print(\"-\" * 20)\nelse:\n    print(f\"No wines found matching '{search_query}'.\")\n\n# Close the client connection\nclient.close()\n```",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 2, in <module>\n    from weaviate.classes.query import Query  # Import Query explicitly if needed for type hinting, though not strictly necessary here\nImportError: cannot import name 'Query' from 'weaviate.classes.query' (/usr/local/lib/python3.9/site-packages/weaviate/classes/query.py)\n",
      "exit_code": 1
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T21:08:09.697509",
      "duration": 3.2749030590057373,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get Weaviate Cloud connection details from environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_key = os.environ.get(\"WCD_TEST_KEY\")\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n\nif not all([weaviate_url, weaviate_key, openai_api_key]):\n    raise ValueError(\n        \"Please set the following environment variables: \"\n        \"WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY\"\n    )\n\n# Initialize the Weaviate client\nclient = weaviate.Client(\n    url=weaviate_url,\n    auth_client_secret=weaviate.AuthApiKey(weaviate_key),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": openai_api_key,\n    },\n)\n\n# Define the query\nquery_text = \"pair with steak\"\nlimit = 5\nalpha = 0.5\n\n# Construct the GraphQL query\n# We use a hybrid search with the query text and specify the `bm25` and `vector` searches.\n# The `alpha` parameter controls the weighting between BM25 and vector search.\n# We also apply filters for price and points, and a where filter for substrings in the review_body.\ngraphql_query = {\n    \"query\": \"\"\"\n    {\n      Get {\n        WineReview(\n          limit: %d,\n          hybrid: {\n            query: \"%s\",\n            alpha: %.1f\n          },\n          where: {\n            and: [\n              {\n                path: [\"price\"],\n                operator: LessThan,\n                value_number: 50\n              },\n              {\n                path: [\"points\"],\n                operator: GreaterThan,\n                value_number: 90\n              },\n              {\n                operator: Or,\n                operands: [\n                  {\n                    path: [\"review_body\"],\n                    operator: ContainsAny,\n                    valueText: [\"spice\"]\n                  },\n                  {\n                    path: [\"review_body\"],\n                    operator: ContainsAny,\n                    valueText: [\"fruit\"]\n                  },\n                  {\n                    path: [\"review_body\"],\n                    operator: ContainsAny,\n                    valueText: [\"berry\"]\n                  },\n                  {\n                    path: [\"review_body\"],\n                    operator: ContainsAny,\n                    valueText: [\"cherry\"]\n                  },\n                  {\n                    path: [\"review_body\"],\n                    operator: ContainsAny,\n                    valueText: [\"honey\"]\n                  }\n                ]\n              }\n            ]\n          }\n        ) {\n          title\n          country\n          price\n          points\n          review_body\n        }\n      }\n    }\n    \"\"\" % (limit, query_text, alpha)\n}\n\n# Execute the query\ntry:\n    result = client.query.raw(graphql_query)\n\n    # Print the results\n    if \"data\" in result and \"Get\" in result[\"data\"] and \"WineReview\" in result[\"data\"][\"Get\"]:\n        wines = result[\"data\"][\"Get\"][\"WineReview\"]\n        if wines:\n            print(f\"Found {len(wines)} wines matching your criteria:\")\n            for wine in wines:\n                print(f\"- Title: {wine['title']}, Country: {wine['country']}, Price: ${wine['price']}, Points: {wine['points']}\")\n        else:\n            print(\"No wines found matching your criteria.\")\n    else:\n        print(\"An error occurred during the query execution.\")\n        print(result)\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:16: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 16, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T21:08:13.746812",
      "duration": 3.6241931915283203,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Retrieve credentials from environment variables\ncluster_url = os.environ.get(\"WCD_TEST_URL\")\napi_key = os.environ.get(\"WCD_TEST_KEY\")\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n\nif not all([cluster_url, api_key, openai_api_key]):\n    raise ValueError(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY environment variables.\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key),\n    headers={\n        \"X-OpenAI-API-Key\": openai_api_key\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Define the hybrid search query\nquery_text = \"pair with steak\"\nmax_results = 5\nalpha_value = 0.5\n\n# Perform the hybrid search with filters\nresponse = collection.query.hybrid(\n    query=query_text,\n    limit=max_results,\n    alpha=alpha_value,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    # Request specific properties to be returned\n    return_properties=[\"title\", \"country\", \"price\", \"points\"]\n)\n\n# Print the results\nif response.objects:\n    for obj in response.objects:\n        print(f\"Title: {obj.properties['title']}\")\n        print(f\"Country: {obj.properties['country']}\")\n        print(f\"Price: {obj.properties['price']}\")\n        print(f\"Points: {obj.properties['points']}\")\n        # Optionally print the score if you included return_metadata=MetadataQuery(score=True)\n        # print(f\"Score: {obj.metadata.score}\")\n        print(\"-\" * 20)\nelse:\n    print(\"No matching wines found.\")\n\n# Close the client connection\nclient.close()\n```",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: 40.0\nPoints: 92\n--------------------\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: 49.0\nPoints: 91\n--------------------\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: 27.0\nPoints: 91\n--------------------\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: 25.0\nPoints: 93\n--------------------\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: 0.0\nPoints: 92\n--------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T21:08:18.702602",
      "duration": 4.5633111000061035,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.query import Filter, HybridFusion\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\n# WCD_TEST_URL should be set to your Weaviate Cloud instance URL\n# WCD_TEST_KEY should be set to your Weaviate API key\n# OPENAI_API_KEY should be set to your OpenAI API key\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\n# Get the WineReview collection\nwine_reviews = client.collections.get(\"WineReview\")\n\n# Define the search query and filters\nquery = \"pair with steak\"\nmax_results = 5\nalpha_value = 0.5\nkeywords_to_check = [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n\n# Construct the filter for review_body\n# This filter checks if the review_body contains at least one of the specified keywords\nreview_body_filter = Filter.by_property(\"review_body\").contains_any(keywords_to_check)\n\n# Perform the hybrid search\nresponse = wine_reviews.query.hybrid(\n    query=query,\n    alpha=alpha_value,\n    limit=max_results,\n    filters=Filter.all_of([\n        Filter.by_property(\"price\").less_than(50),\n        Filter.by_property(\"points\").greater_than(90),\n        review_body_filter  # Add the review_body keyword filter\n    ]),\n    return_properties=[\"title\", \"country\", \"price\", \"points\", \"review_body\"]\n)\n\n# Print the results\nif response.objects:\n    print(f\"Found {len(response.objects)} wines matching your query:\")\n    for wine in response.objects:\n        properties = wine.properties\n        print(f\"  Title: {properties['title']}\")\n        print(f\"  Country: {properties['country']}\")\n        print(f\"  Price: ${properties['price']}\")\n        print(f\"  Points: {properties['points']}\")\n        print(\"-\" * 20)\nelse:\n    print(\"No wines found matching your criteria.\")\n\n# Close the client connection\nclient.close()\n```",
      "stdout": "Found 5 wines matching your query:\n  Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price: $40.0\n  Points: 92\n--------------------\n  Title: Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price: $49.0\n  Points: 91\n--------------------\n  Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price: $27.0\n  Points: 91\n--------------------\n  Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price: $25.0\n  Points: 93\n--------------------\n  Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price: $0.0\n  Points: 92\n--------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    }
  },
  "openai/gpt-5-2025-08-07": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T21:08:41.519089",
      "duration": 22.795607089996338,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T21:08:51.722734",
      "duration": 10.169466972351074,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n)\n\nassert client.is_ready()\n\nclient.close()",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T21:09:21.453893",
      "duration": 29.711873054504395,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType, Configure\n\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\n\nwith weaviate.connect_to_wcs(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n) as client:\n    # Delete the collection if it already exists\n    if client.collections.exists(\"DemoProducts\"):\n        client.collections.delete(\"DemoProducts\")\n\n    # Create the collection with the requested properties\n    client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ],\n        # Use no vectorizer to avoid requiring any embedding module\n        vectorizer_config=Configure.Vectorizer.none(),\n    )\n\n    print(\"Collection 'DemoProducts' created successfully.\")",
      "stdout": "Collection 'DemoProducts' created successfully.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T21:09:38.949816",
      "duration": 17.47764825820923,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\ndef main():\n    cluster_url = os.getenv(\"WCD_TEST_URL\")\n    api_key = os.getenv(\"WCD_TEST_KEY\")\n\n    if not cluster_url or not api_key:\n        raise EnvironmentError(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=cluster_url,\n        auth_credentials=Auth.api_key(api_key),\n    )\n\n    try:\n        collection_name = \"DemoProducts\"\n\n        # Delete the collection if it already exists\n        if client.collections.exists(collection_name):\n            client.collections.delete(collection_name)\n\n        # Create the collection\n        products_collection = client.collections.create(\n            collection_name,\n            properties=[\n                Property(name=\"name\", data_type=DataType.TEXT),\n                Property(name=\"description\", data_type=DataType.TEXT),\n                Property(name=\"price\", data_type=DataType.NUMBER),\n                Property(name=\"in_stock\", data_type=DataType.BOOL),\n            ],\n        )\n\n        print(f\"Created collection: {products_collection.name}\")\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    main()",
      "stdout": "Created collection: DemoProducts\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T21:09:59.490809",
      "duration": 20.52214503288269,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n)\n\ntry:\n    # Delete the collection if it already exists\n    if client.collections.exists(\"DemoProducts\"):\n        client.collections.delete(\"DemoProducts\")\n\n    # Create the collection\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ],\n        # Use the built-in Weaviate vectorizer (no external API key required)\n        vector_config=Configure.Vectors.text2vec_weaviate(),\n    )\nfinally:\n    client.close()",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 26, in <module>\n    vector_config=Configure.Vectors.text2vec_weaviate(),\nAttributeError: type object 'Configure' has no attribute 'Vectors'\n",
      "exit_code": 1
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:10:28.788413",
      "duration": 28.66661286354065,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:10:49.520559",
      "duration": 20.087755918502808,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T21:11:25.313032",
      "duration": 35.104665994644165,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n)\n\ntry:\n    # Create the collection if it doesn't exist\n    if not client.collections.exists(\"DemoProducts\"):\n        client.collections.create(\n            name=\"DemoProducts\",\n            vector_config=Configure.Vectors.text2vec_weaviate(),  # Works in Weaviate Cloud without 3rd-party API keys\n            properties=[\n                Property(name=\"name\", data_type=DataType.TEXT),\n                Property(name=\"description\", data_type=DataType.TEXT),\n            ],\n        )\n\n    # Get the collection\n    products = client.collections.get(\"DemoProducts\")\n\n    # Batch import 50 objects\n    with products.batch.fixed_size(batch_size=50) as batch:\n        for i in range(50):\n            batch.add_object(\n                properties={\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"Description {i}\",\n                }\n            )\n\n    # Print the number of objects in the collection\n    agg = products.aggregate.over_all(total_count=True)\n    print(agg.total_count)\n\nfinally:\n    client.close()\n```",
      "stdout": "50\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:11:44.092685",
      "duration": 18.323253870010376,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\ndef main():\n    client = weaviate.connect_to_wcs(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=AuthApiKey(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]},\n    )\n\n    try:\n        collection = client.collections.get(\"WineReview\")\n\n        result = collection.query.near_text(\n            query=\"dessert wine\",\n            limit=2,\n            return_properties=[\"title\", \"country\", \"price\", \"points\"],\n        )\n\n        for obj in result.objects or []:\n            props = obj.properties or {}\n            print(f\"Title: {props.get('title')}\")\n            print(f\"Country: {props.get('country')}\")\n            print(f\"Price: {props.get('price')}\")\n            print(f\"Points: {props.get('points')}\")\n            print(\"-\" * 40)\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    main()\n```",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:12:01.491122",
      "duration": 16.918649911880493,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Read environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_key = os.getenv(\"WCD_TEST_KEY\")\nopenai_key = os.getenv(\"OPENAI_API_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=Auth.api_key(wcd_key),\n    headers={\n        \"X-OpenAI-API-Key\": openai_key,\n    },\n)\n\n# Get the collection\ncollection = client.collections.get(\"WineReview\")\n\n# Query for best matches to \"dessert wine\"\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2,\n)\n\n# Print requested properties\nfor obj in response.objects:\n    props = obj.properties or {}\n    print(f\"Title: {props.get('title')}, Country: {props.get('country')}, Price: {props.get('price')}, Points: {props.get('points')}\")\n\nclient.close()",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA)), Country: US, Price: 24.0, Points: 88\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast), Country: US, Price: 40.0, Points: 88\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:12:26.733241",
      "duration": 24.823960065841675,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to Weaviate Cloud with OpenAI vectorizer key\nwith weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]},\n) as client:\n    collection = client.collections.get(\"WineReview\")\n\n    # Semantic search for \"dessert wine\" with max 2 results\n    resp = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n    )\n\n    # Print desired fields\n    for obj in resp.objects:\n        props = obj.properties or {}\n        print(f\"Title: {props.get('title')}\")\n        print(f\"Country: {props.get('country')}\")\n        print(f\"Price: {props.get('price')}\")\n        print(f\"Points: {props.get('points')}\")\n        print()",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T21:12:52.309163",
      "duration": 25.18436026573181,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T21:13:14.514894",
      "duration": 21.758270025253296,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T21:13:44.503453",
      "duration": 29.5727481842041,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\n\n# Connect to Weaviate Cloud with OpenAI key for text2vec-openai\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    collection = client.collections.get(\"WineReview\")\n\n    # Build filters:\n    # - price < 50\n    # - points > 90\n    # - review_body contains any of the substrings: spice, fruit, berry, cherry, honey\n    text_filter = Filter.any_of(\n        filters=[\n            Filter.by_property(\"review_body\").like(\"*spice*\"),\n            Filter.by_property(\"review_body\").like(\"*fruit*\"),\n            Filter.by_property(\"review_body\").like(\"*berry*\"),\n            Filter.by_property(\"review_body\").like(\"*cherry*\"),\n            Filter.by_property(\"review_body\").like(\"*honey*\"),\n        ]\n    )\n    numeric_filter = (\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90)\n    )\n    combined_filters = numeric_filter & text_filter\n\n    # Hybrid search\n    resp = collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        limit=5,\n        filters=combined_filters,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n    )\n\n    # Print results\n    for obj in resp.objects:\n        p = obj.properties\n        print(f\"{p.get('title')} | {p.get('country')} | ${p.get('price')} | {p.get('points')} pts\")\n\nfinally:\n    client.close()",
      "stdout": "Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir | US | $40.0 | 92 pts\nBink 2014 Pinot Noir (Anderson Valley) | US | $49.0 | 91 pts\nDo\u00f1a Silvina 2011 Malbec (Mendoza) | Argentina | $27.0 | 91 pts\nDobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji) | Hungary | $25.0 | 93 pts\nTommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico) | Italy | $0.0 | 92 pts\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    }
  },
  "openai/gpt-5-mini-2025-08-07": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T21:13:54.442875",
      "duration": 9.920222997665405,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Read environment variables\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    raise RuntimeError(\"Both WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n\n# Create client for Weaviate Cloud\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n)\n\n# Check that the server is ready to accept requests\nif client.is_ready():\n    print(\"Weaviate server is ready.\")\nelse:\n    raise RuntimeError(\"Weaviate server is not ready.\")\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:12: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 12, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_connect": {
      "success": false,
      "timestamp": "2025-08-17T21:14:02.956035",
      "duration": 8.4947350025177,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\n# Read credentials from environment\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    raise RuntimeError(\"Both WCD_TEST_URL and WCD_TEST_KEY environment variables must be set\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=AuthApiKey(api_key=WCD_TEST_KEY)\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready(), \"Weaviate server is not ready\"\n\n# Close the client\nclient.close()",
      "stdout": "",
      "stderr": "/code/code.py:13: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 13, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T21:14:18.552480",
      "duration": 15.577774286270142,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "```python\nimport os\nimport sys\nimport weaviate\n\ndef main():\n    # Read env vars\n    url = os.getenv(\"WCD_TEST_URL\")\n    api_key = os.getenv(\"WCD_TEST_KEY\")\n    if not url or not api_key:\n        sys.exit(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables\")\n\n    # Connect to Weaviate Cloud\n    client = weaviate.Client(\n        url=url,\n        auth_client_secret=weaviate.AuthApiKey(api_key),\n    )\n\n    # Optional: ensure the instance is reachable\n    if not client.is_ready():\n        sys.exit(\"Weaviate instance is not ready / reachable\")\n\n    class_name = \"DemoProducts\"\n\n    # If the class exists, delete it first\n    schema = client.schema.get()\n    existing = [c.get(\"class\") for c in schema.get(\"classes\", [])]\n    if class_name in existing:\n        client.schema.delete_class(class_name)\n        print(f\"Deleted existing class '{class_name}'\")\n\n    # Define the class schema\n    class_schema = {\n        \"class\": class_name,\n        \"properties\": [\n            {\"name\": \"name\", \"dataType\": [\"text\"]},\n            {\"name\": \"description\", \"dataType\": [\"text\"]},\n            {\"name\": \"price\", \"dataType\": [\"number\"]},\n            {\"name\": \"in_stock\", \"dataType\": [\"boolean\"]},\n        ],\n        # Use \"none\" if you don't rely on a vectorizer module for this class.\n        # Change to an available vectorizer module name if you want automatic vectorization.\n        \"vectorizer\": \"none\",\n    }\n\n    # Create the class\n    client.schema.create_class(class_schema)\n    print(f\"Created class '{class_name}' with properties: name, description, price, in_stock\")\n\nif __name__ == \"__main__\":\n    main()\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:13: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 50, in <module>\n    main()\n  File \"/code/code.py\", line 13, in main\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T21:14:39.636220",
      "duration": 21.064648866653442,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport sys\nimport weaviate\n\n# Read connection info from environment\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    print(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\", file=sys.stderr)\n    sys.exit(1)\n\n# Connect to Weaviate Cloud using API key auth\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.auth.AuthApiKey(api_key=WCD_TEST_KEY),\n)\n\ncollection_name = \"DemoProducts\"\n\n# If the collection (class) already exists, delete it first\nschema = client.schema.get()\nexisting_classes = {c.get(\"class\") for c in schema.get(\"classes\", [])}\nif collection_name in existing_classes:\n    client.schema.delete_class(collection_name)\n    print(f\"Deleted existing collection/class: {collection_name}\")\n\n# Define the class (collection) schema\ndemo_products_class = {\n    \"class\": collection_name,\n    \"properties\": [\n        {\"name\": \"name\", \"dataType\": [\"text\"]},\n        {\"name\": \"description\", \"dataType\": [\"text\"]},\n        {\"name\": \"price\", \"dataType\": [\"number\"]},\n        {\"name\": \"in_stock\", \"dataType\": [\"boolean\"]},\n    ],\n}\n\n# Create the class\nclient.schema.create_class(demo_products_class)\nprint(f\"Created collection/class: {collection_name}\")\n\n# Close connection\nclient.close()\n```",
      "stdout": "",
      "stderr": "/code/code.py:14: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 14, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T21:14:53.758152",
      "duration": 14.102530002593994,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's a self-contained Python script that uses the latest Weaviate client syntax from your examples. It connects to Weaviate Cloud using WCD_TEST_URL and WCD_TEST_KEY, deletes the \"DemoProducts\" collection if it exists, and creates it with the requested properties.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\ndef main():\n    # Read connection info from environment\n    cluster_url = os.environ[\"WCD_TEST_URL\"]\n    api_key = os.environ[\"WCD_TEST_KEY\"]\n\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=cluster_url,\n        auth_credentials=Auth.api_key(api_key)\n    )\n\n    try:\n        collection_name = \"DemoProducts\"\n\n        # If the collection exists, delete it first\n        if client.collections.exists(collection_name):\n            print(f\"Collection '{collection_name}' exists \u2014 deleting it...\")\n            client.collections.delete(collection_name)\n            print(\"Deleted.\")\n\n        # Define properties\n        properties = [\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n\n        # Create the collection\n        client.collections.create(\n            collection_name,\n            properties=properties\n        )\n\n        print(f\"Collection '{collection_name}' created with properties: name, description, price, in_stock\")\n\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNotes:\n- Ensure environment variables WCD_TEST_URL and WCD_TEST_KEY are set before running.\n- If you need a specific vectorizer or other collection settings (indexing, replication, generative config, etc.), add a suitable vector_config or other Configure.* options to client.collections.create. See the example docstrings in your snippet for options.",
      "stdout": "Collection 'DemoProducts' exists \u2014 deleting it...\nDeleted.\nCollection 'DemoProducts' created with properties: name, description, price, in_stock\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n/usr/local/lib/python3.9/site-packages/weaviate/collections/classes/config.py:2041: PydanticDeprecatedSince211: Accessing this attribute on the instance is deprecated, and will be removed in Pydantic V3. Instead, you should access this attribute from the model class. Deprecated in Pydantic V2.11 to be removed in V3.0.\n  for cls_field in self.model_fields:\n",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:15:17.788018",
      "duration": 23.307837963104248,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T21:15:37.727054",
      "duration": 19.14718008041382,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Here's a concise script that uses the latest Weaviate client style shown in your example. It reads WCD_TEST_URL and WCD_TEST_KEY from the environment, connects to Weaviate Cloud, gets the \"DemoProducts\" collection, batch-imports 50 simple objects, prints information about failed imports (if any), and finally prints the number of objects in the collection.\n\nSave as a .py file and run it in an environment where WCD_TEST_URL and WCD_TEST_KEY are set.\n\n```python\nimport os\nimport sys\nimport weaviate\n\n# Read environment variables\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    print(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n    sys.exit(1)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n)\n\ntry:\n    # Get the collection (class) named \"DemoProducts\"\n    collection = client.collections.get(\"DemoProducts\")\n\n    # Prepare 50 objects\n    data_rows = [\n        {\"name\": f\"Product {i+1}\", \"description\": f\"Description {i+1}\"}\n        for i in range(50)\n    ]\n\n    # Batch import\n    with collection.batch.dynamic() as batch:\n        for data_row in data_rows:\n            batch.add_object(properties=data_row)\n            # optional safety: stop if too many errors\n            if batch.number_errors > 10:\n                print(\"Batch import stopped due to excessive errors.\")\n                break\n\n    # Report failed objects, if any\n    failed_objects = collection.batch.failed_objects\n    if failed_objects:\n        print(f\"Number of failed imports: {len(failed_objects)}\")\n        print(\"First failed object:\", failed_objects[0])\n\n    # Print total number of objects in the collection\n    print(\"Total objects in 'DemoProducts':\", len(collection))\n\nfinally:\n    client.close()\n```\n\nNotes:\n- This follows the same high-level client/collection/batch API style from your example.\n- If the \"DemoProducts\" collection/class doesn't exist, you'll need to create it first (define properties name and description) via the Weaviate schema API before adding objects.",
      "stdout": "Total objects in 'DemoProducts': 50\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T21:15:55.254363",
      "duration": 16.804327964782715,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's a self-contained Python script using the v4.x Weaviate Python client syntax. It:\n- Connects to Weaviate Cloud using WCD_TEST_URL and WCD_TEST_KEY,\n- Creates the \"DemoProducts\" collection with \"name\" and \"description\" text properties if it doesn't exist,\n- Batch imports 50 simple objects,\n- Prints the total number of objects in the collection,\n- Closes the client when done.\n\nSave as a .py file and run after setting the environment variables.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\ndef main():\n    # Read cloud credentials from environment\n    wc_url = os.environ.get(\"WCD_TEST_URL\")\n    wc_key = os.environ.get(\"WCD_TEST_KEY\")\n    if not wc_url or not wc_key:\n        raise RuntimeError(\"Set WCD_TEST_URL and WCD_TEST_KEY environment variables\")\n\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=wc_url,\n        auth_credentials=Auth.api_key(wc_key)\n    )\n\n    try:\n        class_name = \"DemoProducts\"\n\n        # Create collection (class) if it doesn't exist\n        if not client.collections.exists(class_name):\n            client.collections.create(\n                class_name,\n                properties=[\n                    Property(name=\"name\", data_type=DataType.TEXT),\n                    Property(name=\"description\", data_type=DataType.TEXT),\n                ]\n            )\n            print(f\"Created collection '{class_name}'\")\n        else:\n            print(f\"Collection '{class_name}' already exists\")\n\n        # Get the collection handle\n        collection = client.collections.get(class_name)\n\n        # Batch import 50 objects\n        with collection.batch.fixed_size(batch_size=50) as batch:\n            for i in range(50):\n                batch.add_object(\n                    properties={\n                        \"name\": f\"Product {i}\",\n                        \"description\": f\"Description {i}\"\n                    }\n                )\n\n        # Count objects by iterating (suitable for small counts; for large datasets consider an aggregate API)\n        count = sum(1 for _ in collection.iterator())\n        print(f\"Number of objects in '{class_name}': {count}\")\n\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNotes:\n- The script uses collection.iterator() to count objects; for very large datasets you may prefer an aggregate/count API if available in your client version.",
      "stdout": "Collection 'DemoProducts' already exists\nNumber of objects in 'DemoProducts': 50\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T21:16:09.964734",
      "duration": 14.233459949493408,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\n# Requires: pip install weaviate-client\nimport os\nimport weaviate\n\ndef main():\n    # Read environment variables\n    wcd_url = os.environ.get(\"WCD_TEST_URL\")\n    wcd_key = os.environ.get(\"WCD_TEST_KEY\")\n    openai_key = os.environ.get(\"OPENAI_API_KEY\")\n\n    if not (wcd_url and wcd_key and openai_key):\n        raise RuntimeError(\"Please set WCD_TEST_URL, WCD_TEST_KEY and OPENAI_API_KEY environment variables\")\n\n    # Connect to Weaviate Cloud and pass the OpenAI API key as an additional header\n    client = weaviate.Client(\n        url=wcd_url,\n        auth_client_secret=weaviate.AuthApiKey(api_key=wcd_key),\n        additional_headers={\"X-OpenAI-Api-Key\": openai_key},\n    )\n\n    query_text = \"dessert wine\"\n\n    # Query the WineReview class using nearText (text2vec-openai vectorizer)\n    response = (\n        client.query\n        .get(\"WineReview\", [\"title\", \"country\", \"price\", \"points\"])\n        .with_near_text({\"concepts\": [query_text]})\n        .with_limit(2)\n        .do()\n    )\n\n    items = response.get(\"data\", {}).get(\"Get\", {}).get(\"WineReview\", [])\n    if not items:\n        print(\"No matching wines found.\")\n        return\n\n    for i, item in enumerate(items, start=1):\n        title = item.get(\"title\")\n        country = item.get(\"country\")\n        price = item.get(\"price\")\n        points = item.get(\"points\")\n        print(f\"Result {i}:\")\n        print(f\"  Title:   {title}\")\n        print(f\"  Country: {country}\")\n        print(f\"  Price:   {price}\")\n        print(f\"  Points:  {points}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:15: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 50, in <module>\n    main()\n  File \"/code/code.py\", line 15, in main\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T21:16:34.549964",
      "duration": 24.08539390563965,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\ndef main():\n    # Load credentials from environment\n    cluster_url = os.environ[\"WCD_TEST_URL\"]\n    wcd_api_key = os.environ[\"WCD_TEST_KEY\"]\n    openai_api_key = os.environ[\"OPENAI_API_KEY\"]\n\n    # Connect to Weaviate Cloud (passes the OpenAI key in headers so text2vec-openai can be used)\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=cluster_url,\n        auth_credentials=weaviate.AuthApiKey(api_key=wcd_api_key),\n        headers={\n            \"X-OpenAI-API-Key\": openai_api_key\n        },\n    )\n\n    try:\n        # Run a near-text/vector search for \"dessert wine\" on the WineReview class,\n        # requesting the fields title, country, price and points, limited to 2 results.\n        res = (\n            client.query\n            .get(\"WineReview\", [\"title\", \"country\", \"price\", \"points\"])\n            .with_near_text({\"concepts\": [\"dessert wine\"]})\n            .with_limit(2)\n            .do()\n        )\n\n        # Extract results\n        items = res.get(\"data\", {}).get(\"Get\", {}).get(\"WineReview\", [])\n        if not items:\n            print(\"No matching wines found.\")\n            return\n\n        # Print requested fields for each result\n        for i, item in enumerate(items, start=1):\n            title = item.get(\"title\")\n            country = item.get(\"country\")\n            price = item.get(\"price\")\n            points = item.get(\"points\")\n            print(f\"Result {i}:\")\n            print(f\"  Title:   {title}\")\n            print(f\"  Country: {country}\")\n            print(f\"  Price:   {price}\")\n            print(f\"  Points:  {points}\")\n            print()\n\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNotes:\n- Ensure the environment variables WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY are set before running.\n- This uses the modern client query API: client.query.get(...).with_near_text(...).with_limit(...).do().",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 53, in <module>\n    main()\n  File \"/code/code.py\", line 23, in main\n    client.query\nAttributeError: 'WeaviateClient' object has no attribute 'query'\n",
      "exit_code": 1
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:16:50.441679",
      "duration": 15.457348823547363,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\n#!/usr/bin/env python3\nimport os\nimport sys\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Read required environment variables\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY or not OPENAI_API_KEY:\n    sys.exit(\n        \"Missing required environment variables. Make sure WCD_TEST_URL, WCD_TEST_KEY and OPENAI_API_KEY are set.\"\n    )\n\n# Connect to Weaviate Cloud, pass OpenAI API key as header for the text2vec-openai vectorizer\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    headers={\"X-OpenAI-Api-Key\": OPENAI_API_KEY},\n)\n\ntry:\n    # Get the WineReview collection\n    collection = client.collections.get(\"WineReview\")\n\n    # Semantic search for \"dessert wine\", limit to maximum 2 results\n    response = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n    )\n\n    # Print requested fields for each matching wine\n    if not response.objects:\n        print(\"No matching wines found.\")\n    else:\n        for i, obj in enumerate(response.objects, start=1):\n            props = obj.properties or {}\n            title = props.get(\"title\")\n            country = props.get(\"country\")\n            price = props.get(\"price\")\n            points = props.get(\"points\")\n            print(f\"Result {i}:\")\n            print(f\"  Title  : {title}\")\n            print(f\"  Country: {country}\")\n            print(f\"  Price  : {price}\")\n            print(f\"  Points : {points}\")\n            print()\nfinally:\n    client.close()\n```",
      "stdout": "Result 1:\n  Title  : Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price  : 24.0\n  Points : 88\n\nResult 2:\n  Title  : Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price  : 40.0\n  Points : 88\n\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T21:17:15.466497",
      "duration": 24.630907773971558,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Read environment variables\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\n# OPENAI_API_KEY is expected to be set on the Weaviate Cloud instance (server-side),\n# not required by the client here.\n\n# Create Weaviate client for cloud instance\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n    timeout_config=(5, 60),\n)\n\n# Build the Where filter:\n# - price < 50\n# - points > 90\n# - review_body contains at least one of the listed substrings\nwhere_filter = {\n    \"operator\": \"And\",\n    \"operands\": [\n        {\n            \"path\": [\"price\"],\n            \"operator\": \"LessThan\",\n            \"valueNumber\": 50\n        },\n        {\n            \"path\": [\"points\"],\n            \"operator\": \"GreaterThan\",\n            \"valueNumber\": 90\n        },\n        {\n            \"operator\": \"Or\",\n            \"operands\": [\n                {\"path\": [\"review_body\"], \"operator\": \"Like\", \"valueText\": \"%spice%\"},\n                {\"path\": [\"review_body\"], \"operator\": \"Like\", \"valueText\": \"%fruit%\"},\n                {\"path\": [\"review_body\"], \"operator\": \"Like\", \"valueText\": \"%berry%\"},\n                {\"path\": [\"review_body\"], \"operator\": \"Like\", \"valueText\": \"%cherry%\"},\n                {\"path\": [\"review_body\"], \"operator\": \"Like\", \"valueText\": \"%honey%\"},\n            ],\n        },\n    ],\n}\n\n# Perform hybrid search with alpha=0.5, query \"pair with steak\", limit 5\nresponse = (\n    client.query.get(\"WineReview\", [\"title\", \"country\", \"price\", \"points\", \"review_body\"])\n    .with_hybrid(\"pair with steak\", alpha=0.5)\n    .with_where(where_filter)\n    .with_limit(5)\n    .do()\n)\n\n# Extract results and print requested fields\nitems = response.get(\"data\", {}).get(\"Get\", {}).get(\"WineReview\", [])\n\nif not items:\n    print(\"No matching wines found.\")\nelse:\n    for idx, item in enumerate(items, start=1):\n        title = item.get(\"title\")\n        country = item.get(\"country\")\n        price = item.get(\"price\")\n        points = item.get(\"points\")\n        print(f\"{idx}. Title: {title} | Country: {country} | Price: {price} | Points: {points}\")\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:145: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:11: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 11, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T21:17:46.992454",
      "duration": 31.120231866836548,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T21:18:07.915514",
      "duration": 20.497114896774292,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, HybridFusion\n\n# Ensure required environment variables exist\nWCD_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_KEY = os.environ.get(\"WCD_TEST_KEY\")\nOPENAI_KEY = os.environ.get(\"OPENAI_API_KEY\")\n\nif not all([WCD_URL, WCD_KEY, OPENAI_KEY]):\n    raise RuntimeError(\n        \"Missing required environment variables. Make sure WCD_TEST_URL, WCD_TEST_KEY and OPENAI_API_KEY are set.\"\n    )\n\n# Connect to Weaviate Cloud (include OpenAI API key in headers for text2vec-openai)\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_URL,\n    auth_credentials=Auth.api_key(WCD_KEY),\n    headers={\"X-OpenAI-Api-Key\": OPENAI_KEY},\n)\n\ntry:\n    # Get the WineReview collection\n    collection = client.collections.get(\"WineReview\")\n\n    # Build text-substring filter: review_body contains at least one of the substrings\n    review_substrings_filter = (\n        Filter.by_property(\"review_body\").like(\"*spice*\")\n        | Filter.by_property(\"review_body\").like(\"*fruit*\")\n        | Filter.by_property(\"review_body\").like(\"*berry*\")\n        | Filter.by_property(\"review_body\").like(\"*cherry*\")\n        | Filter.by_property(\"review_body\").like(\"*honey*\")\n    )\n\n    # Numeric filters: price < 50 and points > 90\n    numeric_filters = (\n        Filter.by_property(\"price\").less_than(50)\n        & Filter.by_property(\"points\").greater_than(90)\n    )\n\n    combined_filter = numeric_filters & review_substrings_filter\n\n    # Perform hybrid search with alpha=0.5, limit up to 5 results\n    response = collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        fusion_type=HybridFusion.RELATIVE_SCORE,\n        filters=combined_filter,\n        limit=5,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n    )\n\n    # Print results\n    if not response.objects:\n        print(\"No matching wines found.\")\n    else:\n        for obj in response.objects:\n            props = obj.properties or {}\n            title = props.get(\"title\")\n            country = props.get(\"country\")\n            price = props.get(\"price\")\n            points = props.get(\"points\")\n            print(f\"Title: {title} | Country: {country} | Price: {price} | Points: {points}\")\n\nfinally:\n    client.close()",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir | Country: US | Price: 40.0 | Points: 92\nTitle: Bink 2014 Pinot Noir (Anderson Valley) | Country: US | Price: 49.0 | Points: 91\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza) | Country: Argentina | Price: 27.0 | Points: 91\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji) | Country: Hungary | Price: 25.0 | Points: 93\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico) | Country: Italy | Price: 0.0 | Points: 92\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    }
  },
  "openai/gpt-5-nano-2025-08-07": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T21:18:17.341106",
      "duration": 9.404930114746094,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T21:18:25.712741",
      "duration": 8.338319063186646,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\ndef main():\n    cluster_url = os.environ[\"WCD_TEST_URL\"]\n    api_key = os.environ[\"WCD_TEST_KEY\"]\n\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=cluster_url,\n        auth_credentials=Auth.api_key(api_key)\n    )\n\n    assert client.is_ready()\n\n    client.close()\n\nif __name__ == \"__main__\":\n    main()",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T21:18:34.859407",
      "duration": 9.128593921661377,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T21:18:44.039768",
      "duration": 9.147908926010132,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T21:18:53.953476",
      "duration": 9.885953187942505,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:19:04.384448",
      "duration": 9.699347019195557,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:19:18.013638",
      "duration": 12.959451913833618,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T21:19:28.192836",
      "duration": 9.531661987304688,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T21:19:37.801869",
      "duration": 9.22121810913086,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T21:19:47.704960",
      "duration": 9.505964040756226,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T21:20:00.869078",
      "duration": 12.740342855453491,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\ndef main():\n    # Connect to Weaviate Cloud using environment variables\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\n            \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n        }\n    )\n\n    try:\n        # Get the WineReview collection\n        wine_collection = client.collections.get(\"WineReview\")\n\n        # Semantic search: find wines most similar to \"dessert wine\"\n        response = wine_collection.query.near_text(\n            query=\"dessert wine\",\n            limit=2\n        )\n\n        # Print desired fields: title, country, price, and points\n        for obj in response.objects:\n            props = obj.properties\n            title = props.get(\"title\")\n            country = props.get(\"country\")\n            price = props.get(\"price\")\n            points = props.get(\"points\")\n            print(title, country, price, points)\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    main()\n```",
      "stdout": "Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA)) US 24.0 88\nClos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast) US 40.0 88\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:133: DeprecationWarning: Dep005: You are using weaviate-client version 4.11.3. The latest version is 4.16.7.\n            Consider upgrading to the latest version. See https://weaviate.io/developers/weaviate/client-libraries/python for details.\n  warnings.warn(\n",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T21:20:11.390837",
      "duration": 10.078569173812866,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T21:20:20.888445",
      "duration": 9.027290105819702,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T21:20:30.803577",
      "duration": 9.505024909973145,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "",
      "error": "No code was executed"
    }
  }
}