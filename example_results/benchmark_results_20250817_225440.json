{
  "anthropic/claude-3-7-sonnet-20250219": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:15:50.886055",
      "duration": 5.934338092803955,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.embedded import EmbeddedOptions\n\n# Get environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_api_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not wcd_url or not wcd_api_key:\n    raise ValueError(\"WCD_TEST_URL and WCD_TEST_KEY environment variables must be set\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_wcs(\n    cluster_url=wcd_url,\n    auth_credentials=weaviate.auth.AuthApiKey(api_key=wcd_api_key),\n)\n\n# Check if the server is ready\nif client.is_ready():\n    print(\"Weaviate server is ready!\")\nelse:\n    print(\"Weaviate server is not ready!\")\n\n# Close the connection\nclient.close()\n```\n\nThis code uses the latest Weaviate client syntax to connect to a Weaviate Cloud instance using the environment variables WCD_TEST_URL and WCD_TEST_KEY. It then checks if the server is ready to accept requests using the `is_ready()` method.",
      "stdout": "Weaviate server is ready!\n",
      "stderr": "/code/code.py:14: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:15:55.957491",
      "duration": 5.052929639816284,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=Auth.api_key(wcd_key)\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready()\n\n# Close the connection\nclient.close()\n```\n\nThis code:\n1. Imports the necessary modules\n2. Retrieves the Weaviate Cloud URL and API key from environment variables\n3. Connects to the Weaviate Cloud instance using the latest client syntax\n4. Verifies the server is ready to accept requests\n5. Closes the connection",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:16:05.590737",
      "duration": 9.615334272384644,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType, Configure\n\n# Get environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not weaviate_url or not weaviate_api_key:\n    raise ValueError(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_wcs(\n    cluster_url=weaviate_url,\n    auth_credentials=weaviate.auth.AuthApiKey(weaviate_api_key),\n)\n\n# Collection name\ncollection_name = \"DemoProducts\"\n\n# Check if collection exists and delete it if it does\nif client.collections.exists(collection_name):\n    print(f\"Collection '{collection_name}' exists. Deleting it...\")\n    client.collections.delete(collection_name)\n    print(f\"Collection '{collection_name}' deleted.\")\n\n# Create the collection with properties\ncollection = client.collections.create(\n    name=collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n    ],\n    vectorizer_config=Configure.Vectorizer.none(),\n)\n\nprint(f\"Collection '{collection_name}' created successfully with the specified properties.\")\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Imports the necessary Weaviate modules\n2. Retrieves the Weaviate Cloud credentials from environment variables\n3. Connects to the Weaviate Cloud instance\n4. Checks if the \"DemoProducts\" collection exists and deletes it if it does\n5. Creates a new \"DemoProducts\" collection with the specified properties:\n   - name (text)\n   - description (text)\n   - price (number)\n   - in_stock (boolean)\n6. Configures the collection with no vectorizer (you can change this if needed)\n7. Closes the client connection\n\nNote: This uses the latest Weaviate client syntax (2.x) with the new collections API.",
      "stdout": "Collection 'DemoProducts' exists. Deleting it...\nCollection 'DemoProducts' deleted.\n",
      "stderr": "/code/code.py:14: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\nTraceback (most recent call last):\n  File \"/code/code.py\", line 35, in <module>\n    Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n  File \"/usr/local/lib/python3.9/enum.py\", line 429, in __getattr__\n    raise AttributeError(name) from None\nAttributeError: BOOLEAN\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 54992), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:16:11.107735",
      "duration": 5.499037981033325,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ.get(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.environ.get(\"WCD_TEST_KEY\"))\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n    print(f\"Deleted existing collection: {collection_name}\")\n\n# Create the collection with the specified properties\nproducts_collection = client.collections.create(\n    name=collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n```",
      "stdout": "Created collection: DemoProducts\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:16:19.144050",
      "duration": 8.018124103546143,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to create a \"DemoProducts\" collection with the specified properties using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\n# Check if collection exists and delete it if it does\nif client.collections.exists(\"DemoProducts\"):\n    client.collections.delete(\"DemoProducts\")\n\n# Create the DemoProducts collection with the specified properties\nclient.collections.create(\n    \"DemoProducts\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL)\n    ]\n)\n\n# Close the client connection when done\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the environment variables\n2. Checks if the \"DemoProducts\" collection already exists and deletes it if it does\n3. Creates a new \"DemoProducts\" collection with the four specified properties\n4. Properly closes the client connection when done",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:16:31.753510",
      "duration": 11.604978084564209,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType, Configure\nfrom weaviate.collections import Collection\n\n# Get environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate\nclient = weaviate.connect_to_wcs(\n    cluster_url=weaviate_url,\n    auth_credentials=weaviate.auth.AuthApiKey(weaviate_api_key),\n)\n\n# Check if collection exists, if not create it\ntry:\n    collection = client.collections.get(\"DemoProducts\")\n    print(\"Collection 'DemoProducts' already exists\")\nexcept weaviate.exceptions.WeaviateQueryError:\n    # Create collection with properties\n    collection = client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ],\n        vectorizer_config=Configure.Vectorizer.none(),  # No vectorization needed for this example\n    )\n    print(\"Created collection 'DemoProducts'\")\n\n# Prepare batch of objects\nobjects = [\n    {\n        \"name\": f\"Product {i}\",\n        \"description\": f\"Description for product {i}. This is a sample product.\"\n    }\n    for i in range(1, 51)\n]\n\n# Batch import objects\nwith collection.batch.dynamic() as batch:\n    for obj in objects:\n        batch.add_object(\n            properties=obj\n        )\n\nprint(f\"Added {len(objects)} objects to the collection\")\n\n# Count objects in the collection\ncount = collection.aggregate.over_all().count()\nprint(f\"Total number of objects in the collection: {count}\")\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using environment variables\n2. Creates a \"DemoProducts\" collection with name and description properties if it doesn't exist\n3. Generates 50 sample product objects\n4. Uses batch processing to efficiently import all objects\n5. Counts and prints the total number of objects in the collection\n6. Properly closes the client connection\n\nThe code uses the latest Weaviate client syntax with the collections API and batch processing for efficient imports.",
      "stdout": "Collection 'DemoProducts' already exists\nAdded 50 objects to the collection\n",
      "stderr": "/code/code.py:11: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\nTraceback (most recent call last):\n  File \"/code/code.py\", line 51, in <module>\n    count = collection.aggregate.over_all().count()\nAttributeError: 'AggregateReturn' object has no attribute 'count'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 59774), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:16:42.124848",
      "duration": 9.728023052215576,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.auth import Auth\n\n# Connect to Weaviate Cloud using environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=Auth.api_key(wcd_key),\n)\n\n# Check if collection exists, if not create it\nif \"DemoProducts\" not in client.collections.list_all():\n    collection = client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            {\"name\": \"name\", \"dataType\": [\"text\"]},\n            {\"name\": \"description\", \"dataType\": [\"text\"]}\n        ]\n    )\nelse:\n    collection = client.collections.get(\"DemoProducts\")\n\n# Prepare 50 objects to import\ndata_objects = [\n    {\n        \"name\": f\"Product {i+1}\",\n        \"description\": f\"Description for product {i+1}. This is a sample product.\"\n    } for i in range(50)\n]\n\n# Batch import the objects\nwith collection.batch.dynamic() as batch:\n    for data_object in data_objects:\n        batch.add_object(\n            properties=data_object,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\n# Check for failed objects\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\n# Print the number of objects in the collection\nprint(f\"Number of objects in the DemoProducts collection: {len(collection)}\")\n\n# Close the client\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the environment variables\n2. Creates the \"DemoProducts\" collection if it doesn't exist\n3. Prepares 50 sample product objects\n4. Batch imports the objects into the collection\n5. Checks for any failed imports\n6. Prints the total number of objects in the collection\n7. Closes the client connection",
      "stdout": "Number of objects in the DemoProducts collection: 50\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:16:52.139780",
      "duration": 9.33753776550293,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to add objects to a \"DemoProducts\" collection using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\n# Check if collection exists and create it if it doesn't\nif not client.collections.exists(\"DemoProducts\"):\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ]\n    )\n\n# Get the collection\ncollection = client.collections.get(\"DemoProducts\")\n\n# Batch import 50 arbitrary objects\nwith collection.batch.fixed_size(batch_size=10) as batch:\n    for i in range(1, 51):\n        batch.add_object(\n            properties={\n                \"name\": f\"Product {i}\",\n                \"description\": f\"Description {i}\"\n            }\n        )\n\n# Print the number of objects in the collection\ncount = collection.query.fetch_objects(limit=0).total_count\nprint(f\"Number of objects in the collection: {count}\")\n\n# Close the client when done\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the environment variables\n2. Creates a \"DemoProducts\" collection if it doesn't exist\n3. Batch imports 50 simple product objects\n4. Prints the total count of objects in the collection\n5. Properly closes the client connection",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 36, in <module>\n    count = collection.query.fetch_objects(limit=0).total_count\nAttributeError: 'QueryReturn' object has no attribute 'total_count'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 40306), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T22:17:00.995788",
      "duration": 8.12146806716919,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import QueryNearText\n\n# Get environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n\n# Connect to Weaviate\nclient = weaviate.connect_to_wcs(\n    cluster_url=weaviate_url,\n    auth_credentials=weaviate.auth.AuthApiKey(api_key=weaviate_api_key),\n    headers={\n        \"X-OpenAI-Api-Key\": openai_api_key\n    }\n)\n\n# Query for wines matching \"dessert wine\"\nresponse = (\n    client.collections.get(\"WineReview\")\n    .query.near_text(\n        query=\"dessert wine\",\n        limit=2\n    )\n    .with_additional([\"certainty\"])\n    .objects\n)\n\n# Print the results\nprint(\"Matching wines for 'dessert wine':\")\nfor wine in response:\n    properties = wine.properties\n    print(f\"\\nTitle: {properties.get('title', 'N/A')}\")\n    print(f\"Country: {properties.get('country', 'N/A')}\")\n    print(f\"Price: ${properties.get('price', 'N/A')}\")\n    print(f\"Points: {properties.get('points', 'N/A')}\")\n    print(f\"Certainty: {wine.metadata.certainty:.4f}\")\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using environment variables\n2. Performs a semantic search for \"dessert wine\" using the text2vec-openai vectorizer\n3. Limits the results to 2 wines\n4. Prints the title, country, price, and points for each matching wine\n5. Also includes the certainty score to show how well each result matches the query\n6. Properly closes the client connection when done",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 3, in <module>\n    from weaviate.classes.query import QueryNearText\nImportError: cannot import name 'QueryNearText' from 'weaviate.classes.query' (/usr/local/lib/python3.9/site-packages/weaviate/classes/query.py)\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:17:08.597792",
      "duration": 7.148252010345459,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Get environment variables\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=Auth.api_key(wcd_key),\n    headers={\n        \"X-OpenAI-API-Key\": openai_api_key\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Query for wines matching \"dessert wine\"\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2\n)\n\n# Print the results\nfor obj in response.objects:\n    print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n    print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n    print(f\"Price: ${obj.properties.get('price', 'N/A')}\")\n    print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n    print(\"-\" * 40)\n\n# Close the client\nclient.close()\n```\n\nThis code:\n1. Retrieves the necessary environment variables\n2. Connects to Weaviate Cloud using the provided credentials\n3. Gets the WineReview collection\n4. Performs a semantic search for \"dessert wine\" with a limit of 2 results\n5. Prints the title, country, price, and points for each matching wine\n6. Properly closes the client connection when done",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: $24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: $40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:17:16.759645",
      "duration": 7.765552282333374,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Query for wines that match \"dessert wine\"\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print the results\n    print(\"Wines matching 'dessert wine':\")\n    for wine in response.objects:\n        print(f\"Title: {wine.properties['title']}\")\n        print(f\"Country: {wine.properties['country']}\")\n        print(f\"Price: ${wine.properties['price']}\")\n        print(f\"Points: {wine.properties['points']}\")\n        print(\"-\" * 50)\n        \nfinally:\n    # Close the client connection\n    client.close()\n```",
      "stdout": "Wines matching 'dessert wine':\nTitle: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: $24.0\nPoints: 88\n--------------------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: $40.0\nPoints: 88\n--------------------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:17:28.396491",
      "duration": 11.234648942947388,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import Filter\nfrom weaviate.classes.config import Configure\n\n# Get environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n\n# Initialize Weaviate client\nclient = weaviate.connect_to_wcs(\n    cluster_url=weaviate_url,\n    auth_credentials=weaviate.auth.AuthApiKey(weaviate_api_key),\n    headers={\n        \"X-OpenAI-Api-Key\": openai_api_key\n    }\n)\n\n# Define the query\nresponse = (\n    client.collections.get(\"WineReview\")\n    .query\n    .hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        limit=5,\n        filters=Filter.and_(\n            Filter.by_property(\"price\").less_than(50),\n            Filter.by_property(\"points\").greater_than(90),\n            Filter.or_(\n                Filter.by_property(\"review_body\").contains_any(\"spice\"),\n                Filter.by_property(\"review_body\").contains_any(\"fruit\"),\n                Filter.by_property(\"review_body\").contains_any(\"berry\"),\n                Filter.by_property(\"review_body\").contains_any(\"cherry\"),\n                Filter.by_property(\"review_body\").contains_any(\"honey\")\n            )\n        )\n    )\n    .with_additional([\"score\"])\n    .objects\n)\n\n# Print the results\nprint(f\"Found {len(response)} matching wines:\\n\")\nfor wine in response:\n    print(f\"Title: {wine.properties.get('title')}\")\n    print(f\"Country: {wine.properties.get('country')}\")\n    print(f\"Price: ${wine.properties.get('price')}\")\n    print(f\"Points: {wine.properties.get('points')}\")\n    print(f\"Score: {wine.metadata.score:.4f}\")\n    print(\"-\" * 50)\n\n# Close the client\nclient.close()\n```\n\nThis code:\n\n1. Connects to Weaviate Cloud using the environment variables\n2. Performs a hybrid search (combining vector and keyword search) with alpha=0.5\n3. Limits results to 5 wines\n4. Applies filters to ensure:\n   - Price is less than $50\n   - Points are greater than 90\n   - Review body contains at least one of the specified keywords\n5. Prints the title, country, price, points, and search score for each matching wine\n6. Properly closes the client connection when done\n\nThe hybrid search with alpha=0.5 gives equal weight to vector similarity and keyword matching, which is ideal for finding wines that semantically match \"pair with steak\" while also considering the keyword filters.",
      "stdout": "",
      "stderr": "/code/code.py:12: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\nTraceback (most recent call last):\n  File \"/code/code.py\", line 28, in <module>\n    filters=Filter.and_(\nAttributeError: type object 'Filter' has no attribute 'and_'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 58500), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:17:36.586509",
      "duration": 7.808754920959473,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=Auth.api_key(wcd_key),\n    headers={\n        \"X-OpenAI-API-Key\": openai_api_key\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform hybrid search\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) & \n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\n# Print results\nprint(f\"Found {len(response.objects)} matching wines:\\n\")\n\nfor obj in response.objects:\n    print(f\"Title: {obj.properties['title']}\")\n    print(f\"Country: {obj.properties['country']}\")\n    print(f\"Price: ${obj.properties['price']}\")\n    print(f\"Points: {obj.properties['points']}\")\n    print(f\"Score: {obj.metadata.score:.4f}\")\n    print(\"-\" * 50)\n\n# Close the client\nclient.close()\n```",
      "stdout": "Found 5 matching wines:\n\nTitle: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.0\nPoints: 92\nScore: 0.5000\n--------------------------------------------------\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.0\nPoints: 91\nScore: 0.3764\n--------------------------------------------------\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.0\nPoints: 91\nScore: 0.0450\n--------------------------------------------------\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.0\nPoints: 93\nScore: 0.0159\n--------------------------------------------------\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: $0.0\nPoints: 92\nScore: 0.0005\n--------------------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:17:51.049866",
      "duration": 14.067532777786255,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\nimport re\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Define the regex pattern to match any of the required substrings\n    pattern = re.compile(r'spice|fruit|berry|cherry|honey', re.IGNORECASE)\n    \n    # Create a filter for price < 50 and points > 90\n    price_points_filter = (\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90)\n    )\n    \n    # Perform hybrid search with alpha=0.5\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,  # Balance between keyword and vector search\n        filters=price_points_filter,\n        limit=5,\n        return_metadata=MetadataQuery(distance=True, score=True)\n    )\n    \n    # Process and print results, filtering for those containing required substrings\n    print(\"Wines that pair well with steak:\")\n    print(\"================================\")\n    \n    for wine in response.objects:\n        # Check if review_body contains any of the required substrings\n        if \"review_body\" in wine.properties and wine.properties[\"review_body\"]:\n            if pattern.search(wine.properties[\"review_body\"]):\n                print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n                print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n                print(f\"Price: ${wine.properties.get('price', 'N/A')}\")\n                print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n                print(f\"Score: {wine.metadata.score}\")\n                print(\"--------------------------------\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using environment variables\n2. Gets the WineReview collection\n3. Creates a filter for wines with price < 50 and points > 90\n4. Performs a hybrid search (combining vector and keyword search) with alpha=0.5\n5. Filters results to only include wines with reviews containing at least one of the required substrings\n6. Prints the title, country, price, and points for each matching wine\n7. Properly closes the client connection when done\n\nThe code uses the latest Weaviate Python client syntax (v4.x) and follows best practices for connection handling and query construction.",
      "stdout": "Wines that pair well with steak:\n================================\nTitle: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.0\nPoints: 92\nScore: 0.5\n--------------------------------\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.0\nPoints: 91\nScore: 0.3765353560447693\n--------------------------------\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.0\nPoints: 91\nScore: 0.04513849690556526\n--------------------------------\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.0\nPoints: 93\nScore: 0.016171861439943314\n--------------------------------\n",
      "stderr": "",
      "exit_code": 0
    }
  },
  "anthropic/claude-3-5-haiku-20241022": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T22:17:55.847417",
      "duration": 4.778242111206055,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "Here's a Python script that connects to Weaviate Cloud using environment variables and checks server readiness:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.connect import ConnectionParams\n\n# Create connection parameters from environment variables\nconnection_params = ConnectionParams.from_params(\n    url=os.getenv('WCD_TEST_URL'),\n    api_key=os.getenv('WCD_TEST_KEY')\n)\n\n# Create Weaviate client\nclient = weaviate.connect_to_custom(\n    connection_params=connection_params\n)\n\n# Check server readiness\ntry:\n    client.is_ready()\n    print(\"Weaviate server is ready.\")\nexcept Exception as e:\n    print(f\"Error connecting to Weaviate: {e}\")\nfinally:\n    # Close the connection\n    client.close()\n```\n\nThis script does the following:\n1. Uses environment variables for URL and API key\n2. Creates connection parameters\n3. Establishes a connection to Weaviate\n4. Checks if the server is ready\n5. Closes the connection",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 6, in <module>\n    connection_params = ConnectionParams.from_params(\nTypeError: from_params() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:18:00.198628",
      "duration": 4.332254886627197,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "Here's the Python code to connect to Weaviate Cloud using environment variables:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv('WCD_TEST_URL'),\n    auth_credentials=Auth.api_key(os.getenv('WCD_TEST_KEY'))\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready()\n\n# Close the client connection\nclient.close()\n```\n\nThis code does the following:\n1. Imports the necessary modules\n2. Uses `os.getenv()` to retrieve the Weaviate Cloud URL and API key from environment variables\n3. Connects to the Weaviate Cloud instance\n4. Checks that the server is ready using `is_ready()`\n5. Closes the client connection",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:18:11.913067",
      "duration": 11.695887088775635,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "Here's a Python script using the latest Weaviate client syntax to create a collection with the specified properties:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\n\ndef create_products_collection():\n    # Read Weaviate Cloud credentials from environment variables\n    wcd_url = os.getenv('WCD_TEST_URL')\n    wcd_key = os.getenv('WCD_TEST_KEY')\n\n    # Create Weaviate client\n    client = weaviate.connect_to_wcs(\n        cluster_url=wcd_url,\n        auth_credentials=wcd_key\n    )\n\n    try:\n        # Check if collection exists and delete if it does\n        if client.collections.exists(\"DemoProducts\"):\n            print(\"Deleting existing DemoProducts collection...\")\n            client.collections.delete(\"DemoProducts\")\n\n        # Create the collection with specified properties\n        client.collections.create(\n            name=\"DemoProducts\",\n            properties=[\n                Property(\n                    name=\"name\",\n                    data_type=DataType.TEXT\n                ),\n                Property(\n                    name=\"description\", \n                    data_type=DataType.TEXT\n                ),\n                Property(\n                    name=\"price\", \n                    data_type=DataType.NUMBER\n                ),\n                Property(\n                    name=\"in_stock\", \n                    data_type=DataType.BOOLEAN\n                )\n            ]\n        )\n\n        print(\"DemoProducts collection created successfully!\")\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n    finally:\n        # Close the client connection\n        client.close()\n\n# Run the function\nif __name__ == \"__main__\":\n    create_products_collection()\n```\n\nThis script does the following:\n\n1. Imports necessary modules from the Weaviate client library.\n\n2. Defines a function `create_products_collection()` that:\n   - Retrieves Weaviate Cloud credentials from environment variables\n   - Connects to Weaviate Cloud using `connect_to_wcs()`\n   - Checks if the \"DemoProducts\" collection exists and deletes it if it does\n   - Creates a new collection with the specified properties\n   - Uses the latest Weaviate client syntax with `collections.create()`\n   - Defines properties using `Property()` with appropriate `DataType`\n\n3. Includes error handling and ensures the client connection is closed\n\n4. Runs the function when the script is executed directly\n\nBefore running the script, make sure to:\n- Install the Weaviate client: `pip install weaviate-client`\n- Set the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n\nExample of setting environment variables:\n```bash\nexport WCD_TEST_URL='https://your-cluster-url.weaviate.network'\nexport WCD_TEST_KEY='your-api-key'\n```\n\nThis script provides a clean, modern approach to creating a Weaviate collection with the specified properties.",
      "stdout": "Deleting existing DemoProducts collection...\nAn error occurred: BOOLEAN\n",
      "stderr": "/code/code.py:11: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:18:20.566413",
      "duration": 8.63523268699646,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "Here's the Python code to create a Weaviate collection using the latest client syntax, connecting to Weaviate Cloud with environment variables:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv('WCD_TEST_URL'),\n    auth_credentials=Auth.api_key(os.getenv('WCD_TEST_KEY'))\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\n# Create the collection with specified properties\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n```\n\nThis code does the following:\n\n1. Imports the necessary Weaviate client libraries.\n2. Connects to Weaviate Cloud using environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n3. Checks if the \"DemoProducts\" collection already exists and deletes it if it does.\n4. Creates a new collection with the specified properties:\n   - `name` as a text property\n   - `description` as a text property\n   - `price` as a number property\n   - `in_stock` as a boolean property\n5. Prints the name of the created collection.\n6. Closes the client connection.\n\nMake sure to set the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables before running the script. You can do this in your shell or in a `.env` file:\n\n```bash\nexport WCD_TEST_URL='https://your-cluster-url.weaviate.network'\nexport WCD_TEST_KEY='your-api-key'\n```\n\nThis code uses the latest Weaviate client syntax and provides a clean way to create a collection with specific properties.",
      "stdout": "Created collection: DemoProducts\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:18:29.506903",
      "duration": 8.922995805740356,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to create a \"DemoProducts\" collection in Weaviate Cloud using the latest client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\n# Delete the collection if it already exists\nif client.collections.exists(\"DemoProducts\"):\n    client.collections.delete(\"DemoProducts\")\n\n# Create the DemoProducts collection\nclient.collections.create(\n    \"DemoProducts\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL)\n    ]\n)\n\n# Close the client connection\nclient.close()\n```\n\nThis code does the following:\n\n1. Imports the necessary Weaviate client modules\n2. Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n3. Checks if the \"DemoProducts\" collection already exists, and if so, deletes it\n4. Creates a new \"DemoProducts\" collection with the specified properties:\n   - `name` as a text property\n   - `description` as a text property\n   - `price` as a number property\n   - `in_stock` as a boolean property\n5. Closes the client connection\n\nMake sure to set the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables before running the script.",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:18:40.520366",
      "duration": 10.380707025527954,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Here's a Python script that accomplishes what you described using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nimport weaviate.classes as wvc\n\n# Read Weaviate Cloud credentials from environment variables\nWEAVIATE_URL = os.getenv('WCD_TEST_URL')\nWEAVIATE_API_KEY = os.getenv('WCD_TEST_KEY')\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_wcs(\n    cluster_url=WEAVIATE_URL,\n    auth_credentials=weaviate.AuthApiKey(api_key=WEAVIATE_API_KEY)\n)\n\ntry:\n    # Create the collection with specified properties\n    client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            wvc.Property(name=\"name\", data_type=wvc.DataType.TEXT),\n            wvc.Property(name=\"description\", data_type=wvc.DataType.TEXT)\n        ]\n    )\n\n    # Get the collection\n    products = client.collections.get(\"DemoProducts\")\n\n    # Batch import 50 objects\n    with products.batch as batch:\n        for i in range(50):\n            batch.add_object({\n                \"name\": f\"Product {i}\",\n                \"description\": f\"Description {i}\"\n            })\n\n    # Print the number of objects in the collection\n    object_count = products.aggregate.count()\n    print(f\"Number of objects in DemoProducts collection: {object_count}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis script does the following:\n\n1. Imports necessary libraries\n2. Reads Weaviate Cloud credentials from environment variables\n3. Connects to Weaviate Cloud using the provided URL and API key\n4. Creates a collection named \"DemoProducts\" with name and description properties\n5. Batch imports 50 objects into the collection\n6. Prints the number of objects in the collection\n7. Closes the client connection\n\nMake sure to set the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` before running the script.\n\nYou can set these in your terminal before running the script:\n```bash\nexport WCD_TEST_URL='your-weaviate-cloud-url'\nexport WCD_TEST_KEY='your-api-key'\n```\n\nOr you can set them directly in the script if you prefer.\n\nNote: This script uses the latest Weaviate client syntax (v4.x), which is different from previous versions. Make sure you have the latest version installed:\n\n```bash\npip install weaviate-client\n```",
      "stdout": "An error occurred: module 'weaviate.classes' has no attribute 'Property'\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:10: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:18:53.525799",
      "duration": 12.304467916488647,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Here's the Python code to accomplish the task using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=AuthApiKey(os.getenv(\"WCD_TEST_KEY\")),\n)\n\n# Create the collection if it doesn't exist\ntry:\n    # Define the collection schema\n    client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            weaviate.Property(name=\"name\", data_type=weaviate.DataType.TEXT),\n            weaviate.Property(name=\"description\", data_type=weaviate.DataType.TEXT)\n        ]\n    )\nexcept Exception as e:\n    print(f\"Collection might already exist: {e}\")\n\n# Get the collection\ncollection = client.collections.get(\"DemoProducts\")\n\n# Prepare batch import data\ndata_rows = [\n    {\n        \"name\": f\"Product {i}\",\n        \"description\": f\"Description {i}\"\n    } for i in range(50)\n]\n\n# Batch import objects\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(properties=data_row)\n        \n        # Optional: Handle potential batch import errors\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\n# Check for failed objects\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\n# Print the number of objects in the collection\nprint(f\"Number of objects in the collection: {len(collection)}\")\n\n# Close the client connection\nclient.close()\n```\n\nThis script does the following:\n\n1. Imports necessary libraries and uses environment variables for Weaviate Cloud connection.\n2. Connects to Weaviate Cloud using the URL and API key from environment variables.\n3. Creates the \"DemoProducts\" collection with \"name\" and \"description\" text properties.\n4. Prepares 50 sample objects with incrementing names and descriptions.\n5. Batch imports the objects using the dynamic batch method.\n6. Handles potential batch import errors.\n7. Prints the number of objects in the collection.\n8. Closes the client connection.\n\nMake sure to set the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` before running the script:\n\n```bash\nexport WCD_TEST_URL=\"your-weaviate-cloud-url\"\nexport WCD_TEST_KEY=\"your-api-key\"\n```\n\nNote: The exact syntax may vary slightly depending on the specific version of the Weaviate Python client you're using. Always refer to the most recent documentation for the most up-to-date syntax.",
      "stdout": "Collection might already exist: module weaviate has no attribute Property\nNumber of objects in the collection: 50\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:19:03.815190",
      "duration": 9.61159896850586,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to accomplish the task using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\n# Create the collection\nclient.collections.create(\n    \"DemoProducts\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT)\n    ]\n)\n\n# Get the collection\ncollection = client.collections.get(\"DemoProducts\")\n\n# Batch import 50 objects\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(50):\n        batch.add_object(\n            properties={\n                \"name\": f\"Product {i}\",\n                \"description\": f\"Description {i}\"\n            }\n        )\n\n# Print the number of objects in the collection\nobject_count = collection.aggregate.count()\nprint(f\"Number of objects in the collection: {object_count}\")\n\n# Close the client\nclient.close()\n```\n\nThis script does the following:\n\n1. Imports necessary modules from the Weaviate Python client\n2. Connects to Weaviate Cloud using environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n3. Creates a collection named \"DemoProducts\" with two text properties: \"name\" and \"description\"\n4. Uses a fixed-size batch to import 50 objects with simple incrementing names and descriptions\n5. Prints the total number of objects in the collection\n6. Closes the client connection\n\nMake sure to set the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` before running the script.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 13, in <module>\n    client.collections.create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/executor.py\", line 240, in create\n    return self.__create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/executor.py\", line 104, in __create\n    result = self._connection.post(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 822, in post\n    return self._send(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 716, in _send\n    return executor.execute(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/executor.py\", line 99, in execute\n    return cast(T, exception_callback(e))\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 714, in exc\n    self.__handle_exceptions(e, error_msg)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 670, in __handle_exceptions\n    raise e\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/executor.py\", line 95, in execute\n    resp_call = response_callback(call)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 711, in resp\n    return self.__handle_response(res, error_msg, status_codes)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 681, in __handle_response\n    raise UnexpectedStatusCodeError(error_msg, response)\nweaviate.exceptions.UnexpectedStatusCodeError: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'class name DemoProducts already exists'}]}.\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 51022), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:19:12.988986",
      "duration": 8.670630931854248,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's a Python script that accomplishes the task using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nimport weaviate.classes as wvc\n\n# Set up Weaviate client connection\nclient = weaviate.connect_to_wcs(\n    cluster_url=os.getenv('WCD_TEST_URL'),\n    auth_credentials=weaviate.auth.AuthApiKey(os.getenv('WCD_TEST_KEY')),\n    headers={\n        \"X-OpenAI-Api-Key\": os.getenv('OPENAI_API_KEY')\n    }\n)\n\ntry:\n    # Perform vector search on WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Perform hybrid search for \"dessert wine\"\n    results = wine_collection.query.hybrid(\n        query=\"dessert wine\",\n        limit=2\n    )\n    \n    # Print details of matching wines\n    for wine in results.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: {wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(\"---\")\n\nfinally:\n    # Always close the client connection\n    client.close()\n```\n\nThis script does the following:\n\n1. Imports necessary libraries\n2. Connects to Weaviate Cloud using environment variables\n3. Uses hybrid search to find wines matching \"dessert wine\"\n4. Limits results to 2 wines\n5. Prints details of each matching wine\n6. Ensures the client connection is closed\n\nMake sure to set the environment variables `WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY` before running the script.",
      "stdout": "Title: Schmitz 24 Brix 2012 Sauvignon Blanc (Sierra Foothills)\nCountry: US\nPrice: 22.0\nPoints: 85\n---\nTitle: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n---\n",
      "stderr": "/code/code.py:6: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:19:21.935422",
      "duration": 8.550546884536743,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "Here's the Python code to query the 'WineReview' collection for dessert wines using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv('WCD_TEST_URL'),\n    auth_credentials=Auth.api_key(os.getenv('WCD_TEST_KEY')),\n    headers={\n        \"X-OpenAI-API-Key\": os.getenv('OPENAI_API_KEY')\n    }\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform near_text search for \"dessert wine\"\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2\n)\n\n# Print details of matching wines\nfor obj in response.objects:\n    print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n    print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n    print(f\"Price: {obj.properties.get('price', 'N/A')}\")\n    print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n    print(\"---\")\n\n# Close the client connection\nclient.close()\n```\n\nThis script does the following:\n\n1. Imports the necessary Weaviate libraries\n2. Connects to Weaviate Cloud using environment variables\n3. Retrieves the 'WineReview' collection\n4. Performs a near_text search for \"dessert wine\" with a limit of 2 results\n5. Prints the title, country, price, and points for each matching wine\n6. Closes the client connection\n\nMake sure to set the following environment variables before running:\n- `WCD_TEST_URL`: Weaviate Cloud instance URL\n- `WCD_TEST_KEY`: Weaviate Cloud API key\n- `OPENAI_API_KEY`: OpenAI API key for the text2vec-openai vectorizer",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n---\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n---\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:19:33.247985",
      "duration": 10.84282922744751,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to query the 'WineReview' collection for dessert wines using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n\n    # Perform near_text search for \"dessert wine\"\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2\n    )\n\n    # Print details for each matching wine\n    for wine in response.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: {wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(\"---\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. Imports necessary libraries and modules\n2. Connects to Weaviate Cloud using environment variables\n3. Gets the WineReview collection\n4. Performs a semantic search for \"dessert wine\" with a limit of 2 results\n5. Prints the title, country, price, and points for each matching wine\n6. Ensures the client connection is closed\n\nMake sure to set the following environment variables before running:\n- `WCD_TEST_URL`: Weaviate Cloud instance URL\n- `WCD_TEST_KEY`: Weaviate Cloud API key\n- `OPENAI_API_KEY`: OpenAI API key for the text2vec-openai vectorizer",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n---\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n---\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:19:45.257105",
      "duration": 11.622211217880249,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's a Python script that meets your requirements:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import HybridSearchOptions\n\ndef main():\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_wcs(\n        cluster_url=os.getenv('WCD_TEST_URL'),\n        auth_credentials=os.getenv('WCD_TEST_KEY'),\n        headers={\n            \"X-OpenAI-Api-Key\": os.getenv('OPENAI_API_KEY')\n        }\n    )\n\n    try:\n        # Query the WineReview collection\n        wine_reviews = client.collections.get(\"WineReview\")\n        \n        results = wine_reviews.query.hybrid(\n            query=\"pair with steak\",\n            hybrid_search_options=HybridSearchOptions(alpha=0.5),\n            filters=wine_reviews.query.filter.where(\n                # Price less than 50\n                path=[\"price\"],\n                operator=\"LessThan\",\n                value=50\n            ).and_filter(\n                # Points greater than 90\n                path=[\"points\"],\n                operator=\"GreaterThan\", \n                value=90\n            ),\n            limit=5\n        )\n\n        # Filter results to include specific substrings in review_body\n        matching_wines = [\n            result for result in results.objects \n            if any(substring in result.properties['review_body'].lower() \n                   for substring in ['spice', 'fruit', 'berry', 'cherry', 'honey'])\n        ]\n\n        # Print matching wines\n        for wine in matching_wines:\n            print(f\"Title: {wine.properties['title']}\")\n            print(f\"Country: {wine.properties['country']}\")\n            print(f\"Price: ${wine.properties['price']}\")\n            print(f\"Points: {wine.properties['points']}\")\n            print(\"---\")\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n    \n    finally:\n        # Close the client connection\n        client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nThis script does the following:\n\n1. Connects to Weaviate Cloud using environment variables\n2. Uses the latest Weaviate client syntax (v4+)\n3. Performs a hybrid search with alpha=0.5\n4. Applies filters for price < 50 and points > 90\n5. Limits results to 5\n6. Filters results to include wines with specific substrings in the review body\n7. Prints title, country, price, and points for matching wines\n\nMake sure to set the following environment variables before running:\n- `WCD_TEST_URL`\n- `WCD_TEST_KEY`\n- `OPENAI_API_KEY`\n\nNote: The exact field names (like 'title', 'country', etc.) should match your actual Weaviate schema.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 3, in <module>\n    from weaviate.classes.query import HybridSearchOptions\nImportError: cannot import name 'HybridSearchOptions' from 'weaviate.classes.query' (/usr/local/lib/python3.9/site-packages/weaviate/classes/query.py)\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:19:54.587145",
      "duration": 8.900651931762695,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "Here's the Python code that matches your requirements:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv('WCD_TEST_URL'),\n    auth_credentials=Auth.api_key(os.getenv('WCD_TEST_KEY')),\n    headers={\n        \"X-OpenAI-API-Key\": os.getenv('OPENAI_API_KEY')\n    }\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform hybrid search with specified conditions\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    )\n)\n\n# Print matching wines\nfor wine in response.objects:\n    print(f\"Title: {wine.properties['title']}\")\n    print(f\"Country: {wine.properties['country']}\")\n    print(f\"Price: ${wine.properties['price']}\")\n    print(f\"Points: {wine.properties['points']}\")\n    print(\"---\")\n\n# Close the client connection\nclient.close()\n```\n\nThis script does the following:\n\n1. Imports necessary Weaviate libraries\n2. Connects to Weaviate Cloud using environment variables\n3. Retrieves the WineReview collection\n4. Performs a hybrid search with:\n   - Query: \"pair with steak\"\n   - Limit: 5 results\n   - Alpha: 0.5\n   - Filters:\n     * Price less than $50\n     * Points greater than 90\n     * Review body contains one of: \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n5. Prints the title, country, price, and points of each matching wine\n6. Closes the client connection\n\nMake sure to set the following environment variables before running:\n- `WCD_TEST_URL`\n- `WCD_TEST_KEY`\n- `OPENAI_API_KEY`",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.0\nPoints: 92\n---\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.0\nPoints: 91\n---\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.0\nPoints: 91\n---\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.0\nPoints: 93\n---\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: $0.0\nPoints: 92\n---\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:20:08.606191",
      "duration": 13.610887289047241,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to query the 'WineReview' collection with the specified requirements:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, HybridFusion\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\n# Get the WineReview collection\nwine_collection = client.collections.get(\"WineReview\")\n\ntry:\n    # Perform hybrid search with complex filtering\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,  # Balance between semantic and keyword search\n        fusion_type=HybridFusion.RELATIVE_SCORE,\n        filters=(\n            Filter.by_property(\"price\").less_than(50) &\n            Filter.by_property(\"points\").greater_than(90) &\n            (\n                Filter.by_property(\"review_body\").contains_any([\n                    \"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"\n                ])\n            )\n        ),\n        limit=5\n    )\n\n    # Print results\n    for wine in response.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: ${wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(\"---\")\n\nfinally:\n    # Always close the client\n    client.close()\n```\n\nThis code does the following:\n\n1. Connects to Weaviate Cloud using environment variables for the URL, API key, and OpenAI API key.\n2. Retrieves the WineReview collection.\n3. Performs a hybrid search with:\n   - Query \"pair with steak\"\n   - Alpha of 0.5 (balanced semantic and keyword search)\n   - Filters for:\n     - Price less than $50\n     - Points greater than 90\n     - Review body containing at least one of: \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n   - Limit of 5 results\n4. Prints the title, country, price, and points for each matching wine.\n5. Ensures the client is closed after the operation.\n\nMake sure to set the following environment variables before running:\n- `WCD_TEST_URL`: Weaviate Cloud instance URL\n- `WCD_TEST_KEY`: Weaviate Cloud API key\n- `OPENAI_API_KEY`: OpenAI API key for the text2vec-openai vectorizer",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.0\nPoints: 92\n---\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.0\nPoints: 91\n---\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.0\nPoints: 91\n---\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.0\nPoints: 93\n---\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: $0.0\nPoints: 92\n---\n",
      "stderr": "",
      "exit_code": 0
    }
  },
  "openai/gpt-4.1-mini-2025-04-14": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T22:20:11.067869",
      "duration": 2.443779945373535,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get environment variables\nurl = os.getenv(\"WCD_TEST_URL\")\napi_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Create Weaviate client with API key authentication\nclient = weaviate.Client(\n    url=url,\n    auth_client_secret=weaviate.AuthApiKey(api_key),\n)\n\n# Check if the server is ready\nif client.is_ready():\n    print(\"Weaviate server is ready to accept requests.\")\nelse:\n    print(\"Weaviate server is not ready.\")\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:9: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 9, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:20:13.717780",
      "duration": 2.631645917892456,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Read environment variables\ncluster_url = os.environ[\"WCD_TEST_URL\"]\napi_key = os.environ[\"WCD_TEST_KEY\"]\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Check if the server is ready\nassert client.is_ready()\n\nclient.close()\n```",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:20:17.295189",
      "duration": 3.556969165802002,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set\")\n\n# Create Weaviate client with API key authentication\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": WCD_TEST_KEY  # sometimes needed if using OpenAI module, else can omit\n    }\n)\n\nclass_name = \"DemoProducts\"\n\n# Delete class if it exists\nif client.schema.contains(class_name):\n    client.schema.delete_class(class_name)\n\n# Define the schema for the class\ndemo_products_class = {\n    \"class\": class_name,\n    \"properties\": [\n        {\n            \"name\": \"name\",\n            \"dataType\": [\"text\"],\n        },\n        {\n            \"name\": \"description\",\n            \"dataType\": [\"text\"],\n        },\n        {\n            \"name\": \"price\",\n            \"dataType\": [\"number\"],\n        },\n        {\n            \"name\": \"in_stock\",\n            \"dataType\": [\"boolean\"],\n        },\n    ],\n}\n\n# Create the class\nclient.schema.create_class(demo_products_class)\n\nprint(f\"Class '{class_name}' created successfully.\")\n```\n",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:12: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 12, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:20:21.496464",
      "duration": 4.183395862579346,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Read environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY)\n)\n\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\n# Create the collection with the specified properties\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n```",
      "stdout": "Created collection: DemoProducts\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:20:26.545188",
      "duration": 5.03062891960144,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\ndef main():\n    # Connect to Weaviate Cloud using environment variables\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    )\n\n    collection_name = \"DemoProducts\"\n\n    # If the collection exists, delete it first\n    if client.collections.exists(collection_name):\n        client.collections.delete(collection_name)\n\n    # Create the collection with specified properties\n    client.collections.create(\n        collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ],\n        # Optionally, you can specify a vectorizer here, e.g.:\n        # vector_config=Configure.Vectors.text2vec_weaviate()\n    )\n\n    print(f\"Collection '{collection_name}' created successfully.\")\n\n    # Close the client connection when done\n    client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\nThis script:\n- Connects to Weaviate Cloud using `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables.\n- Checks if the collection \"DemoProducts\" exists and deletes it if so.\n- Creates the \"DemoProducts\" collection with the requested properties.\n- Closes the client connection at the end.\n\nFor more details on collection management, see the official docs:  \nhttps://docs.weaviate.io/weaviate/manage-data/collections  \nand the Python client library page:  \nhttps://docs.weaviate.io/weaviate/client-libraries/python",
      "stdout": "Collection 'DemoProducts' created successfully.\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:20:33.103172",
      "duration": 5.936992168426514,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": WCD_TEST_KEY  # sometimes needed for OpenAI modules, but optional here\n    }\n)\n\n# Define the schema for the \"DemoProducts\" class\nschema_class = {\n    \"class\": \"DemoProducts\",\n    \"description\": \"A collection of demo products\",\n    \"properties\": [\n        {\n            \"name\": \"name\",\n            \"dataType\": [\"text\"],\n            \"description\": \"Name of the product\"\n        },\n        {\n            \"name\": \"description\",\n            \"dataType\": [\"text\"],\n            \"description\": \"Description of the product\"\n        }\n    ]\n}\n\n# Check if class exists, if not create it\nif \"DemoProducts\" not in [c[\"class\"] for c in client.schema.get()[\"classes\"]]:\n    client.schema.create_class(schema_class)\n\n# Prepare batch import\nwith client.batch as batch:\n    batch.batch_size = 20  # batch size can be tuned\n    for i in range(1, 51):\n        obj = {\n            \"name\": f\"Product {i}\",\n            \"description\": f\"Description {i}\"\n        }\n        batch.add_data_object(obj, \"DemoProducts\")\n\n# Count objects in the class\nresult = client.query.aggregate(\"DemoProducts\").with_meta_count().do()\ncount = result.get(\"data\", {}).get(\"Aggregate\", {}).get(\"DemoProducts\", [{}])[0].get(\"meta\", {}).get(\"count\", 0)\n\nprint(f\"Number of objects in 'DemoProducts': {count}\")\n```\n",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:12: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 12, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:20:41.594656",
      "duration": 7.812525033950806,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\ndef main():\n    # Read environment variables\n    WCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\n    WCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n    if not WCD_TEST_URL or not WCD_TEST_KEY:\n        raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set\")\n\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=AuthApiKey(api_key=WCD_TEST_KEY),\n    )\n\n    # Get the collection (class) \"DemoProducts\"\n    collection = client.collections.get(\"DemoProducts\")\n\n    # Prepare 50 arbitrary objects\n    data_rows = [\n        {\n            \"name\": f\"Product {i}\",\n            \"description\": f\"Description {i}\"\n        }\n        for i in range(1, 51)\n    ]\n\n    # Batch import objects\n    with collection.batch.dynamic() as batch:\n        for data_row in data_rows:\n            batch.add_object(properties=data_row)\n            if batch.number_errors > 10:\n                print(\"Batch import stopped due to excessive errors.\")\n                break\n\n    # Check for failed objects\n    failed_objects = collection.batch.failed_objects\n    if failed_objects:\n        print(f\"Number of failed imports: {len(failed_objects)}\")\n        print(f\"First failed object: {failed_objects[0]}\")\n\n    # Print number of objects in the collection\n    print(f\"Number of objects in 'DemoProducts': {len(collection)}\")\n\n    client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n",
      "stdout": "Number of objects in 'DemoProducts': 50\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:20:50.634212",
      "duration": 8.354863166809082,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Configure, Property, DataType\n\ndef main():\n    # Connect to Weaviate Cloud using environment variables\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=weaviate.classes.init.Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    )\n\n    collection_name = \"DemoProducts\"\n\n    # Check if collection exists, delete if it does (optional, to start fresh)\n    if client.collections.exists(collection_name):\n        client.collections.delete(collection_name)\n\n    # Create collection with properties: name (text), description (text)\n    client.collections.create(\n        collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ],\n        # Use a vectorizer suitable for text (recommended for Weaviate Cloud)\n        vector_config=Configure.Vectors.text2vec_weaviate()\n    )\n\n    # Get the collection object\n    collection = client.collections.get(collection_name)\n\n    # Batch import 50 arbitrary objects\n    with collection.batch.fixed_size(batch_size=50) as batch:\n        for i in range(50):\n            batch.add_object(\n                properties={\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"Description {i}\"\n                }\n            )\n\n    # Print the number of objects in the collection\n    # Use the iterator to count objects\n    count = sum(1 for _ in collection.iterator())\n    print(f\"Number of objects in collection '{collection_name}': {count}\")\n\n    # Close client connection\n    client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n---\n\n### Explanation:\n\n- Connects to Weaviate Cloud using `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables.\n- Creates a collection named `\"DemoProducts\"` with two text properties: `\"name\"` and `\"description\"`.\n- Uses the `text2vec_weaviate` vectorizer (recommended for Weaviate Cloud).\n- Batch imports 50 objects with simple properties.\n- Counts and prints the number of objects in the collection using the iterator.\n- Closes the client connection at the end.\n\n---\n\n### References:\n\n- [Weaviate Python Client docs](https://docs.weaviate.io/weaviate/client-libraries/python)\n- [How to batch import data](https://docs.weaviate.io/weaviate/manage-data/import)\n- [How to manage collections](https://docs.weaviate.io/weaviate/manage-data/collections)",
      "stdout": "Number of objects in collection 'DemoProducts': 50\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T22:20:55.383092",
      "duration": 4.290410995483398,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Load environment variables\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\nOPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\n\n# Initialize Weaviate client with authentication\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": OPENAI_API_KEY\n    }\n)\n\n# Define the query string\nquery_text = \"dessert wine\"\n\n# Perform a vector search using the text2vec-openai vectorizer\nresponse = (\n    client.query.get(\"WineReview\", [\"title\", \"country\", \"price\", \"points\"])\n    .with_near_text({\"concepts\": [query_text]})\n    .with_limit(2)\n    .do()\n)\n\n# Extract and print results\nfor wine in response.get(\"data\", {}).get(\"Get\", {}).get(\"WineReview\", []):\n    title = wine.get(\"title\")\n    country = wine.get(\"country\")\n    price = wine.get(\"price\")\n    points = wine.get(\"points\")\n    print(f\"Title: {title}, Country: {country}, Price: {price}, Points: {points}\")\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:10: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 10, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:21:01.369144",
      "duration": 5.595238924026489,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Load environment variables\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\nOPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    headers={\n        \"X-OpenAI-API-Key\": OPENAI_API_KEY\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Query for wines best matching \"dessert wine\" with limit 2\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2\n)\n\n# Print title, country, price, and points of each matching wine\nfor obj in response.objects:\n    props = obj.properties\n    print(\n        f\"Title: {props.get('title')}, \"\n        f\"Country: {props.get('country')}, \"\n        f\"Price: {props.get('price')}, \"\n        f\"Points: {props.get('points')}\"\n    )\n\nclient.close()\n```",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA)), Country: US, Price: 24.0, Points: 88\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast), Country: US, Price: 40.0, Points: 88\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:21:08.000258",
      "duration": 6.217645168304443,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\ndef main():\n    # Connect to Weaviate Cloud using environment variables\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\n            \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n        }\n    )\n\n    # Get the WineReview collection\n    collection = client.collections.get(\"WineReview\")\n\n    # Perform a semantic search with near_text for \"dessert wine\"\n    response = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # Print the results\n    for obj in response.objects:\n        props = obj.properties\n        print(f\"Title: {props.get('title', 'N/A')}\")\n        print(f\"Country: {props.get('country', 'N/A')}\")\n        print(f\"Price: {props.get('price', 'N/A')}\")\n        print(f\"Points: {props.get('points', 'N/A')}\")\n        print(\"-\" * 40)\n\n    # Close the client connection\n    client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\nThis code uses the latest Weaviate Python client syntax (v4.x) to connect to your Weaviate Cloud instance, queries the `WineReview` collection using the `near_text` semantic search with the query `\"dessert wine\"`, limits the results to 2, and prints the requested properties.\n\nFor more details on querying with the Python client, see the official docs:  \nhttps://weaviate.io/developers/weaviate/current/client-libraries/python.html#search-operations",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:21:17.620697",
      "duration": 9.228949785232544,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Load environment variables\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\nOPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\n\n# Initialize Weaviate client with API key authentication\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": OPENAI_API_KEY\n    }\n)\n\n# Define the query string\nquery_text = \"pair with steak\"\n\n# Define the filter for price < 50 and points > 90\nfilter_obj = {\n    \"operator\": \"And\",\n    \"operands\": [\n        {\n            \"path\": [\"price\"],\n            \"operator\": \"LessThan\",\n            \"valueInt\": 50\n        },\n        {\n            \"path\": [\"points\"],\n            \"operator\": \"GreaterThan\",\n            \"valueInt\": 90\n        }\n    ]\n}\n\n# Define the filter for review_body containing at least one of the substrings\n# Since Weaviate filters do not support \"contains substring\" natively,\n# we use the \"Like\" operator with wildcards for each substring and combine with \"Or\"\nreview_body_substrings = [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\nreview_body_filters = [\n    {\n        \"path\": [\"review_body\"],\n        \"operator\": \"Like\",\n        \"valueString\": f\"*{substr}*\"\n    }\n    for substr in review_body_substrings\n]\n\n# Combine the review_body substring filters with OR\nreview_body_filter_obj = {\n    \"operator\": \"Or\",\n    \"operands\": review_body_filters\n}\n\n# Combine all filters: price & points AND (review_body substrings)\ncombined_filter = {\n    \"operator\": \"And\",\n    \"operands\": [\n        filter_obj,\n        review_body_filter_obj\n    ]\n}\n\n# Perform the hybrid query\nresult = (\n    client.query\n    .get(\"WineReview\", [\"title\", \"country\", \"price\", \"points\"])\n    .with_hybrid(query_text, alpha=0.5)\n    .with_limit(5)\n    .with_where(combined_filter)\n    .do()\n)\n\n# Extract and print results\nfor wine in result.get(\"data\", {}).get(\"Get\", {}).get(\"WineReview\", []):\n    title = wine.get(\"title\", \"N/A\")\n    country = wine.get(\"country\", \"N/A\")\n    price = wine.get(\"price\", \"N/A\")\n    points = wine.get(\"points\", \"N/A\")\n    print(f\"Title: {title}, Country: {country}, Price: {price}, Points: {points}\")\n```\n",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:10: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 10, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:21:27.932962",
      "duration": 9.844936847686768,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\n\n# Read environment variables\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\nOPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    headers={\n        \"X-OpenAI-API-Key\": OPENAI_API_KEY\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Build the filter:\n# price < 50 AND points > 90 AND review_body contains any of the substrings\nfilter_ = (\n    Filter.by_property(\"price\").less_than(50) &\n    Filter.by_property(\"points\").greater_than(90) &\n    Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n)\n\n# Perform the hybrid query\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    filters=filter_,\n    return_metadata=MetadataQuery(score=True)\n)\n\n# Print the requested fields for each result\nfor obj in response.objects:\n    props = obj.properties\n    title = props.get(\"title\", \"<no title>\")\n    country = props.get(\"country\", \"<no country>\")\n    price = props.get(\"price\", \"<no price>\")\n    points = props.get(\"points\", \"<no points>\")\n    print(f\"Title: {title}, Country: {country}, Price: {price}, Points: {points}\")\n\nclient.close()\n```",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir, Country: US, Price: 40.0, Points: 92\nTitle: Bink 2014 Pinot Noir (Anderson Valley), Country: US, Price: 49.0, Points: 91\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza), Country: Argentina, Price: 27.0, Points: 91\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji), Country: Hungary, Price: 25.0, Points: 93\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico), Country: Italy, Price: 0.0, Points: 92\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:21:39.413166",
      "duration": 11.038836240768433,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import Filter\n\n# Connect to Weaviate Cloud with API key and OpenAI key in headers\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.classes.init.Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Build the filter:\n# price < 50 AND points > 90 AND review_body contains at least one of the substrings\n# \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n# We use Filter.any_of for the substrings on review_body with .like(\"*substring*\")\n\nprice_filter = Filter.by_property(\"price\").less_than(50)\npoints_filter = Filter.by_property(\"points\").greater_than(90)\nreview_body_substrings_filter = Filter.any_of(\n    filters=[\n        Filter.by_property(\"review_body\").like(\"*spice*\"),\n        Filter.by_property(\"review_body\").like(\"*fruit*\"),\n        Filter.by_property(\"review_body\").like(\"*berry*\"),\n        Filter.by_property(\"review_body\").like(\"*cherry*\"),\n        Filter.by_property(\"review_body\").like(\"*honey*\"),\n    ]\n)\n\ncombined_filter = Filter.all_of(\n    filters=[\n        price_filter,\n        points_filter,\n        review_body_substrings_filter,\n    ]\n)\n\n# Perform hybrid search with alpha=0.5, limit=5, with the filter applied\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    alpha=0.5,\n    limit=5,\n    filters=combined_filter,\n    return_properties=[\"title\", \"country\", \"price\", \"points\"]\n)\n\n# Print the results\nfor obj in response.objects:\n    props = obj.properties\n    print(f\"Title: {props.get('title')}\")\n    print(f\"Country: {props.get('country')}\")\n    print(f\"Price: {props.get('price')}\")\n    print(f\"Points: {props.get('points')}\")\n    print(\"-\" * 40)\n\n# Close client when done\nclient.close()\n```\nThis code uses the latest Weaviate Python client syntax (v4.x), connects to your Weaviate Cloud instance using environment variables, performs a hybrid search with the specified alpha and filters, and prints the requested properties for each matching wine.  \nIf you want to learn more about filters and hybrid queries, see the official docs:  \nhttps://weaviate.io/developers/weaviate/current/client-libraries/python.html#search-with-filters  \nhttps://weaviate.io/developers/weaviate/current/client-libraries/python.html#hybrid-search",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: 40.0\nPoints: 92\n----------------------------------------\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: 49.0\nPoints: 91\n----------------------------------------\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: 27.0\nPoints: 91\n----------------------------------------\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: 25.0\nPoints: 93\n----------------------------------------\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: 0.0\nPoints: 92\n----------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    }
  },
  "cohere/command-a-03-2025": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T22:21:44.054854",
      "duration": 4.622228145599365,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to connect to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, and then check if the server is ready to accept requests:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.exceptions import WeaviateConnectionError\n\n# Retrieve environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set.\")\n\n# Initialize the Weaviate client with API key authentication\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n)\n\n# Check if the server is ready\ntry:\n    if client.is_ready():\n        print(\"Weaviate server is ready to accept requests.\")\n    else:\n        print(\"Weaviate server is not ready.\")\nexcept WeaviateConnectionError as e:\n    print(f\"Failed to connect to Weaviate: {e}\")\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves `WCD_TEST_URL` and `WCD_TEST_KEY` from the environment using `os.getenv()`.\n2. **Client Initialization**: The Weaviate client is initialized with the provided URL and API key using `auth_client_secret`.\n3. **Server Readiness Check**: The `client.is_ready()` method checks if the Weaviate server is ready to accept requests. If there's a connection error, it's caught and printed.\n\nMake sure you have the `weaviate-client` Python package installed. You can install it using:\n\n```bash\npip install weaviate-client\n```\n\nThis code does exactly what you asked: connects to Weaviate Cloud and checks if the server is ready, without performing any additional actions.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:14: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 14, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:21:47.986353",
      "duration": 3.9135470390319824,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to connect to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, and then check if the server is ready to accept requests:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Retrieve environment variables\ncluster_url = os.getenv(\"WCD_TEST_URL\")\napi_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not cluster_url or not api_key:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set.\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Check if the server is ready\nassert client.is_ready(), \"Weaviate server is not ready.\"\n\n# Close the client connection\nclient.close()\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the `WCD_TEST_URL` and `WCD_TEST_KEY` from the environment using `os.getenv()`.\n2. **Error Handling**: It checks if the environment variables are set and raises an error if they are missing.\n3. **Connection**: It connects to the Weaviate Cloud instance using `weaviate.connect_to_weaviate_cloud()` with the provided URL and API key.\n4. **Readiness Check**: It verifies that the server is ready using `client.is_ready()` and asserts the result.\n5. **Cleanup**: Finally, it closes the client connection with `client.close()`.\n\nThis code ensures a clean and efficient connection to Weaviate Cloud and verifies its readiness.",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:21:52.880827",
      "duration": 4.876481056213379,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to create a collection named \"DemoProducts\" with the specified properties. The code also handles the case where the collection already exists by deleting it first. The code uses environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` to connect to Weaviate Cloud.\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Client\nfrom weaviate.util import get_valid_uuid\n\n# Retrieve environment variables\nWEAVIATE_URL = os.getenv(\"WCD_TEST_URL\")\nWEAVIATE_API_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n# Initialize the Weaviate client\nclient = Client(\n    url=WEAVIATE_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WEAVIATE_API_KEY),\n)\n\n# Define the collection name\nCOLLECTION_NAME = \"DemoProducts\"\n\n# Check if the collection already exists and delete it if it does\nif client.schema.exists(COLLECTION_NAME):\n    client.schema.delete_class(COLLECTION_NAME)\n    print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n\n# Define the schema for the collection\nschema = {\n    \"classes\": [\n        {\n            \"class\": COLLECTION_NAME,\n            \"description\": \"A collection of demo products\",\n            \"properties\": [\n                {\n                    \"name\": \"name\",\n                    \"dataType\": [\"text\"],\n                    \"description\": \"The name of the product\",\n                },\n                {\n                    \"name\": \"description\",\n                    \"dataType\": [\"text\"],\n                    \"description\": \"The description of the product\",\n                },\n                {\n                    \"name\": \"price\",\n                    \"dataType\": [\"number\"],\n                    \"description\": \"The price of the product\",\n                },\n                {\n                    \"name\": \"in_stock\",\n                    \"dataType\": [\"boolean\"],\n                    \"description\": \"Whether the product is in stock\",\n                },\n            ],\n        }\n    ]\n}\n\n# Create the collection\nclient.schema.create(schema)\nprint(f\"Collection '{COLLECTION_NAME}' created successfully.\")\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the Weaviate Cloud URL and API key from the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n2. **Weaviate Client**: The client is initialized with the provided URL and API key.\n3. **Collection Existence Check**: The code checks if the collection `DemoProducts` already exists. If it does, the collection is deleted.\n4. **Schema Definition**: The schema for the `DemoProducts` collection is defined with the specified properties (`name`, `description`, `price`, `in_stock`).\n5. **Collection Creation**: The schema is created using `client.schema.create()`, and a success message is printed.\n\nMake sure the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` are set before running the script.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:11: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 11, in <module>\n    client = Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:21:57.746243",
      "duration": 4.847910165786743,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to create a collection named `\"DemoProducts\"` with the specified properties. The code connects to Weaviate Cloud using environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`. If the collection already exists, it deletes it first.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Retrieve environment variables for Weaviate Cloud connection\nCLUSTER_URL = os.getenv(\"WCD_TEST_URL\")\nAPI_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not CLUSTER_URL or not API_KEY:\n    raise ValueError(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set.\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=CLUSTER_URL,\n    auth_credentials=Auth.api_key(API_KEY)\n)\n\n# Define the collection name\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n    print(f\"Deleted existing collection: {collection_name}\")\n\n# Create the collection with the specified properties\nproducts_collection = client.collections.create(\n    name=collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close the connection\nclient.close()\n```\n\n### Key Points:\n1. **Environment Variables**: The code retrieves the Weaviate Cloud URL and API key from environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n2. **Collection Deletion**: If the collection `\"DemoProducts\"` already exists, it is deleted before creating a new one.\n3. **Properties**: The collection is created with the specified properties: `name`, `description`, `price`, and `in_stock`.\n4. **Connection Closure**: The connection to Weaviate Cloud is closed after the operation is complete.\n\nMake sure the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` are properly set in your environment before running the script.",
      "stdout": "Deleted existing collection: DemoProducts\n",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 35, in <module>\n    Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n  File \"/usr/local/lib/python3.9/enum.py\", line 429, in __getattr__\n    raise AttributeError(name) from None\nAttributeError: BOOLEAN\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 36944), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "extensive_examples_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:22:02.973498",
      "duration": 5.208024740219116,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here\u2019s the Python code to create a collection named \"DemoProducts\" with the specified properties, using the latest Weaviate client syntax. The code connects to Weaviate Cloud using environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, and deletes the collection if it already exists.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Configure, Property, DataType\nfrom weaviate.classes.init import Auth\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n)\n\n# Define the collection name\ncollection_name = \"DemoProducts\"\n\n# Check if the collection exists and delete it if necessary\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\n# Create the collection with the specified properties\nclient.collections.create(\n    name=collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n    ]\n)\n\n# Close the client connection\nclient.close()\n```\n\n### Explanation:\n1. **Environment Variables**: The code uses `os.environ` to access the Weaviate Cloud URL (`WCD_TEST_URL`) and API key (`WCD_TEST_KEY`).\n2. **Collection Existence Check**: Before creating the collection, the code checks if it already exists using `client.collections.exists()`. If it does, the collection is deleted using `client.collections.delete()`.\n3. **Collection Creation**: The `client.collections.create()` method is used to create the \"DemoProducts\" collection with the specified properties:\n   - `name`: Text property\n   - `description`: Text property\n   - `price`: Number property\n   - `in_stock`: Boolean property\n4. **Connection Closure**: The `client.close()` method ensures the connection to Weaviate is properly closed after the operation.\n\nThis code ensures the collection is created with the correct schema, and any existing collection with the same name is deleted first.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 26, in <module>\n    Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n  File \"/usr/local/lib/python3.9/enum.py\", line 429, in __getattr__\n    raise AttributeError(name) from None\nAttributeError: BOOLEAN\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 57706), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:22:08.296355",
      "duration": 4.612364053726196,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Below is the Python code that uses the latest Weaviate client syntax to achieve the task you described. The code connects to Weaviate Cloud using the provided environment variables, creates a collection named \"DemoProducts\", batch imports 50 arbitrary objects, and finally prints the number of objects in the collection.\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Client\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.collections.classes.batch import BatchObject\n\n# Connect to Weaviate Cloud using environment variables\nWEAVIATE_URL = os.getenv(\"WCD_TEST_URL\")\nWEAVIATE_API_KEY = os.getenv(\"WCD_TEST_KEY\")\n\nclient = Client(\n    url=WEAVIATE_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WEAVIATE_API_KEY),\n)\n\n# Define the collection schema\ncollection_name = \"DemoProducts\"\ntry:\n    client.collections.delete(collection_name)\nexcept:\n    pass\n\ndemo_products = client.collections.create(\n    name=collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n    ],\n)\n\n# Prepare batch objects\nbatch_objects = []\nfor i in range(50):\n    obj = BatchObject(\n        properties={\n            \"name\": f\"Product {i}\",\n            \"description\": f\"Description {i}\",\n        }\n    )\n    batch_objects.append(obj)\n\n# Batch import objects\nwith demo_products.batch.dynamic() as batch:\n    batch.add_objects(batch_objects)\n\n# Print the number of objects in the collection\nobject_count = demo_products.count()\nprint(f\"Number of objects in the '{collection_name}' collection: {object_count}\")\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the Weaviate Cloud URL and API key from the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`.\n\n2. **Collection Creation**: It defines a collection named \"DemoProducts\" with two properties: `name` and `description`, both of type `TEXT`.\n\n3. **Batch Import**: It generates 50 arbitrary objects and imports them into the collection using batch operations for efficiency.\n\n4. **Object Count**: Finally, it retrieves and prints the total number of objects in the collection.\n\nMake sure the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` are set before running the script.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:11: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 11, in <module>\n    client = Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:22:14.489774",
      "duration": 5.514342308044434,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to achieve the task you described. The code connects to Weaviate Cloud using environment variables, creates a collection named \"DemoProducts\" with the specified properties, batch imports 50 arbitrary objects, and then prints the number of objects in the collection.\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Auth\n\n# Retrieve Weaviate Cloud credentials from environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_wcs(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\", \"\")  # Optional: for hybrid search\n    }\n)\n\n# Define the collection schema\ncollection_name = \"DemoProducts\"\nclient.collections.create(\n    name=collection_name,\n    properties=[\n        {\n            \"name\": \"name\",\n            \"dataType\": [\"text\"],\n            \"description\": \"Product name\"\n        },\n        {\n            \"name\": \"description\",\n            \"dataType\": [\"text\"],\n            \"description\": \"Product description\"\n        }\n    ]\n)\n\n# Generate 50 arbitrary objects\ndata_rows = [\n    {\n        \"name\": f\"Product {i}\",\n        \"description\": f\"Description {i}\"\n    } for i in range(50)\n]\n\n# Batch import objects into the collection\ncollection = client.collections.get(collection_name)\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.failed_objects:\n            print(f\"Failed to import object: {batch.failed_objects[-1]}\")\n            break\n\n# Print the number of objects in the collection\nobject_count = collection.aggregate.over_all().total_count()\nprint(f\"Number of objects in the collection: {object_count}\")\n\n# Close the client connection\nclient.close()\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the Weaviate Cloud URL and API key from environment variables (`WCD_TEST_URL` and `WCD_TEST_KEY`).\n2. **Connection**: It connects to Weaviate Cloud using `weaviate.connect_to_wcs`.\n3. **Collection Creation**: The `DemoProducts` collection is created with `name` and `description` properties.\n4. **Batch Import**: 50 arbitrary objects are generated and imported into the collection using a batch process.\n5. **Error Handling**: If any object fails to import, it prints the failed object.\n6. **Object Count**: The total number of objects in the collection is printed using `collection.aggregate.over_all().total_count()`.\n7. **Cleanup**: The client connection is closed after the operation is complete.\n\nMake sure to set the required environment variables (`WCD_TEST_URL`, `WCD_TEST_KEY`, and optionally `OPENAI_API_KEY`) before running the script.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 3, in <module>\n    from weaviate import Auth\nImportError: cannot import name 'Auth' from 'weaviate' (/usr/local/lib/python3.9/site-packages/weaviate/__init__.py)\n",
      "exit_code": 1
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:22:20.758490",
      "duration": 5.6150758266448975,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here\u2019s the Python code to create a collection named \"DemoProducts\" with the specified properties, batch import 50 objects, and print the number of objects in the collection. The code uses the latest Weaviate client syntax and connects to Weaviate Cloud using environment variables.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Configure, Property, DataType\nfrom weaviate.classes.data import DataObject\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.classes.init.Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\n# Create the \"DemoProducts\" collection with properties\nclient.collections.create(\n    name=\"DemoProducts\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n    ]\n)\n\n# Get the collection\ndemo_products = client.collections.get(\"DemoProducts\")\n\n# Batch import 50 objects\nwith demo_products.batch.fixed_size(batch_size=50) as batch:\n    for i in range(50):\n        batch.add_object(\n            properties={\n                \"name\": f\"Product {i}\",\n                \"description\": f\"Description {i}\"\n            }\n        )\n\n# Print the number of objects in the collection\nobject_count = demo_products.aggregate.total()\nprint(f\"Number of objects in the collection: {object_count}\")\n\n# Close the client\nclient.close()\n```\n\n### Explanation:\n1. **Connection to Weaviate Cloud**:\n   - Uses `connect_to_weaviate_cloud` with the provided environment variables (`WCD_TEST_URL` and `WCD_TEST_KEY`).\n\n2. **Collection Creation**:\n   - Creates a collection named \"DemoProducts\" with two properties: `name` and `description`, both of type `TEXT`.\n\n3. **Batch Import**:\n   - Uses a fixed-size batch to import 50 objects into the collection. Each object has a `name` and `description` with incremental values.\n\n4. **Counting Objects**:\n   - Uses `aggregate.total()` to get the total number of objects in the collection and prints it.\n\n5. **Cleanup**:\n   - Closes the client connection to free up resources.\n\nMake sure the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` are set before running the script.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 13, in <module>\n    client.collections.create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/executor.py\", line 240, in create\n    return self.__create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/executor.py\", line 104, in __create\n    result = self._connection.post(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 822, in post\n    return self._send(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 716, in _send\n    return executor.execute(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/executor.py\", line 99, in execute\n    return cast(T, exception_callback(e))\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 714, in exc\n    self.__handle_exceptions(e, error_msg)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 670, in __handle_exceptions\n    raise e\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/executor.py\", line 95, in execute\n    resp_call = response_callback(call)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 711, in resp\n    return self.__handle_response(res, error_msg, status_codes)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 681, in __handle_response\n    raise UnexpectedStatusCodeError(error_msg, response)\nweaviate.exceptions.UnexpectedStatusCodeError: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'class name DemoProducts already exists'}]}.\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 41972), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T22:22:26.138473",
      "duration": 4.950124979019165,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to query the `WineReview` collection and find wines that best match the query \"dessert wine\", with a limit of 2 results. The code uses the `text2vec-openai` vectorizer and connects to Weaviate Cloud using the provided environment variables.\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Client\nfrom weaviate.util import generate_uuid5\n\n# Connect to Weaviate Cloud\nclient = Client(\n    url=os.getenv(\"WCD_TEST_URL\"),\n    auth_client_secret=weaviate.AuthApiKey(api_key=os.getenv(\"WCD_TEST_KEY\")),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")  # Pass OpenAI API key to Weaviate\n    }\n)\n\n# Define the query\nquery = \"dessert wine\"\n\n# Perform the hybrid search (combines vector and keyword search)\nresponse = client.query.get(\n    class_name=\"WineReview\",\n    properties=[\"title\", \"country\", \"price\", \"points\"],\n    hybrid={\n        \"query\": query,\n        \"alpha\": 0.5  # Balance between vector search and keyword search\n    },\n    limit=2  # Limit results to 2\n)\n\n# Extract and print the results\nresults = response['data']['Get']['WineReview']\nfor wine in results:\n    print(f\"Title: {wine['title']}\")\n    print(f\"Country: {wine['country']}\")\n    print(f\"Price: {wine['price']}\")\n    print(f\"Points: {wine['points']}\")\n    print(\"-\" * 40)\n```\n\n### Explanation:\n1. **Weaviate Client Initialization**:\n   - The client is initialized with the Weaviate Cloud URL (`WCD_TEST_URL`) and API key (`WCD_TEST_KEY`).\n   - The OpenAI API key (`OPENAI_API_KEY`) is passed as an additional header to enable the `text2vec-openai` vectorizer.\n\n2. **Hybrid Search**:\n   - The `hybrid` search combines vector search (based on the OpenAI embedding) and keyword search to find the best matches for the query \"dessert wine\".\n   - The `alpha` parameter balances between vector search (`alpha=0`) and keyword search (`alpha=1`). Here, `alpha=0.5` provides a balanced approach.\n\n3. **Result Extraction**:\n   - The results are extracted from the response and printed, including the `title`, `country`, `price`, and `points` of each matching wine.\n\nMake sure the required environment variables (`WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY`) are set before running the script.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:7: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 7, in <module>\n    client = Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:22:32.221094",
      "duration": 5.701442003250122,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to query the `WineReview` collection for wines that best match the query \"dessert wine\", with a limit of 2 results. The code uses the environment variables `WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY` as specified.\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Retrieve environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    headers={\n        \"X-OpenAI-API-Key\": OPENAI_API_KEY\n    },\n)\n\n# Access the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Query for wines matching \"dessert wine\" with a limit of 2 results\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2\n)\n\n# Print the title, country, price, and points of each matching wine\nfor obj in response.objects:\n    properties = obj.properties\n    print(f\"Title: {properties['title']}\")\n    print(f\"Country: {properties['country']}\")\n    print(f\"Price: {properties['price']}\")\n    print(f\"Points: {properties['points']}\")\n    print(\"-\" * 40)\n\n# Close the client connection\nclient.close()\n```\n\n### Explanation:\n1. **Environment Variables**: The code retrieves the necessary environment variables (`WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY`).\n2. **Weaviate Connection**: It connects to the Weaviate Cloud instance using the provided URL and API key, and includes the OpenAI API key in the headers for vectorization.\n3. **Collection Access**: It accesses the `WineReview` collection.\n4. **Query Execution**: It performs a `near_text` query with the search term \"dessert wine\" and limits the results to 2.\n5. **Result Printing**: It iterates over the results and prints the `title`, `country`, `price`, and `points` of each matching wine.\n6. **Connection Closure**: Finally, it closes the Weaviate client connection.\n\nMake sure the environment variables are properly set before running the script.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:22:38.961026",
      "duration": 6.370282888412476,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here is the Python code to query the 'WineReview' collection and find wines that best match the query \"dessert wine\", with a limit of maximum 2 results, using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import MetadataQuery\nfrom weaviate.classes.config import Configure\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.classes.init.Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\n# Get the WineReview collection\nwine_collection = client.collections.get(\"WineReview\")\n\n# Perform a semantic search with near_text\nresponse = wine_collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2,\n    return_metadata=MetadataQuery(distance=True)\n)\n\n# Print the title, country, price, and points of each matching wine\nfor wine in response.objects:\n    print(f\"Title: {wine.properties['title']}\")\n    print(f\"Country: {wine.properties['country']}\")\n    print(f\"Price: {wine.properties['price']}\")\n    print(f\"Points: {wine.properties['points']}\")\n    print(f\"Distance: {wine.metadata.distance}\")\n    print(\"-\" * 40)\n\n# Close the client\nclient.close()\n```\n\nThis code:\n\n1.  Connects to Weaviate Cloud using the provided environment variables.\n2.  Gets the `WineReview` collection.\n3.  Performs a semantic search using the `near_text` method with the query \"dessert wine\" and a limit of 2 results.\n4.  Returns the metadata, including the distance of each result from the query.\n5.  Prints the title, country, price, points, and distance of each matching wine.\n6.  Closes the client connection.\n\nMake sure to replace the environment variables with your actual Weaviate Cloud and OpenAI API credentials.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\nDistance: 0.4766477346420288\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\nDistance: 0.4812379479408264\n----------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:22:45.603500",
      "duration": 6.274996995925903,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Below is the Python code using the latest Weaviate client syntax to perform the specified query:\n\n```python\nimport os\nimport weaviate\nfrom weaviate import Client\nfrom weaviate.util import get_valid_uuid\n\n# Connect to Weaviate Cloud\nclient = Client(\n    url=os.getenv(\"WCD_TEST_URL\"),\n    auth_client_secret=weaviate.AuthApiKey(api_key=os.getenv(\"WCD_TEST_KEY\")),\n    additional_headers={\"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")}\n)\n\n# Define the query\nquery = \"\"\"\n{\n  Get {\n    WineReview(\n      hybrid: { query: \"pair with steak\", alpha: 0.5 }\n      where: {\n        operator: AND\n        path: [\"price\", \"points\", \"review_body\"]\n        value: [\n          { operator: LessThan, value: 50 },\n          { operator: GreaterThan, value: 90 },\n          { operator: Like, value: [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"] }\n        ]\n      }\n      limit: 5\n    ) {\n      title\n      country\n      price\n      points\n    }\n  }\n}\n\"\"\"\n\n# Execute the query\nresponse = client.query.raw(query)\n\n# Extract and print the results\nresults = response[\"data\"][\"Get\"][\"WineReview\"]\nfor wine in results:\n    print(f\"Title: {wine['title']}\")\n    print(f\"Country: {wine['country']}\")\n    print(f\"Price: {wine['price']}\")\n    print(f\"Points: {wine['points']}\")\n    print(\"-\" * 40)\n```\n\n### Explanation:\n1. **Connection to Weaviate Cloud**:\n   - The `Client` is initialized with the Weaviate Cloud URL (`WCD_TEST_URL`) and API key (`WCD_TEST_KEY`).\n   - The OpenAI API key (`OPENAI_API_KEY`) is passed as an additional header for the `text2vec-openai` vectorizer.\n\n2. **Query Construction**:\n   - The query uses **hybrid search** with `alpha=0.5` to balance semantic and keyword search.\n   - The `where` clause filters results to include only wines with:\n     - `price < 50`\n     - `points > 90`\n     - `review_body` containing at least one of the specified substrings (`spice`, `fruit`, etc.) using the `Like` operator.\n   - The `limit` is set to 5 to retrieve a maximum of 5 results.\n\n3. **Result Extraction and Printing**:\n   - The response is parsed to extract the `title`, `country`, `price`, and `points` of each matching wine.\n   - The results are printed in a formatted manner.\n\n### Notes:\n- Ensure the environment variables (`WCD_TEST_URL`, `WCD_TEST_KEY`, `OPENAI_API_KEY`) are set before running the script.\n- The `Like` operator is used for substring matching in the `review_body`.\n- The `hybrid` search combines semantic search (vector-based) and keyword search (BM25) with the specified `alpha` value.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:7: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 7, in <module>\n    client = Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:22:52.325120",
      "duration": 6.320986747741699,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to achieve the desired query:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\nimport os\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\")),\n    headers={\n        \"X-OpenAI-API-Key\": os.getenv(\"OPENAI_API_KEY\")\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Define the hybrid search query with filters\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    filters=Filter.by_properties(\n        [\n            Filter.by_property(\"price\").less_than(50),\n            Filter.by_property(\"points\").greater_than(90),\n            Filter.by_property(\"review_body\").contains_any(\n                [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n            ),\n        ]\n    ).as_condition(),\n    return_metadata=True,  # Include metadata for scores\n)\n\n# Print the desired properties for each matching wine\nfor obj in response.objects:\n    print(f\"Title: {obj.properties['title']}\")\n    print(f\"Country: {obj.properties['country']}\")\n    print(f\"Price: {obj.properties['price']}\")\n    print(f\"Points: {obj.properties['points']}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(\"-\" * 40)\n\n# Close the client connection\nclient.close()\n```\n\n### Explanation:\n1. **Connection to Weaviate Cloud**:\n   - Uses `os.getenv` to retrieve environment variables for the Weaviate Cloud URL (`WCD_TEST_URL`), API key (`WCD_TEST_KEY`), and OpenAI API key (`OPENAI_API_KEY`).\n\n2. **Collection Access**:\n   - Retrieves the `WineReview` collection using `client.collections.get(\"WineReview\")`.\n\n3. **Hybrid Search Query**:\n   - Performs a hybrid search with the query `\"pair with steak\"`, a limit of 5 results, and `alpha=0.5`.\n   - Applies filters to ensure:\n     - `price` is less than 50.\n     - `points` is greater than 90.\n     - `review_body` contains at least one of the specified substrings.\n\n4. **Result Processing**:\n   - Iterates over the results and prints the `title`, `country`, `price`, `points`, and the search score for each matching wine.\n\n5. **Client Closure**:\n   - Closes the Weaviate client connection after the query is complete.\n\nThis code adheres to the latest Weaviate client syntax and meets all the specified requirements.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 23, in <module>\n    filters=Filter.by_properties(\nAttributeError: type object 'Filter' has no attribute 'by_properties'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 42972), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "extensive_examples_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:22:59.834423",
      "duration": 7.1087658405303955,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here\u2019s the Python code using the latest Weaviate client syntax to query the `WineReview` collection based on your requirements:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.query import Filter, HybridFusion\nfrom weaviate.classes.config import Configure\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.classes.init.Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\n# Get the WineReview collection\nwine_collection = client.collections.get(\"WineReview\")\n\n# Define the search query with filters and hybrid search\nresponse = wine_collection.query.hybrid(\n    query=\"pair with steak\",\n    alpha=0.5,\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    filters=Filter.by_properties(\n        price=Filter.by_property(\"price\").less_than(50),\n        points=Filter.by_property(\"points\").greater_than(90),\n        review_body=Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    )\n)\n\n# Print the results\nfor wine in response.objects:\n    print(f\"Title: {wine.properties['title']}\")\n    print(f\"Country: {wine.properties['country']}\")\n    print(f\"Price: {wine.properties['price']}\")\n    print(f\"Points: {wine.properties['points']}\")\n    print(\"-\" * 40)\n\n# Close the client\nclient.close()\n```\n\n### Explanation:\n1. **Connection to Weaviate Cloud**:\n   - Uses `connect_to_weaviate_cloud` with the provided environment variables for the cluster URL and API key.\n   - Includes the OpenAI API key in the headers for vectorization.\n\n2. **Collection Access**:\n   - Retrieves the `WineReview` collection using `client.collections.get(\"WineReview\")`.\n\n3. **Hybrid Search**:\n   - Performs a hybrid search with `query.hybrid` using the query `\"pair with steak\"`.\n   - Sets `alpha=0.5` for balancing between keyword and vector search.\n   - Limits the results to 5.\n\n4. **Filters**:\n   - Applies filters to ensure:\n     - `price` is less than 50.\n     - `points` is greater than 90.\n     - `review_body` contains at least one of the specified substrings.\n\n5. **Result Printing**:\n   - Iterates over the results and prints the `title`, `country`, `price`, and `points` of each matching wine.\n\n6. **Client Closure**:\n   - Closes the client connection after the query is complete.\n\nThis code should work with the latest Weaviate client syntax and fulfill all the specified requirements.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 24, in <module>\n    filters=Filter.by_properties(\nAttributeError: type object 'Filter' has no attribute 'by_properties'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 42992), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    }
  },
  "anthropic/claude-sonnet-4-20250514": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:23:06.018284",
      "duration": 6.164469003677368,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "Here's Python code using the latest Weaviate client syntax to connect to Weaviate Cloud and check if the server is ready:\n\n```python\nimport os\nimport weaviate\n\n# Get environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=weaviate.auth.AuthApiKey(wcd_key)\n)\n\ntry:\n    # Check if the server is ready\n    if client.is_ready():\n        print(\"Weaviate server is ready to accept requests!\")\n    else:\n        print(\"Weaviate server is not ready.\")\n        \nexcept Exception as e:\n    print(f\"Error checking server readiness: {e}\")\n    \nfinally:\n    # Close the connection\n    client.close()\n```\n\nThis code:\n1. Imports the necessary modules\n2. Retrieves the environment variables for the Weaviate Cloud URL and API key\n3. Connects to Weaviate Cloud using the latest client syntax with `connect_to_weaviate_cloud()`\n4. Uses API key authentication with `weaviate.auth.AuthApiKey()`\n5. Checks if the server is ready using `client.is_ready()`\n6. Properly closes the connection when done\n\nMake sure you have the latest Weaviate Python client installed:\n```bash\npip install weaviate-client\n```",
      "stdout": "Weaviate server is ready to accept requests!\n",
      "stderr": "",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:23:10.761226",
      "duration": 4.724740028381348,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to connect to Weaviate Cloud using environment variables:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\"))\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready()\n\n# Close the connection\nclient.close()\n```\n\nThis code:\n1. Imports the necessary modules including `os` for environment variables\n2. Uses `os.getenv()` to retrieve the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables\n3. Connects to the Weaviate Cloud instance using these credentials\n4. Checks if the server is ready using `client.is_ready()`\n5. Closes the connection when done",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:23:19.669158",
      "duration": 8.889446020126343,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "Here's Python code using the latest Weaviate client syntax to create the \"DemoProducts\" collection:\n\n```python\nimport weaviate\nimport os\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=weaviate.auth.AuthApiKey(os.getenv(\"WCD_TEST_KEY\"))\n)\n\ntry:\n    # Check if collection exists and delete it if it does\n    if client.collections.exists(\"DemoProducts\"):\n        client.collections.delete(\"DemoProducts\")\n        print(\"Existing 'DemoProducts' collection deleted.\")\n    \n    # Create the DemoProducts collection with specified properties\n    client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL)\n        ]\n    )\n    \n    print(\"'DemoProducts' collection created successfully!\")\n    \n    # Verify the collection was created\n    collection = client.collections.get(\"DemoProducts\")\n    print(f\"Collection '{collection.name}' is ready to use.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Imports**: Imports the necessary Weaviate client modules and os for environment variables\n2. **Connection**: Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n3. **Collection Management**: Checks if the \"DemoProducts\" collection already exists and deletes it if found\n4. **Collection Creation**: Creates a new \"DemoProducts\" collection with the four specified properties:\n   - `name` (text)\n   - `description` (text) \n   - `price` (number)\n   - `in_stock` (boolean)\n5. **Error Handling**: Includes try-except-finally blocks for proper error handling and connection cleanup\n6. **Verification**: Confirms the collection was created successfully\n\nMake sure you have the Weaviate Python client installed:\n```bash\npip install weaviate-client\n```\n\nAnd ensure your environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` are properly set before running the code.",
      "stdout": "Existing 'DemoProducts' collection deleted.\n'DemoProducts' collection created successfully!\nCollection 'DemoProducts' is ready to use.\n",
      "stderr": "",
      "exit_code": 0
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:23:26.294599",
      "duration": 6.607445001602173,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to create the \"DemoProducts\" collection:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\"))\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n    print(f\"Deleted existing collection: {collection_name}\")\n\n# Create the new collection with the specified properties\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n```\n\nThis code:\n\n1. **Imports the necessary modules** from the Weaviate client library\n2. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n3. **Checks if the collection exists** and deletes it if it does\n4. **Creates the new collection** with the four specified properties:\n   - `name` (text)\n   - `description` (text) \n   - `price` (number)\n   - `in_stock` (boolean)\n5. **Prints confirmation** and closes the connection\n\nMake sure you have the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` set in your environment before running this code.",
      "stdout": "Deleted existing collection: DemoProducts\nCreated collection: DemoProducts\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:23:36.146284",
      "duration": 9.833733081817627,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to create the \"DemoProducts\" collection using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\ntry:\n    # Check if the collection already exists and delete it if it does\n    if client.collections.exists(\"DemoProducts\"):\n        print(\"Collection 'DemoProducts' already exists. Deleting it...\")\n        client.collections.delete(\"DemoProducts\")\n        print(\"Collection 'DemoProducts' deleted successfully.\")\n    \n    # Create the DemoProducts collection with the specified properties\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n    \n    print(\"Collection 'DemoProducts' created successfully with properties:\")\n    print(\"- name (text)\")\n    print(\"- description (text)\")\n    print(\"- price (number)\")\n    print(\"- in_stock (boolean)\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the `connect_to_weaviate_cloud()` method with the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Checks if the collection exists** using `client.collections.exists()`\n3. **Deletes the existing collection** if it exists using `client.collections.delete()`\n4. **Creates the new collection** with the specified properties:\n   - `name` as a TEXT property\n   - `description` as a TEXT property  \n   - `price` as a NUMBER property (floating point)\n   - `in_stock` as a BOOL property\n5. **Properly closes the connection** using a try/finally block\n\nMake sure you have the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` set before running this code.",
      "stdout": "Collection 'DemoProducts' already exists. Deleting it...\nCollection 'DemoProducts' deleted successfully.\nCollection 'DemoProducts' created successfully with properties:\n- name (text)\n- description (text)\n- price (number)\n- in_stock (boolean)\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:23:47.697643",
      "duration": 10.858030080795288,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Here's Python code using the latest Weaviate client syntax to accomplish your requirements:\n\n```python\nimport weaviate\nimport os\nfrom weaviate.classes.config import Configure\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=weaviate.auth.AuthApiKey(os.getenv(\"WCD_TEST_KEY\"))\n)\n\ntry:\n    # Create the collection with the specified properties\n    collection = client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            weaviate.classes.config.Property(\n                name=\"name\",\n                data_type=weaviate.classes.config.DataType.TEXT\n            ),\n            weaviate.classes.config.Property(\n                name=\"description\", \n                data_type=weaviate.classes.config.DataType.TEXT\n            )\n        ]\n    )\n    print(\"Collection 'DemoProducts' created successfully!\")\n    \n    # Get reference to the collection\n    demo_products = client.collections.get(\"DemoProducts\")\n    \n    # Prepare 50 objects for batch import\n    objects_to_insert = []\n    for i in range(1, 51):\n        objects_to_insert.append({\n            \"name\": f\"Product {i}\",\n            \"description\": f\"Description {i}\"\n        })\n    \n    # Batch import the objects\n    with demo_products.batch.dynamic() as batch:\n        for obj in objects_to_insert:\n            batch.add_object(obj)\n    \n    print(\"Successfully batch imported 50 objects!\")\n    \n    # Print the number of objects in the collection\n    response = demo_products.aggregate.over_all(total_count=True)\n    object_count = response.total_count\n    print(f\"Number of objects in 'DemoProducts' collection: {object_count}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n\n2. **Creates a collection** named \"DemoProducts\" with two text properties:\n   - `name` (text property)\n   - `description` (text property)\n\n3. **Batch imports 50 objects** with the simple structure you specified:\n   - Each object has a name like \"Product 1\", \"Product 2\", etc.\n   - Each object has a description like \"Description 1\", \"Description 2\", etc.\n\n4. **Prints the object count** in the collection using the aggregate query\n\n5. **Properly closes** the client connection\n\nMake sure you have the required environment variables set:\n```bash\nexport WCD_TEST_URL=\"your-weaviate-cloud-url\"\nexport WCD_TEST_KEY=\"your-api-key\"\n```\n\nAnd install the Weaviate client if you haven't already:\n```bash\npip install weaviate-client\n```\n\nThe code uses the latest Weaviate Python client v4 syntax with proper error handling and resource cleanup.",
      "stdout": "An error occurred: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'class name DemoProducts already exists'}]}.\n",
      "stderr": "",
      "exit_code": 0
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:24:00.936022",
      "duration": 12.499958992004395,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to accomplish your requirements:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.auth import Auth\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\")),\n)\n\ntry:\n    # Create the collection with the specified properties\n    collection_name = \"DemoProducts\"\n    \n    # Check if collection exists, if not create it\n    if not client.collections.exists(collection_name):\n        client.collections.create(\n            name=collection_name,\n            properties=[\n                weaviate.classes.Property(\n                    name=\"name\",\n                    data_type=weaviate.classes.DataType.TEXT\n                ),\n                weaviate.classes.Property(\n                    name=\"description\", \n                    data_type=weaviate.classes.DataType.TEXT\n                )\n            ]\n        )\n        print(f\"Collection '{collection_name}' created successfully.\")\n    else:\n        print(f\"Collection '{collection_name}' already exists.\")\n    \n    # Get the collection\n    collection = client.collections.get(collection_name)\n    \n    # Create 50 arbitrary objects\n    data_rows = [\n        {\n            \"name\": f\"Product {i}\",\n            \"description\": f\"Description {i}\"\n        } for i in range(50)\n    ]\n    \n    # Batch import the objects\n    with collection.batch.dynamic() as batch:\n        for data_row in data_rows:\n            batch.add_object(\n                properties=data_row,\n            )\n            if batch.number_errors > 10:\n                print(\"Batch import stopped due to excessive errors.\")\n                break\n    \n    # Check for failed objects\n    failed_objects = collection.batch.failed_objects\n    if failed_objects:\n        print(f\"Number of failed imports: {len(failed_objects)}\")\n        print(f\"First failed object: {failed_objects[0]}\")\n    else:\n        print(\"All objects imported successfully!\")\n    \n    # Print the number of objects in the collection\n    print(f\"Number of objects in collection: {len(collection)}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n\n2. **Creates the collection** \"DemoProducts\" with the specified properties:\n   - `name` (text property)\n   - `description` (text property)\n\n3. **Generates 50 objects** with the format you specified:\n   - `\"name\": \"Product {i}\"`\n   - `\"description\": \"Description {i}\"`\n\n4. **Batch imports** all 50 objects using the dynamic batch functionality\n\n5. **Error handling** - checks for failed imports and stops if there are too many errors\n\n6. **Prints the final count** of objects in the collection\n\n7. **Properly closes** the client connection\n\nMake sure you have the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` set before running this code. The code also includes proper error handling and will create the collection if it doesn't already exist.",
      "stdout": "Collection 'DemoProducts' already exists.\nAll objects imported successfully!\nNumber of objects in collection: 50\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:24:13.473811",
      "duration": 11.861661911010742,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's the Python code to create a collection, batch import 50 objects, and print the count using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\ntry:\n    # Create the DemoProducts collection with name and description properties\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ]\n    )\n    \n    # Get the collection\n    collection = client.collections.get(\"DemoProducts\")\n    \n    # Batch import 50 objects using fixed_size batch (recommended approach)\n    with collection.batch.fixed_size(batch_size=50) as batch:\n        for i in range(50):\n            batch.add_object(\n                properties={\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"Description {i}\"\n                }\n            )\n    \n    # Check for any batch errors\n    if collection.batch.failed_objects:\n        print(f\"Number of failed objects: {len(collection.batch.failed_objects)}\")\n    \n    # Get the total count of objects in the collection\n    response = collection.query.fetch_objects(limit=0)  # limit=0 to get count without objects\n    total_count = len(list(collection.iterator()))  # Use iterator to get accurate count\n    \n    print(f\"Number of objects in DemoProducts collection: {total_count}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Creates a collection** named \"DemoProducts\" with two text properties: `name` and `description`\n3. **Batch imports 50 objects** using the recommended `fixed_size` batch approach for optimal performance\n4. **Handles errors** by checking for failed objects after the batch operation\n5. **Counts the objects** in the collection using the iterator method for an accurate count\n6. **Prints the total count** of objects in the collection\n7. **Properly closes** the client connection using a try/finally block\n\nThe batch import uses `fixed_size(batch_size=50)` which is the recommended approach for batch operations as it provides good performance while managing memory usage effectively.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 14, in <module>\n    client.collections.create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/executor.py\", line 240, in create\n    return self.__create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/executor.py\", line 104, in __create\n    result = self._connection.post(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 822, in post\n    return self._send(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 716, in _send\n    return executor.execute(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/executor.py\", line 99, in execute\n    return cast(T, exception_callback(e))\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 714, in exc\n    self.__handle_exceptions(e, error_msg)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 670, in __handle_exceptions\n    raise e\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/executor.py\", line 95, in execute\n    resp_call = response_callback(call)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 711, in resp\n    return self.__handle_response(res, error_msg, status_codes)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 681, in __handle_response\n    raise UnexpectedStatusCodeError(error_msg, response)\nweaviate.exceptions.UnexpectedStatusCodeError: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'class name DemoProducts already exists'}]}.\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:24:24.218914",
      "duration": 10.333739995956421,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to query the 'WineReview' collection:\n\n```python\nimport weaviate\nimport os\nfrom weaviate.classes.query import MetadataQuery\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=weaviate.auth.AuthApiKey(os.getenv(\"WCD_TEST_KEY\")),\n    headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_reviews = client.collections.get(\"WineReview\")\n    \n    # Perform a vector search for \"dessert wine\"\n    response = wine_reviews.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_metadata=MetadataQuery(distance=True)\n    )\n    \n    # Print the results\n    print(f\"Found {len(response.objects)} matching wines:\\n\")\n    \n    for i, wine in enumerate(response.objects, 1):\n        print(f\"Wine {i}:\")\n        print(f\"  Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"  Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"  Price: ${wine.properties.get('price', 'N/A')}\")\n        print(f\"  Points: {wine.properties.get('points', 'N/A')}\")\n        print(f\"  Distance: {wine.metadata.distance:.4f}\")\n        print()\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Sets up OpenAI authentication** using the `OPENAI_API_KEY` environment variable in the headers\n3. **Performs a semantic search** using `near_text()` with the query \"dessert wine\"\n4. **Limits results to 2** as requested\n5. **Prints the required fields** (title, country, price, points) for each matching wine\n6. **Includes error handling** and proper client cleanup\n\nThe `near_text()` query will use the text2vec-openai vectorizer to find wines that are semantically similar to \"dessert wine\", which should return wines that are actually dessert wines or have similar characteristics.\n\nMake sure you have the required environment variables set:\n- `WCD_TEST_URL`: Your Weaviate Cloud instance URL\n- `WCD_TEST_KEY`: Your Weaviate Cloud API key  \n- `OPENAI_API_KEY`: Your OpenAI API key\n\nYou'll also need to install the Weaviate client:\n```bash\npip install weaviate-client\n```",
      "stdout": "Found 2 matching wines:\n\nWine 1:\n  Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price: $24.0\n  Points: 88\n  Distance: 0.4766\n\nWine 2:\n  Title: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price: $40.0\n  Points: 88\n  Distance: 0.4812\n\n",
      "stderr": "",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:24:31.970377",
      "duration": 7.311306953430176,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to query the 'WineReview' collection for wines matching \"dessert wine\":\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\")),\n    headers={\n        \"X-OpenAI-API-Key\": os.getenv(\"OPENAI_API_KEY\")\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Query for wines that best match \"dessert wine\"\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2\n)\n\n# Print the title, country, price, and points of each matching wine\nfor obj in response.objects:\n    properties = obj.properties\n    print(f\"Title: {properties.get('title', 'N/A')}\")\n    print(f\"Country: {properties.get('country', 'N/A')}\")\n    print(f\"Price: {properties.get('price', 'N/A')}\")\n    print(f\"Points: {properties.get('points', 'N/A')}\")\n    print(\"-\" * 40)\n\n# Close the connection\nclient.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Sets up OpenAI authentication** using the `OPENAI_API_KEY` environment variable in the headers\n3. **Gets the WineReview collection** from the Weaviate instance\n4. **Performs a semantic search** using `near_text` with the query \"dessert wine\" and limits results to 2\n5. **Extracts and prints** the title, country, price, and points for each matching wine\n6. **Closes the connection** to clean up resources\n\nThe `near_text` query will use the text2vec-openai vectorizer to find wines that are semantically similar to \"dessert wine\", which should return wines that are actually dessert wines or have similar characteristics.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:24:43.557175",
      "duration": 11.17624306678772,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, here's the Python code to query the 'WineReview' collection for wines matching \"dessert wine\":\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # For text2vec-openai vectorizer\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Perform semantic search for \"dessert wine\" with limit of 2 results\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print the results\n    for wine in response.objects:\n        properties = wine.properties\n        print(f\"Title: {properties.get('title', 'N/A')}\")\n        print(f\"Country: {properties.get('country', 'N/A')}\")\n        print(f\"Price: {properties.get('price', 'N/A')}\")\n        print(f\"Points: {properties.get('points', 'N/A')}\")\n        print(\"-\" * 40)\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Includes the OpenAI API key** in headers for the text2vec-openai vectorizer\n3. **Performs a semantic search** using `near_text()` to find wines that best match \"dessert wine\"\n4. **Limits results to 2** as requested\n5. **Returns specific properties**: title, country, price, and points\n6. **Prints the results** in a readable format\n7. **Properly closes the connection** using a try/finally block\n\nThe `near_text()` method leverages the text2vec-openai vectorizer to find wines that are semantically similar to \"dessert wine\", which should return wines that are actually dessert wines or have similar characteristics.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n----------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n----------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:24:54.896806",
      "duration": 10.940865993499756,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to perform the hybrid search with the specified requirements:\n\n```python\nimport weaviate\nimport os\nfrom weaviate.classes.query import HybridFusion\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_wcs(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=weaviate.auth.AuthApiKey(os.getenv(\"WCD_TEST_KEY\")),\n    headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Perform hybrid search with filters\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        limit=5,\n        where=weaviate.classes.query.Filter.by_property(\"price\").less_than(50) &\n              weaviate.classes.query.Filter.by_property(\"points\").greater_than(90) &\n              (weaviate.classes.query.Filter.by_property(\"review_body\").contains_any([\"spice\"]) |\n               weaviate.classes.query.Filter.by_property(\"review_body\").contains_any([\"fruit\"]) |\n               weaviate.classes.query.Filter.by_property(\"review_body\").contains_any([\"berry\"]) |\n               weaviate.classes.query.Filter.by_property(\"review_body\").contains_any([\"cherry\"]) |\n               weaviate.classes.query.Filter.by_property(\"review_body\").contains_any([\"honey\"]))\n    )\n    \n    # Print results\n    print(f\"Found {len(response.objects)} wines that pair well with steak:\\n\")\n    \n    for wine in response.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: ${wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(\"-\" * 50)\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, and includes the OpenAI API key in the headers.\n\n2. **Performs a hybrid search** with:\n   - Query: \"pair with steak\"\n   - Alpha: 0.5 (balanced between keyword and vector search)\n   - Limit: 5 results maximum\n\n3. **Applies filters** to ensure results meet all criteria:\n   - Price less than 50\n   - Points greater than 90\n   - Review body contains at least one of: \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n\n4. **Prints the results** showing the title, country, price, and points for each matching wine.\n\n5. **Properly closes the connection** in the finally block.\n\nThe filter uses the `&` operator for AND conditions and the `|` operator for OR conditions to match wines that contain any of the specified flavor descriptors in their review body.",
      "stdout": "An error occurred: hybrid() got an unexpected keyword argument 'where'\n",
      "stderr": "/code/code.py:6: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:25:05.234770",
      "duration": 9.946330785751343,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to query the 'WineReview' collection:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.getenv(\"WCD_TEST_URL\"),\n    auth_credentials=Auth.api_key(os.getenv(\"WCD_TEST_KEY\")),\n    headers={\n        \"X-OpenAI-API-Key\": os.getenv(\"OPENAI_API_KEY\")\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform hybrid search with filters\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\n# Print the results\nprint(f\"Found {len(response.objects)} matching wines:\\n\")\n\nfor obj in response.objects:\n    properties = obj.properties\n    print(f\"Title: {properties.get('title', 'N/A')}\")\n    print(f\"Country: {properties.get('country', 'N/A')}\")\n    print(f\"Price: ${properties.get('price', 'N/A')}\")\n    print(f\"Points: {properties.get('points', 'N/A')}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(\"-\" * 50)\n\n# Close the connection\nclient.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Sets up OpenAI integration** using the `OPENAI_API_KEY` environment variable\n3. **Performs a hybrid search** with:\n   - Query: \"pair with steak\"\n   - Alpha: 0.5 (balanced between vector and keyword search)\n   - Limit: 5 results maximum\n4. **Applies filters** to ensure:\n   - Price < 50\n   - Points > 90\n   - Review body contains at least one of: \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n5. **Prints the requested information** for each matching wine: title, country, price, and points\n6. **Includes the search score** for reference\n7. **Properly closes the connection** when done\n\nThe hybrid search with alpha=0.5 provides a balanced combination of semantic similarity (vector search) and keyword matching, which should effectively find wines that are semantically related to \"pair with steak\" while meeting all the specified criteria.",
      "stdout": "Found 5 matching wines:\n\nTitle: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.0\nPoints: 92\nScore: 0.5\n--------------------------------------------------\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.0\nPoints: 91\nScore: 0.3765353560447693\n--------------------------------------------------\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.0\nPoints: 91\nScore: 0.04513849690556526\n--------------------------------------------------\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.0\nPoints: 93\nScore: 0.016171861439943314\n--------------------------------------------------\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: $0.0\nPoints: 92\nScore: 0.0010482011130079627\n--------------------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:25:21.292231",
      "duration": 15.679394006729126,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, I'll write Python code that connects to Weaviate Cloud, performs a hybrid search on the WineReview collection with the specified filters, and returns the matching wines.\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # For text2vec-openai vectorizer\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Create filters for the requirements\n    # Price less than 50 AND points greater than 90\n    price_points_filter = (\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90)\n    )\n    \n    # Filter for review_body containing at least one of the specified substrings\n    # Using like with wildcards to match substrings\n    flavor_filter = Filter.any_of([\n        Filter.by_property(\"review_body\").like(\"*spice*\"),\n        Filter.by_property(\"review_body\").like(\"*fruit*\"),\n        Filter.by_property(\"review_body\").like(\"*berry*\"),\n        Filter.by_property(\"review_body\").like(\"*cherry*\"),\n        Filter.by_property(\"review_body\").like(\"*honey*\")\n    ])\n    \n    # Combine all filters\n    combined_filter = price_points_filter & flavor_filter\n    \n    # Perform hybrid search with alpha=0.5\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,  # Balance between keyword and vector search\n        filters=combined_filter,\n        limit=5,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print the results\n    print(f\"Found {len(response.objects)} wines that pair well with steak:\\n\")\n    \n    for i, wine in enumerate(response.objects, 1):\n        props = wine.properties\n        print(f\"{i}. Title: {props.get('title', 'N/A')}\")\n        print(f\"   Country: {props.get('country', 'N/A')}\")\n        print(f\"   Price: ${props.get('price', 'N/A')}\")\n        print(f\"   Points: {props.get('points', 'N/A')}\")\n        print()\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code does the following:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, with the OpenAI API key for the text2vec-openai vectorizer\n\n2. **Creates the required filters**:\n   - Price less than 50 AND points greater than 90\n   - Review body contains at least one of: \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n\n3. **Performs a hybrid search** with:\n   - Query: \"pair with steak\"\n   - Alpha: 0.5 (equal balance between semantic and keyword search)\n   - Maximum 5 results\n   - Combined filters applied\n\n4. **Returns only the requested properties**: title, country, price, and points\n\n5. **Properly closes the connection** using a try/finally block\n\nThe hybrid search with alpha=0.5 will combine both semantic similarity (using the text2vec-openai vectors) and keyword matching to find wines that best match \"pair with steak\" while meeting all the specified criteria.",
      "stdout": "Found 5 wines that pair well with steak:\n\n1. Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n   Country: US\n   Price: $40.0\n   Points: 92\n\n2. Title: Bink 2014 Pinot Noir (Anderson Valley)\n   Country: US\n   Price: $49.0\n   Points: 91\n\n3. Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n   Country: Argentina\n   Price: $27.0\n   Points: 91\n\n4. Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n   Country: Hungary\n   Price: $25.0\n   Points: 93\n\n5. Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n   Country: Italy\n   Price: $0.0\n   Points: 92\n\n",
      "stderr": "",
      "exit_code": 0
    }
  },
  "anthropic/claude-opus-4-20250514": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:25:47.450701",
      "duration": 26.139448165893555,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "Here's the Python code to connect to Weaviate Cloud using environment variables and check server readiness:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=AuthApiKey(wcd_key)\n)\n\ntry:\n    # Check if the server is ready\n    if client.is_ready():\n        print(\"Weaviate server is ready to accept requests\")\n    else:\n        print(\"Weaviate server is not ready\")\nfinally:\n    # Close the connection\n    client.close()\n```\n\nAlternatively, you can use the context manager approach which automatically handles closing the connection:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud using context manager\nwith weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=AuthApiKey(wcd_key)\n) as client:\n    # Check if the server is ready\n    if client.is_ready():\n        print(\"Weaviate server is ready to accept requests\")\n    else:\n        print(\"Weaviate server is not ready\")\n```\n\nBoth approaches use the latest Weaviate client syntax (v4) with the `connect_to_weaviate_cloud()` function and proper authentication using `AuthApiKey`.",
      "stdout": "Weaviate server is ready to accept requests\n",
      "stderr": "",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:26:06.983123",
      "duration": 19.513837099075317,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "Here's the Python code to connect to Weaviate Cloud using environment variables and check if the server is ready:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Get environment variables\ncluster_url = os.environ.get(\"WCD_TEST_URL\")\napi_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready()\n\n# Close the connection\nclient.close()\n```\n\nThis code:\n1. Imports the necessary modules (`os` for environment variables, `weaviate` for the client, and `Auth` for authentication)\n2. Retrieves the `WCD_TEST_URL` and `WCD_TEST_KEY` from environment variables\n3. Connects to the Weaviate Cloud instance using the retrieved credentials\n4. Checks if the server is ready using `assert client.is_ready()`\n5. Closes the connection properly\n\nMake sure you have set the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` before running this code.",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:26:46.378197",
      "duration": 39.37616205215454,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=weaviate.auth.AuthApiKey(wcd_key)\n)\n\ntry:\n    # Check if collection exists and delete it\n    if client.collections.exists(\"DemoProducts\"):\n        client.collections.delete(\"DemoProducts\")\n        print(\"Existing 'DemoProducts' collection deleted.\")\n    \n    # Create the collection with properties\n    client.collections.create(\n        name=\"DemoProducts\",\n        properties=[\n            Property(\n                name=\"name\",\n                data_type=DataType.TEXT\n            ),\n            Property(\n                name=\"description\",\n                data_type=DataType.TEXT\n            ),\n            Property(\n                name=\"price\",\n                data_type=DataType.NUMBER\n            ),\n            Property(\n                name=\"in_stock\",\n                data_type=DataType.BOOL\n            )\n        ]\n    )\n    \n    print(\"Collection 'DemoProducts' created successfully!\")\n    \n    # Verify the collection was created\n    collection = client.collections.get(\"DemoProducts\")\n    print(f\"\\nCollection name: {collection.name}\")\n    print(\"Properties:\")\n    for prop in collection.config.get().properties:\n        print(f\"  - {prop.name}: {prop.data_type}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. Imports the necessary modules including the latest Weaviate client\n2. Retrieves the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n3. Connects to Weaviate Cloud using `connect_to_weaviate_cloud()` with API key authentication\n4. Checks if the \"DemoProducts\" collection already exists and deletes it if found\n5. Creates a new collection with the specified properties:\n   - `name` as TEXT\n   - `description` as TEXT\n   - `price` as NUMBER\n   - `in_stock` as BOOL\n6. Verifies the collection was created and prints its properties\n7. Properly closes the client connection in a finally block\n\nMake sure you have the latest Weaviate client installed:\n```bash\npip install weaviate-client>=4.0.0\n```",
      "stdout": "Existing 'DemoProducts' collection deleted.\nCollection 'DemoProducts' created successfully!\n\nCollection name: DemoProducts\nProperties:\n  - name: text\n  - description: text\n  - price: number\n  - in_stock: boolean\n",
      "stderr": "",
      "exit_code": 0
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:27:17.299049",
      "duration": 30.902042150497437,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax with the environment variables:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Get environment variables\ncluster_url = os.environ.get(\"WCD_TEST_URL\")\napi_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\n# Create the collection with specified properties\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n```\n\nThis code:\n1. Imports the necessary modules from the Weaviate client library\n2. Retrieves the `WCD_TEST_URL` and `WCD_TEST_KEY` from environment variables\n3. Connects to the Weaviate Cloud instance using these credentials\n4. Checks if the \"DemoProducts\" collection already exists and deletes it if it does\n5. Creates a new \"DemoProducts\" collection with the four specified properties:\n   - `name` (text)\n   - `description` (text)\n   - `price` (number)\n   - `in_stock` (boolean)\n6. Prints a confirmation message\n7. Closes the connection to the Weaviate instance\n\nMake sure you have the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` set before running this code.",
      "stdout": "Created collection: DemoProducts\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:27:59.388427",
      "duration": 42.07068204879761,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, I'll write Python code to create a \"DemoProducts\" collection with the specified properties, connecting to Weaviate Cloud using environment variables. Here's the solution:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\ntry:\n    # Check if the collection already exists and delete it if it does\n    if client.collections.exists(\"DemoProducts\"):\n        client.collections.delete(\"DemoProducts\")\n        print(\"Existing 'DemoProducts' collection deleted.\")\n    \n    # Create the DemoProducts collection with specified properties\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL)\n        ]\n    )\n    \n    print(\"Collection 'DemoProducts' created successfully!\")\n    \n    # Verify the collection was created\n    if client.collections.exists(\"DemoProducts\"):\n        print(\"Collection confirmed to exist.\")\n        \n        # Optional: Get the collection to verify its configuration\n        collection = client.collections.get(\"DemoProducts\")\n        print(f\"Collection name: {collection.name}\")\n\nfinally:\n    # Always close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Checks if the collection exists** using `client.collections.exists()`\n3. **Deletes the existing collection** if it exists using `client.collections.delete()`\n4. **Creates the new collection** with the four specified properties:\n   - `name` (TEXT type)\n   - `description` (TEXT type)\n   - `price` (NUMBER type - for floating point values)\n   - `in_stock` (BOOL type)\n5. **Verifies the creation** and prints confirmation messages\n6. **Properly closes the connection** in the finally block\n\nThe code uses the latest Weaviate Python client v4.x syntax as shown in the examples provided.",
      "stdout": "Existing 'DemoProducts' collection deleted.\nCollection 'DemoProducts' created successfully!\nCollection confirmed to exist.\nCollection name: DemoProducts\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:28:40.039164",
      "duration": 39.94800424575806,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax:\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Configure, Property, DataType\nfrom weaviate.classes.data import DataObject\n\n# Get environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=weaviate.auth.AuthApiKey(wcd_key)\n)\n\ntry:\n    # Create or get the collection\n    if client.collections.exists(\"DemoProducts\"):\n        collection = client.collections.get(\"DemoProducts\")\n    else:\n        collection = client.collections.create(\n            name=\"DemoProducts\",\n            properties=[\n                Property(name=\"name\", data_type=DataType.TEXT),\n                Property(name=\"description\", data_type=DataType.TEXT)\n            ]\n        )\n    \n    # Prepare batch data\n    products = []\n    for i in range(50):\n        products.append(\n            DataObject(\n                properties={\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"Description {i}\"\n                }\n            )\n        )\n    \n    # Batch import the objects\n    collection.data.insert_many(products)\n    \n    # Get and print the number of objects in the collection\n    response = collection.aggregate.over_all(total_count=True)\n    print(f\"Number of objects in the collection: {response.total_count}\")\n    \nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. **Creates or gets the collection** \"DemoProducts\" with two text properties: \"name\" and \"description\"\n3. **Prepares 50 objects** with simple data following the pattern you specified\n4. **Batch imports** all 50 objects using `insert_many()`\n5. **Queries the collection** to get the total count of objects\n6. **Prints the result** showing the number of objects in the collection\n7. **Properly closes** the client connection in a finally block\n\nMake sure you have the latest Weaviate client installed:\n```bash\npip install -U weaviate-client\n```\n\nThe code uses the v4 client syntax with proper type hints and the new collection-based API structure.",
      "stdout": "Number of objects in the collection: 50\n",
      "stderr": "",
      "exit_code": 0
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:29:13.830229",
      "duration": 33.11242699623108,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to accomplish your requirements:\n\n```python\nimport weaviate\nfrom weaviate.auth import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n)\n\n# Get the collection\ncollection = client.collections.get(\"DemoProducts\")\n\n# Create 50 product objects\ndata_rows = [\n    {\n        \"name\": f\"Product {i}\",\n        \"description\": f\"Description {i}\"\n    } \n    for i in range(50)\n]\n\n# Batch import the objects\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\n# Check for failed imports\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\n# Print the number of objects in the collection\nprint(f\"Number of objects in the collection: {len(collection)}\")\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. Gets the \"DemoProducts\" collection\n3. Creates 50 simple product objects with name and description properties\n4. Uses batch import with dynamic batching to efficiently add all objects\n5. Checks for any failed imports and reports them\n6. Prints the total number of objects in the collection\n7. Properly closes the client connection\n\nMake sure you have the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY` set before running this code. Also ensure that the \"DemoProducts\" collection already exists in your Weaviate instance with the appropriate schema defining the \"name\" and \"description\" text properties.",
      "stdout": "Number of objects in the collection: 50\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:29:53.557129",
      "duration": 39.07146072387695,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, I'll write Python code to:\n1. Connect to Weaviate Cloud using environment variables\n2. Create a \"DemoProducts\" collection with name and description properties\n3. Batch import 50 products\n4. Print the count of objects\n\nHere's the complete code:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\ntry:\n    # Create the DemoProducts collection with properties\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ]\n    )\n    \n    # Get the collection\n    collection = client.collections.get(\"DemoProducts\")\n    \n    # Batch import 50 products using fixed size batch\n    with collection.batch.fixed_size(batch_size=50) as batch:\n        for i in range(50):\n            batch.add_object(\n                properties={\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"Description {i}\"\n                }\n            )\n    \n    # Check if there were any errors during batch import\n    if collection.batch.failed_objects:\n        print(f\"Warning: {len(collection.batch.failed_objects)} objects failed to import\")\n    \n    # Get the count of objects in the collection\n    # We can use the aggregate query to count objects\n    response = collection.aggregate.over_all(total_count=True)\n    \n    print(f\"Number of objects in the collection: {response.total_count}\")\n    \nfinally:\n    # Always close the client connection\n    client.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables\n2. Creates a collection named \"DemoProducts\" with two text properties: \"name\" and \"description\"\n3. Uses a fixed-size batch import to efficiently add 50 products to the collection\n4. Uses the aggregate query to get the total count of objects in the collection\n5. Properly closes the client connection in a finally block\n\nThe batch import is done efficiently using Weaviate's batch API with a fixed batch size of 50, which means all 50 objects will be sent in a single batch operation for optimal performance.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 14, in <module>\n    client.collections.create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/executor.py\", line 240, in create\n    return self.__create(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/collections/collections/executor.py\", line 104, in __create\n    result = self._connection.post(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 822, in post\n    return self._send(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 716, in _send\n    return executor.execute(\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/executor.py\", line 99, in execute\n    return cast(T, exception_callback(e))\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 714, in exc\n    self.__handle_exceptions(e, error_msg)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 670, in __handle_exceptions\n    raise e\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/executor.py\", line 95, in execute\n    resp_call = response_callback(call)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 711, in resp\n    return self.__handle_response(res, error_msg, status_codes)\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/connect/v4.py\", line 681, in __handle_response\n    raise UnexpectedStatusCodeError(error_msg, response)\nweaviate.exceptions.UnexpectedStatusCodeError: Collection may not have been created properly.! Unexpected status code: 422, with response body: {'error': [{'message': 'class name DemoProducts already exists'}]}.\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:30:16.863925",
      "duration": 22.90989398956299,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.query import MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.auth.AuthApiKey(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Perform near_text search for \"dessert wine\"\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_metadata=MetadataQuery(distance=True)\n    )\n    \n    # Print the results\n    for wine in response.objects:\n        print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n        print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n        print(f\"Price: {wine.properties.get('price', 'N/A')}\")\n        print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n        print(f\"Distance: {wine.metadata.distance}\")\n        print(\"-\" * 50)\n        \nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. Connects to Weaviate Cloud using the provided environment variables\n2. Passes the OpenAI API key in the headers for the text2vec-openai vectorizer\n3. Gets the 'WineReview' collection\n4. Performs a `near_text` query searching for \"dessert wine\" with a limit of 2 results\n5. Prints the title, country, price, and points for each matching wine\n6. Also includes the distance metric to show how closely each result matches the query\n7. Properly closes the client connection when done\n\nThe code uses the latest Weaviate v4 client syntax with the collections API and proper connection handling.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\nDistance: 0.47662150859832764\n--------------------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\nDistance: 0.4811869263648987\n--------------------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:30:42.346354",
      "duration": 25.089261770248413,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "Here's the Python code to query the WineReview collection for dessert wines using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-API-Key\": os.environ[\"OPENAI_API_KEY\"]\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Query for dessert wines\nresponse = collection.query.near_text(\n    query=\"dessert wine\",\n    limit=2\n)\n\n# Print the results\nfor obj in response.objects:\n    properties = obj.properties\n    print(f\"Title: {properties.get('title', 'N/A')}\")\n    print(f\"Country: {properties.get('country', 'N/A')}\")\n    print(f\"Price: {properties.get('price', 'N/A')}\")\n    print(f\"Points: {properties.get('points', 'N/A')}\")\n    print(\"-\" * 50)\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. Includes the OpenAI API key in the headers for the text2vec-openai vectorizer\n3. Gets the `WineReview` collection\n4. Performs a semantic search using `near_text` with the query \"dessert wine\"\n5. Limits the results to 2 wines\n6. Prints the title, country, price, and points for each matching wine\n7. Properly closes the client connection\n\nThe `near_text` query will use the text2vec-openai vectorizer to find wines that semantically match \"dessert wine\" based on their vector embeddings.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n--------------------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n--------------------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:31:18.003379",
      "duration": 35.20990991592407,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, I'll write Python code to query the 'WineReview' collection for dessert wines. Here's the solution:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Required for text2vec-openai\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Query for dessert wines using semantic search\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print the results\n    for wine in response.objects:\n        print(f\"Title: {wine.properties['title']}\")\n        print(f\"Country: {wine.properties['country']}\")\n        print(f\"Price: {wine.properties['price']}\")\n        print(f\"Points: {wine.properties['points']}\")\n        print(\"-\" * 50)\n        \nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the provided environment variables\n2. Includes the OpenAI API key in the headers for the text2vec-openai vectorizer\n3. Gets the 'WineReview' collection\n4. Performs a semantic search using `near_text` with the query \"dessert wine\"\n5. Limits results to 2 wines\n6. Returns only the requested properties: title, country, price, and points\n7. Prints the results in a formatted way\n8. Properly closes the connection using try/finally\n\nThe semantic search will find wines that are conceptually similar to \"dessert wine\" based on the vector embeddings created by the text2vec-openai vectorizer.",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n--------------------------------------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n--------------------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:32:00.228130",
      "duration": 41.82947087287903,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax:\n\n```python\nimport weaviate\nfrom weaviate.classes.query import Filter\nimport os\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.auth.AuthApiKey(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n    \n    # Perform hybrid search with filters\n    response = wine_collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        limit=5,\n        where=(\n            Filter.by_property(\"price\").less_than(50) &\n            Filter.by_property(\"points\").greater_than(90) &\n            (\n                Filter.by_property(\"review_body\").contains_any([\"spice\"]) |\n                Filter.by_property(\"review_body\").contains_any([\"fruit\"]) |\n                Filter.by_property(\"review_body\").contains_any([\"berry\"]) |\n                Filter.by_property(\"review_body\").contains_any([\"cherry\"]) |\n                Filter.by_property(\"review_body\").contains_any([\"honey\"])\n            )\n        ),\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print results\n    print(f\"Found {len(response.objects)} wines that pair well with steak:\\n\")\n    \n    for i, wine in enumerate(response.objects, 1):\n        print(f\"{i}. {wine.properties['title']}\")\n        print(f\"   Country: {wine.properties['country']}\")\n        print(f\"   Price: ${wine.properties['price']}\")\n        print(f\"   Points: {wine.properties['points']}\")\n        print()\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. Connects to Weaviate Cloud using the provided environment variables\n2. Includes the OpenAI API key in the headers for the text2vec-openai vectorizer\n3. Performs a hybrid search with alpha=0.5 on the query \"pair with steak\"\n4. Applies filters to ensure:\n   - Price is less than 50\n   - Points are greater than 90\n   - The review_body contains at least one of the specified substrings\n5. Limits results to 5 wines\n6. Returns and prints the title, country, price, and points for each matching wine\n7. Properly closes the client connection when done\n\nThe hybrid search combines both keyword (BM25) and vector search, with alpha=0.5 giving equal weight to both search methods.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 19, in <module>\n    response = wine_collection.query.hybrid(\nTypeError: hybrid() got an unexpected keyword argument 'where'\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:32:37.939527",
      "duration": 37.25849771499634,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "Here's the Python code using the latest Weaviate client syntax to query the 'WineReview' collection:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-API-Key\": os.environ[\"OPENAI_API_KEY\"]\n    },\n)\n\n# Get the WineReview collection\ncollection = client.collections.get(\"WineReview\")\n\n# Perform hybrid search\nresponse = collection.query.hybrid(\n    query=\"pair with steak\",\n    limit=5,\n    alpha=0.5,\n    where=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\n# Print results\nfor obj in response.objects:\n    print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n    print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n    print(f\"Price: ${obj.properties.get('price', 'N/A')}\")\n    print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(\"-\" * 50)\n\n# Close the client connection\nclient.close()\n```\n\nThis code:\n1. Connects to Weaviate Cloud using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`\n2. Sets the OpenAI API key from the `OPENAI_API_KEY` environment variable\n3. Gets the 'WineReview' collection\n4. Performs a hybrid search with:\n   - Query: \"pair with steak\"\n   - Limit: 5 results\n   - Alpha: 0.5 (balanced between vector and keyword search)\n   - Filters: price < 50, points > 90, and review_body contains at least one of the specified substrings\n5. Prints the title, country, price, and points for each matching wine\n6. Closes the client connection\n\nNote: I used `where` instead of `filters` as that's the correct parameter name in the latest Weaviate client syntax.",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 19, in <module>\n    response = collection.query.hybrid(\nTypeError: hybrid() got an unexpected keyword argument 'where'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 50594), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:33:22.803666",
      "duration": 44.37471389770508,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Looking at your requirements, I'll write Python code to query the WineReview collection with the specified filters and hybrid search. Here's the solution:\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # For text2vec-openai vectorizer\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    collection = client.collections.get(\"WineReview\")\n    \n    # Create filters for price < 50 and points > 90\n    price_filter = Filter.by_property(\"price\").less_than(50)\n    points_filter = Filter.by_property(\"points\").greater_than(90)\n    \n    # Create filter for review_body containing at least one of the specified substrings\n    review_filter = Filter.any_of([\n        Filter.by_property(\"review_body\").like(\"*spice*\"),\n        Filter.by_property(\"review_body\").like(\"*fruit*\"),\n        Filter.by_property(\"review_body\").like(\"*berry*\"),\n        Filter.by_property(\"review_body\").like(\"*cherry*\"),\n        Filter.by_property(\"review_body\").like(\"*honey*\")\n    ])\n    \n    # Combine all filters\n    combined_filter = price_filter & points_filter & review_filter\n    \n    # Perform hybrid search with alpha=0.5\n    response = collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,  # Balance between keyword and vector search\n        filters=combined_filter,\n        limit=5,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n    \n    # Print results\n    print(f\"Found {len(response.objects)} wines that pair well with steak:\\n\")\n    \n    for i, wine in enumerate(response.objects, 1):\n        print(f\"Wine {i}:\")\n        print(f\"  Title: {wine.properties['title']}\")\n        print(f\"  Country: {wine.properties['country']}\")\n        print(f\"  Price: ${wine.properties['price']}\")\n        print(f\"  Points: {wine.properties['points']}\")\n        print()\n\nfinally:\n    # Close the client connection\n    client.close()\n```\n\nThis code:\n\n1. **Connects to Weaviate Cloud** using the environment variables `WCD_TEST_URL` and `WCD_TEST_KEY`, with the OpenAI API key for the text2vec-openai vectorizer\n2. **Creates filters** for:\n   - Price less than 50\n   - Points greater than 90\n   - Review body containing at least one of the specified substrings (spice, fruit, berry, cherry, or honey)\n3. **Performs a hybrid search** with:\n   - Query: \"pair with steak\"\n   - Alpha: 0.5 (equal balance between keyword and vector search)\n   - Limit: 5 results\n4. **Prints the results** showing title, country, price, and points for each matching wine\n\nThe hybrid search combines both semantic (vector) search and keyword (BM25) search to find wines that best match the query \"pair with steak\" while meeting all the specified criteria.",
      "stdout": "Found 5 wines that pair well with steak:\n\nWine 1:\n  Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price: $40.0\n  Points: 92\n\nWine 2:\n  Title: Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price: $49.0\n  Points: 91\n\nWine 3:\n  Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price: $27.0\n  Points: 91\n\nWine 4:\n  Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price: $25.0\n  Points: 93\n\nWine 5:\n  Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price: $0.0\n  Points: 92\n\n",
      "stderr": "",
      "exit_code": 0
    }
  },
  "gemini/gemini-2.5-pro": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:33:47.074578",
      "duration": 24.23453116416931,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "Of course. Here is the Python code using the modern `v4` Weaviate client to connect to Weaviate Cloud and check the server's readiness.\n\nThis code is self-contained and includes error handling in case the environment variables are not set.\n\n### Python Code\n\n```python\n#!/usr/bin/env python3\n\nimport os\nimport sys\nimport weaviate\nfrom weaviate.auth import AuthApiKey\n\n\"\"\"\nConnects to a Weaviate Cloud (WCS) instance using environment variables\nand checks if the server is ready to accept requests.\n\"\"\"\n\n# 1. Get connection details from environment variables\ntry:\n    wcs_url = os.environ[\"WCD_TEST_URL\"]\n    wcs_api_key = os.environ[\"WCD_TEST_KEY\"]\nexcept KeyError:\n    print(\"\ud83d\uded1 Error: Make sure WCD_TEST_URL and WCD_TEST_KEY environment variables are set.\")\n    sys.exit(1)\n\n# 2. Prepare authentication credentials\nauth_credentials = AuthApiKey(api_key=wcs_api_key)\n\n# Initialize client to None so it's accessible in the `finally` block\nclient = None\ntry:\n    # 3. Connect to your Weaviate Cloud instance\n    # This is the modern syntax for the Weaviate Python client v4+\n    client = weaviate.connect_to_wcs(\n        cluster_url=wcs_url,\n        auth_credentials=auth_credentials\n    )\n    print(f\"Successfully created a client for Weaviate at {wcs_url}\")\n\n    # 4. Check if the server is ready\n    # The .is_ready() method returns True if the server is ready, False otherwise.\n    if client.is_ready():\n        print(\"\u2705 Weaviate server is ready to accept requests.\")\n    else:\n        print(\"\u26a0\ufe0f Weaviate server is NOT ready.\")\n\nexcept Exception as e:\n    print(f\"\ud83d\uded1 An error occurred while connecting or checking the server: {e}\")\n\nfinally:\n    # 5. Always close the connection\n    if client:\n        client.close()\n        print(\"Connection to Weaviate closed.\")\n\n```\n\n### How to Run This Code\n\n1.  **Install the Weaviate client:**\n    If you haven't already, install the Python client library.\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set the environment variables:**\n    Before running the script, you need to set the required environment variables in your terminal.\n\n    **For Linux/macOS:**\n    ```bash\n    export WCD_TEST_URL=\"https://your-weaviate-instance.wcs.weaviate.io\"\n    export WCD_TEST_KEY=\"your-wcs-api-key\"\n    ```\n\n    **For Windows (Command Prompt):**\n    ```cmd\n    set WCD_TEST_URL=\"https://your-weaviate-instance.wcs.weaviate.io\"\n    set WCD_TEST_KEY=\"your-wcs-api-key\"\n    ```\n\n    **For Windows (PowerShell):**\n    ```powershell\n    $env:WCD_TEST_URL=\"https://your-weaviate-instance.wcs.weaviate.io\"\n    $env:WCD_TEST_KEY=\"your-wcs-api-key\"\n    ```\n    Replace the placeholder values with your actual WCS URL and API key.\n\n3.  **Save and execute the script:**\n    Save the code above as a Python file (e.g., `connect_test.py`) and run it from your terminal.\n    ```bash\n    python connect_test.py\n    ```\n\nIf the connection is successful, you will see output like this:\n```\nSuccessfully created a client for Weaviate at https://your-weaviate-instance.wcs.weaviate.io\n\u2705 Weaviate server is ready to accept requests.\nConnection to Weaviate closed.\n```",
      "stdout": "Successfully created a client for Weaviate at yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\n\u2705 Weaviate server is ready to accept requests.\nConnection to Weaviate closed.\n",
      "stderr": "/code/code.py:29: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:34:06.676438",
      "duration": 19.56541895866394,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "Of course. Here is the Python code to connect to a Weaviate Cloud instance using environment variables and then check its readiness.\n\nThis code uses a `with` statement, which is the recommended practice as it automatically handles closing the connection to your Weaviate instance.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport sys\n\n# Get Weaviate Cloud credentials from environment variables\ntry:\n    wcd_url = os.environ[\"WCD_TEST_URL\"]\n    wcd_api_key = os.environ[\"WCD_TEST_KEY\"]\nexcept KeyError:\n    print(\"Error: WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n    sys.exit(1)\n\ntry:\n    # Connect to your Weaviate Cloud instance\n    # The 'with' statement ensures the client is closed automatically\n    with weaviate.connect_to_weaviate_cloud(\n        cluster_url=wcd_url,\n        auth_credentials=Auth.api_key(wcd_api_key)\n    ) as client:\n        # Check if the server is ready to accept requests\n        if client.is_ready():\n            print(f\"Successfully connected to Weaviate at {wcd_url}.\")\n            print(\"Weaviate is ready to accept requests.\")\n        else:\n            print(f\"Connected to Weaviate at {wcd_url}, but it is not ready.\")\n\nexcept Exception as e:\n    print(f\"An error occurred while connecting to Weaviate: {e}\")\n\n```\n\n### How to Run This Code\n\n1.  **Install the Weaviate client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set your environment variables.** You can do this in your terminal before running the script.\n\n    **On macOS/Linux:**\n    ```bash\n    export WCD_TEST_URL=\"YOUR_WEAVIATE_URL\"\n    export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n    ```\n\n    **On Windows (Command Prompt):**\n    ```bat\n    set WCD_TEST_URL=\"YOUR_WEAVIATE_URL\"\n    set WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n    ```\n\n    **On Windows (PowerShell):**\n    ```powershell\n    $env:WCD_TEST_URL=\"YOUR_WEAVIATE_URL\"\n    $env:WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n    ```\n\n3.  **Save the code** as a Python file (e.g., `connect_test.py`).\n\n4.  **Run the script:**\n    ```bash\n    python connect_test.py\n    ```\n\nIf the connection is successful, you will see the output:\n```\nSuccessfully connected to Weaviate at YOUR_WEAVIATE_URL.\nWeaviate is ready to accept requests.\n```",
      "stdout": "Successfully connected to Weaviate at yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud.\nWeaviate is ready to accept requests.\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:34:30.373874",
      "duration": 23.66042184829712,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "Of course. Here is the Python code using the latest Weaviate client (v4) syntax to create the \"DemoProducts\" collection.\n\nThis script first checks for the required environment variables, connects to your Weaviate Cloud instance, deletes the \"DemoProducts\" collection if it already exists, and then creates it with the specified properties.\n\n### Prerequisites\n\n1.  **Install the Weaviate Python client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set your environment variables:**\n    Replace `\"YOUR-WCD-URL\"` and `\"YOUR-WCD-API-KEY\"` with your actual Weaviate Cloud credentials.\n\n    **For Linux/macOS:**\n    ```bash\n    export WCD_TEST_URL=\"YOUR-WCD-URL\"\n    export WCD_TEST_KEY=\"YOUR-WCD-API-KEY\"\n    ```\n\n    **For Windows (Command Prompt):**\n    ```cmd\n    set WCD_TEST_URL=\"YOUR-WCD-URL\"\n    set WCD_TEST_KEY=\"YOUR-WCD-API-KEY\"\n    ```\n\n    **For Windows (PowerShell):**\n    ```powershell\n    $env:WCD_TEST_URL=\"YOUR-WCD-URL\"\n    $env:WCD_TEST_KEY=\"YOUR-WCD-API-KEY\"\n    ```\n\n### Python Code\n\nSave the following code as a Python file (e.g., `create_collection.py`) and run it.\n\n```python\nimport weaviate\nimport os\nimport sys\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.classes.auth import AuthApiKey\n\n# --- 1. Get Weaviate Cloud credentials from environment variables ---\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_api_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not wcd_url or not wcd_api_key:\n    print(\"Error: WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n    sys.exit(1)\n\n# Define the name for our collection\ncollection_name = \"DemoProducts\"\nclient = None  # Initialize client to None\n\ntry:\n    # --- 2. Connect to Weaviate Cloud ---\n    print(f\"Connecting to Weaviate Cloud at {wcd_url}...\")\n    client = weaviate.connect_to_wcs(\n        cluster_url=wcd_url,\n        auth_credentials=AuthApiKey(wcd_api_key)\n    )\n    print(\"Connection successful.\")\n\n    # --- 3. Check if collection exists and delete it if it does ---\n    if client.collections.exists(collection_name):\n        print(f\"Collection '{collection_name}' already exists. Deleting it.\")\n        client.collections.delete(collection_name)\n        print(f\"Collection '{collection_name}' deleted.\")\n\n    # --- 4. Create the 'DemoProducts' collection ---\n    print(f\"Creating collection '{collection_name}'...\")\n    products_collection = client.collections.create(\n        name=collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n\n    print(f\"Successfully created collection '{products_collection.name}'.\")\n\n    # --- Optional: Verify the schema ---\n    schema = client.collections.get(collection_name).config.get()\n    print(\"\\nVerifying collection schema:\")\n    print(schema.properties)\n\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # --- 5. Close the connection ---\n    if client:\n        client.close()\n        print(\"\\nConnection to Weaviate closed.\")\n\n```\n\n### How to Run the Script\n\n1.  Make sure your environment variables are set as described in the \"Prerequisites\" section.\n2.  Save the code above as `create_collection.py`.\n3.  Run the script from your terminal:\n    ```bash\n    python create_collection.py\n    ```\n\n### Expected Output\n\nIf the collection does not exist, you will see:\n```\nConnecting to Weaviate Cloud at https://your-cluster-name.weaviate.network...\nConnection successful.\nCreating collection 'DemoProducts'...\nSuccessfully created collection 'DemoProducts'.\n\nVerifying collection schema:\n[Property(name='name', data_type=<DataType.TEXT: 'text'>, ...), Property(name='description', data_type=<DataType.TEXT: 'text'>, ...), Property(name='price', data_type=<DataType.NUMBER: 'number'>, ...), Property(name='in_stock', data_type=<DataType.BOOL: 'boolean'>, ...)]\n\nConnection to Weaviate closed.\n```\n\nIf the collection already exists, the output will include the deletion steps:\n```\nConnecting to Weaviate Cloud at https://your-cluster-name.weaviate.network...\nConnection successful.\nCollection 'DemoProducts' already exists. Deleting it.\nCollection 'DemoProducts' deleted.\nCreating collection 'DemoProducts'...\nSuccessfully created collection 'DemoProducts'.\n\nVerifying collection schema:\n[...]\n\nConnection to Weaviate closed.\n```",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 5, in <module>\n    from weaviate.classes.auth import AuthApiKey\nModuleNotFoundError: No module named 'weaviate.classes.auth'\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:34:50.263738",
      "duration": 19.851737022399902,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "Of course. Here is the Python code to create a \"DemoProducts\" collection in Weaviate Cloud, using credentials from environment variables.\n\nThe code first checks if the collection exists and deletes it to ensure a clean start, as requested.\n\n### `create_collection.py`\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# --- Get Weaviate credentials from environment variables ---\n# Make sure you have these set in your environment\n# e.g., export WCD_TEST_URL=\"https://your-weaviate-url.wcd.io\"\n#       export WCD_TEST_KEY=\"your-wcd-api-key\"\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Check if the environment variables are set\nif not wcd_url or not wcd_key:\n    raise ValueError(\"WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n\n# --- Define the collection name ---\ncollection_name = \"DemoProducts\"\n\n# Use a try...finally block to ensure the client is always closed\ntry:\n    # --- Connect to the Weaviate Cloud instance ---\n    # Using the latest Weaviate client syntax (v4)\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=wcd_url,\n        auth_credentials=Auth.api_key(wcd_key),\n        # Optional: Add headers for your specific WCD instance\n        # headers={\n        #     \"X-OpenAI-Api-Key\": os.environ.get(\"OPENAI_API_KEY\")\n        # }\n    )\n    print(\"Connection successful.\")\n\n    # --- Delete the collection if it already exists ---\n    # This is useful for starting with a clean slate during development\n    if client.collections.exists(collection_name):\n        print(f\"Collection '{collection_name}' already exists. Deleting it.\")\n        client.collections.delete(collection_name)\n        print(f\"Collection '{collection_name}' deleted.\")\n\n    # --- Create the collection ---\n    print(f\"Creating collection '{collection_name}'...\")\n    products_collection = client.collections.create(\n        name=collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n\n    print(f\"Successfully created collection: '{products_collection.name}'\")\n    # You can print the configuration to verify\n    # print(\"Collection config:\")\n    # print(products_collection.config.get())\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # --- Close the connection ---\n    # The client.close() method is part of the v4 client\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"Weaviate client connection closed.\")\n\n```\n\n### How to Run the Code\n\n1.  **Install the Weaviate client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set your environment variables:**\n    Replace the placeholder values with your actual Weaviate Cloud URL and API key.\n\n    **On Linux/macOS:**\n    ```bash\n    export WCD_TEST_URL=\"https://your-weaviate-instance.wcd.io\"\n    export WCD_TEST_KEY=\"your-weaviate-api-key\"\n    ```\n\n    **On Windows (Command Prompt):**\n    ```bash\n    set WCD_TEST_URL=\"https://your-weaviate-instance.wcd.io\"\n    set WCD_TEST_KEY=\"your-weaviate-api-key\"\n    ```\n\n    **On Windows (PowerShell):**\n    ```powershell\n    $env:WCD_TEST_URL=\"https://your-weaviate-instance.wcd.io\"\n    $env:WCD_TEST_KEY=\"your-weaviate-api-key\"\n    ```\n\n3.  **Save and execute the Python script:**\n    Save the code above as a file (e.g., `create_collection.py`) and run it from your terminal:\n    ```bash\n    python create_collection.py\n    ```\n\n**Expected Output:**\n\n```\nConnecting to Weaviate Cloud...\nConnection successful.\nCollection 'DemoProducts' already exists. Deleting it.\nCollection 'DemoProducts' deleted.\nCreating collection 'DemoProducts'...\nSuccessfully created collection: 'DemoProducts'\nWeaviate client connection closed.\n```\n*(Note: The \"already exists\" message will only appear on subsequent runs.)*",
      "stdout": "Connecting to Weaviate Cloud...\nConnection successful.\nCollection 'DemoProducts' already exists. Deleting it.\nCollection 'DemoProducts' deleted.\nCreating collection 'DemoProducts'...\nSuccessfully created collection: 'DemoProducts'\nWeaviate client connection closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:35:10.696085",
      "duration": 20.39531898498535,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# This script assumes you have the WCD_TEST_URL and WCD_TEST_KEY environment\n# variables set, for example in a .env file.\n\n# For more information on client instantiation, see:\n# https://docs.weaviate.io/weaviate/client-libraries/python\n\ntry:\n    # Connect to your Weaviate Cloud instance\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\n\n    collection_name = \"DemoProducts\"\n\n    # For more information on collection management, see:\n    # https://docs.weaviate.io/weaviate/manage-data/collections\n\n    # First, check if the collection already exists. If so, delete it.\n    if client.collections.exists(collection_name):\n        print(f\"Collection '{collection_name}' already exists. Deleting it.\")\n        client.collections.delete(collection_name)\n        print(f\"Collection '{collection_name}' deleted.\")\n\n    # Create the \"DemoProducts\" collection with the specified properties.\n    print(f\"Creating collection '{collection_name}'...\")\n    products = client.collections.create(\n        name=collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n\n    print(f\"Collection '{collection_name}' created successfully.\")\n    \n    # You can verify the creation by getting the collection's configuration\n    config = products.config.get()\n    print(\"\\nCollection Configuration:\")\n    print(config)\n\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Always close the client connection when you're done\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"\\nConnection to Weaviate closed.\")\n```",
      "stdout": "Successfully connected to Weaviate Cloud.\nCollection 'DemoProducts' already exists. Deleting it.\nCollection 'DemoProducts' deleted.\nCreating collection 'DemoProducts'...\nCollection 'DemoProducts' created successfully.\n\nCollection Configuration:\n_CollectionConfig(name='DemoProducts', description=None, generative_config=None, inverted_index_config=_InvertedIndexConfig(bm25=_BM25Config(b=0.75, k1=1.2), cleanup_interval_seconds=60, index_null_state=False, index_property_length=False, index_timestamps=False, stopwords=_StopwordsConfig(preset=<StopwordsPreset.EN: 'en'>, additions=None, removals=None)), multi_tenancy_config=_MultiTenancyConfig(enabled=False, auto_tenant_creation=False, auto_tenant_activation=False), properties=[_Property(name='name', description=None, data_type=<DataType.TEXT: 'text'>, index_filterable=True, index_range_filters=False, index_searchable=True, nested_properties=None, tokenization=<Tokenization.WORD: 'word'>, vectorizer_config=None, vectorizer=None, vectorizer_configs={}), _Property(name='description', description=None, data_type=<DataType.TEXT: 'text'>, index_filterable=True, index_range_filters=False, index_searchable=True, nested_properties=None, tokenization=<Tokenization.WORD: 'word'>, vectorizer_config=None, vectorizer=None, vectorizer_configs={}), _Property(name='price', description=None, data_type=<DataType.NUMBER: 'number'>, index_filterable=True, index_range_filters=False, index_searchable=False, nested_properties=None, tokenization=None, vectorizer_config=None, vectorizer=None, vectorizer_configs={}), _Property(name='in_stock', description=None, data_type=<DataType.BOOL: 'boolean'>, index_filterable=True, index_range_filters=False, index_searchable=False, nested_properties=None, tokenization=None, vectorizer_config=None, vectorizer=None, vectorizer_configs={})], references=[], replication_config=_ReplicationConfig(factor=1, async_enabled=False, deletion_strategy=<ReplicationDeletionStrategy.NO_AUTOMATED_RESOLUTION: 'NoAutomatedResolution'>), reranker_config=None, sharding_config=_ShardingConfig(virtual_per_physical=128, desired_count=1, actual_count=1, desired_virtual_count=128, actual_virtual_count=128, key='_id', strategy='hash', function='murmur3'), vector_index_config=None, vector_index_type=None, vectorizer_config=None, vectorizer=None, vector_config={'default': _NamedVectorConfig(vectorizer=_NamedVectorizerConfig(vectorizer=<Vectorizers.NONE: 'none'>, model={}, source_properties=None), vector_index_config=_VectorIndexConfigHNSW(multi_vector=None, quantizer=None, cleanup_interval_seconds=300, distance_metric=<VectorDistances.COSINE: 'cosine'>, dynamic_ef_min=100, dynamic_ef_max=500, dynamic_ef_factor=8, ef=-1, ef_construction=128, filter_strategy=<VectorFilterStrategy.SWEEPING: 'sweeping'>, flat_search_cutoff=40000, max_connections=32, skip=False, vector_cache_max_objects=1000000000000))})\n\nConnection to Weaviate closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:35:41.737037",
      "duration": 30.337735176086426,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Of course! Here is the Python code to connect to a Weaviate Cloud instance, create a collection, batch import 50 objects, and then verify the count.\n\nThis script uses the modern `weaviate-client` v4 syntax.\n\n### Prerequisites\n\n1.  **Install the Weaviate Python client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set environment variables:**\n    Before running the script, make sure you have set the required environment variables.\n\n    *   **For Linux/macOS:**\n        ```bash\n        export WCD_TEST_URL=\"YOUR-WEAVIATE-CLOUD-URL\"\n        export WCD_TEST_KEY=\"YOUR-WEAVIATE-API-KEY\"\n        ```\n    *   **For Windows (Command Prompt):**\n        ```bash\n        set WCD_TEST_URL=\"YOUR-WEAVIATE-CLOUD-URL\"\n        set WCD_TEST_KEY=\"YOUR-WEAVIATE-API-KEY\"\n        ```\n    *   **For Windows (PowerShell):**\n        ```bash\n        $env:WCD_TEST_URL=\"YOUR-WEAVIATE-CLOUD-URL\"\n        $env:WCD_TEST_KEY=\"YOUR-WEAVIATE-API-KEY\"\n        ```\n\n    Replace `YOUR-WEAVIATE-CLOUD-URL` and `YOUR-WEAVIATE-API-KEY` with your actual credentials from the Weaviate Cloud console.\n\n### Python Script\n\n```python\nimport os\nimport weaviate\nimport weaviate.auth as wa\nfrom weaviate.classes.config import Property, DataType\n\n# --- 1. Configuration ---\nWCD_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_API_KEY = os.getenv(\"WCD_TEST_KEY\")\nCOLLECTION_NAME = \"DemoProducts\"\n\n# Check for environment variables\nif not WCD_URL or not WCD_API_KEY:\n    raise ValueError(\n        \"WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\"\n    )\n\nprint(\"Connecting to Weaviate Cloud...\")\n\n# --- 2. Connect to Weaviate Cloud ---\n# Use a `try...finally` block to ensure the client is closed properly.\n# The `with` statement is the recommended Pythonic way to handle this.\ntry:\n    with weaviate.connect_to_wcs(\n        cluster_url=WCD_URL,\n        auth_credentials=wa.AuthApiKey(WCD_API_KEY),\n    ) as client:\n\n        print(f\"Successfully connected to Weaviate: {client.is_ready()}\")\n\n        # --- 3. Recreate the Collection ---\n        # To ensure the script is repeatable, we first delete the collection if it exists.\n        if client.collections.exists(COLLECTION_NAME):\n            print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it.\")\n            client.collections.delete(COLLECTION_NAME)\n\n        print(f\"Creating collection '{COLLECTION_NAME}'...\")\n        client.collections.create(\n            name=COLLECTION_NAME,\n            properties=[\n                Property(name=\"name\", data_type=DataType.TEXT),\n                Property(name=\"description\", data_type=DataType.TEXT),\n            ],\n            # If you are not using a generative module, you can specify the vectorizer.\n            # For example, using the free `text2vec-openai` model:\n            # vectorizer_config=Configure.Vectorizer.text2vec_openai()\n        )\n        print(\"Collection created successfully.\")\n\n        # --- 4. Batch Import Data ---\n        # Get the collection object\n        products = client.collections.get(COLLECTION_NAME)\n\n        print(f\"Generating 50 objects for batch import...\")\n        objects_to_add = []\n        for i in range(50):\n            objects_to_add.append(\n                {\n                    \"name\": f\"Product {i}\",\n                    \"description\": f\"This is the description for product number {i}.\",\n                }\n            )\n\n        print(\"Starting batch import...\")\n        # Use a context manager for batching.\n        # `dynamic()` automatically handles batch size and sends requests.\n        with products.batch.dynamic() as batch:\n            for data_object in objects_to_add:\n                batch.add_object(properties=data_object)\n        \n        print(\"Batch import complete.\")\n\n        # --- 5. Verify the number of objects ---\n        # Use aggregation to get the total count of objects in the collection.\n        response = products.aggregate.over_all(total_count=True)\n\n        print(\"\\n--- Verification ---\")\n        print(f\"Total number of objects in '{COLLECTION_NAME}': {response.total_count}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\n```\n\n### How to Run the Script\n\n1.  Save the code above as a Python file (e.g., `import_products.py`).\n2.  Make sure your environment variables are set correctly in your terminal.\n3.  Run the script from your terminal:\n    ```bash\n    python import_products.py\n    ```\n\n### Expected Output\n\n```\nConnecting to Weaviate Cloud...\nSuccessfully connected to Weaviate: True\nCollection 'DemoProducts' already exists. Deleting it.\nCreating collection 'DemoProducts'...\nCollection created successfully.\nGenerating 50 objects for batch import...\nStarting batch import...\nBatch import complete.\n\n--- Verification ---\nTotal number of objects in 'DemoProducts': 50\n```\n\n*(Note: The line \"Collection 'DemoProducts' already exists. Deleting it.\" will only appear on the second and subsequent runs of the script.)*",
      "stdout": "Connecting to Weaviate Cloud...\nSuccessfully connected to Weaviate: True\nCollection 'DemoProducts' already exists. Deleting it.\nCreating collection 'DemoProducts'...\nCollection created successfully.\nGenerating 50 objects for batch import...\nStarting batch import...\nBatch import complete.\n\n--- Verification ---\nTotal number of objects in 'DemoProducts': 50\n",
      "stderr": "/code/code.py:23: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  with weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:36:11.346438",
      "duration": 28.912011861801147,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "Here is the Python code to add 50 objects to a \"DemoProducts\" collection in Weaviate Cloud using the latest Weaviate client (v4) syntax.\n\nThis script performs the following actions:\n1.  Connects to a Weaviate Cloud instance using environment variables.\n2.  Deletes the \"DemoProducts\" collection if it already exists for a clean run.\n3.  Creates a new \"DemoProducts\" collection with `name` and `description` text properties.\n4.  Generates 50 sample product objects.\n5.  Uses the batch import functionality to add all 50 objects efficiently.\n6.  Checks for any import errors and reports them.\n7.  Prints the final count of objects in the collection to verify the import.\n8.  Closes the connection to Weaviate.\n\n### Prerequisites\n\nBefore running the code, make sure you have:\n1.  Installed the Weaviate Python client: `pip install weaviate-client`\n2.  Set the following environment variables with your Weaviate Cloud credentials:\n    - `WCD_TEST_URL`: The URL of your Weaviate cluster (e.g., `https://my-cluster.weaviate.network`).\n    - `WCD_TEST_KEY`: The API key for your Weaviate cluster.\n\n### Python Code\n\n```python\nimport weaviate\nimport weaviate.classes as wvc\nimport os\nimport sys\n\n# 1. Get Weaviate credentials from environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_api_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if the environment variables are set\nif not wcd_url or not wcd_api_key:\n    print(\"Error: WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\", file=sys.stderr)\n    sys.exit(1)\n\n# --- Main execution ---\nclient = None  # Initialize client to None for the finally block\ntry:\n    # 2. Connect to Weaviate Cloud\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=wcd_url,\n        auth_credentials=weaviate.auth.AuthApiKey(wcd_api_key),\n    )\n    print(\"Connection successful.\")\n\n    collection_name = \"DemoProducts\"\n\n    # 3. Recreate the collection\n    # This ensures a clean start for the demo.\n    if client.collections.exists(collection_name):\n        print(f\"Deleting existing collection: '{collection_name}'\")\n        client.collections.delete(collection_name)\n\n    print(f\"Creating collection: '{collection_name}'\")\n    products = client.collections.create(\n        name=collection_name,\n        properties=[\n            wvc.config.Property(name=\"name\", data_type=wvc.config.DataType.TEXT),\n            wvc.config.Property(name=\"description\", data_type=wvc.config.DataType.TEXT),\n        ]\n    )\n    print(f\"Collection '{collection_name}' created successfully.\")\n\n    # 4. Prepare data for batch import\n    num_objects_to_add = 50\n    print(f\"Preparing {num_objects_to_add} objects for import...\")\n    data_objects = [\n        {\n            \"name\": f\"Product {i}\",\n            \"description\": f\"This is the description for product number {i}.\",\n        }\n        for i in range(1, num_objects_to_add + 1)\n    ]\n\n    # 5. Batch import objects\n    print(f\"Starting batch import of {len(data_objects)} objects...\")\n    with products.batch.dynamic() as batch:\n        for obj in data_objects:\n            batch.add_object(\n                properties=obj\n            )\n\n    # 6. Check for and report any import errors\n    if products.batch.failed_objects:\n        print(f\"Failed to import {len(products.batch.failed_objects)} objects.\")\n        # Optionally, print details of the first few failed objects\n        for i, failed in enumerate(products.batch.failed_objects):\n            if i >= 5: # Limit printing to the first 5 errors\n                break\n            print(f\"  - Failed object details: {failed.message}\")\n    else:\n        print(\"All objects imported successfully.\")\n\n    # 7. Print the number of objects in the collection\n    # The `len()` function provides a convenient way to get the object count.\n    object_count = len(products)\n    print(f\"\\nTotal number of objects in '{collection_name}': {object_count}\")\n\nfinally:\n    # 8. Close the client connection\n    if client:\n        client.close()\n        print(\"Client connection closed.\")\n\n```\n\n### How to Run\n\n1.  Save the code above as a Python file (e.g., `import_products.py`).\n2.  Set your environment variables in your terminal:\n    ```bash\n    export WCD_TEST_URL=\"https://your-cluster-url.weaviate.network\"\n    export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n    ```\n3.  Run the script from your terminal:\n    ```bash\n    python import_products.py\n    ```\n\n### Expected Output\n\n```\nConnecting to Weaviate Cloud...\nConnection successful.\nDeleting existing collection: 'DemoProducts'\nCreating collection: 'DemoProducts'\nCollection 'DemoProducts' created successfully.\nPreparing 50 objects for import...\nStarting batch import of 50 objects...\nAll objects imported successfully.\n\nTotal number of objects in 'DemoProducts': 50\nClient connection closed.\n```",
      "stdout": "Connecting to Weaviate Cloud...\nConnection successful.\nDeleting existing collection: 'DemoProducts'\nCreating collection: 'DemoProducts'\nCollection 'DemoProducts' created successfully.\nPreparing 50 objects for import...\nStarting batch import of 50 objects...\nAll objects imported successfully.\n\nTotal number of objects in 'DemoProducts': 50\nClient connection closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:36:36.983744",
      "duration": 24.943046808242798,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.classes.init import Auth\n\n# This script demonstrates how to create a collection, batch import objects,\n# and count the total number of objects using the Weaviate Python client v4.\n\n# It connects to a Weaviate Cloud (WCD) instance, so you must have the\n# WCD_TEST_URL and WCD_TEST_KEY environment variables set.\n\n# 1. Get Weaviate Cloud credentials from environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_api_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not wcd_url or not wcd_api_key:\n    raise ValueError(\"WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n\nclient = None\ntry:\n    # 2. Connect to Weaviate Cloud\n    # For more information, see: https://weaviate.io/developers/weaviate/client-libraries/python#connection\n    print(f\"Connecting to Weaviate Cloud at {wcd_url}...\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=wcd_url,\n        auth_credentials=Auth.api_key(wcd_api_key),\n    )\n    print(\"Connection successful.\")\n\n    collection_name = \"DemoProducts\"\n\n    # 3. Create a collection\n    # For more information, see: https://weaviate.io/developers/weaviate/manage-data/collections\n    \n    # Clean up previous runs: delete the collection if it already exists\n    if client.collections.exists(collection_name):\n        print(f\"Deleting existing collection: '{collection_name}'\")\n        client.collections.delete(collection_name)\n\n    print(f\"Creating new collection: '{collection_name}'\")\n    products_collection = client.collections.create(\n        name=collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n        ]\n    )\n    print(f\"Collection '{collection_name}' created.\")\n\n    # 4. Batch import objects\n    # For more information, see: https://weaviate.io/developers/weaviate/manage-data/import\n    print(\"Starting batch import of 50 objects...\")\n\n    # Use a context manager for batching. This is the recommended way to import data.\n    # It automatically handles sending batches and managing errors.\n    with products_collection.batch.fixed_size(batch_size=25) as batch:\n        for i in range(50):\n            product_object = {\n                \"name\": f\"Product {i}\",\n                \"description\": f\"This is the description for product number {i}.\"\n            }\n            batch.add_object(properties=product_object)\n\n    # Check for errors during batch import\n    if len(products_collection.batch.failed_objects) > 0:\n        print(f\"Failed to import {len(products_collection.batch.failed_objects)} objects.\")\n    else:\n        print(\"Batch import completed successfully.\")\n\n\n    # 5. Get and print the number of objects in the collection\n    # The aggregate.total_count() method is the most efficient way to get the object count.\n    total_count = products_collection.aggregate.total_count()\n    print(f\"\\nTotal number of objects in '{collection_name}': {total_count}\")\n\nfinally:\n    # 6. Close the client connection\n    if client:\n        client.close()\n        print(\"\\nClient connection closed.\")\n\n```",
      "stdout": "Connecting to Weaviate Cloud at yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud...\nConnection successful.\nDeleting existing collection: 'DemoProducts'\nCreating new collection: 'DemoProducts'\nCollection 'DemoProducts' created.\nStarting batch import of 50 objects...\nBatch import completed successfully.\n\nClient connection closed.\n",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 74, in <module>\n    total_count = products_collection.aggregate.total_count()\nAttributeError: '_AggregateCollection' object has no attribute 'total_count'\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:36:59.680083",
      "duration": 22.25255799293518,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Of course! Here is the Python code to perform the requested query using the latest Weaviate client syntax (v4).\n\n### Prerequisites\n\n1.  **Install Weaviate Client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set Environment Variables:**\n    You need to set the following environment variables. You can do this in your terminal or by using a `.env` file with a library like `python-dotenv`.\n\n    ```bash\n    export WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n    export WCD_TEST_KEY=\"YOUR_WEAVIATE_CLOUD_API_KEY\"\n    export OPENAI_API_KEY=\"YOUR_OPENAI_API_KEY\"\n    ```\n\n    Replace the placeholder values with your actual credentials.\n\n### Python Code\n\n```python\nimport weaviate\nimport os\n\n# --- 1. Connect to Weaviate Cloud ---\n# Get connection details from environment variables\ntry:\n    wcd_url = os.environ[\"WCD_TEST_URL\"]\n    wcd_api_key = os.environ[\"WCD_TEST_KEY\"]\n    openai_api_key = os.environ[\"OPENAI_API_KEY\"]\nexcept KeyError as e:\n    print(f\"Error: Environment variable {e} not set.\")\n    print(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY.\")\n    exit(1)\n\n# Set up authentication credentials for Weaviate\nauth_credentials = weaviate.auth.AuthApiKey(api_key=wcd_api_key)\n\n# Connect to the Weaviate instance\n# We pass the OpenAI API key in the headers for the text2vec-openai vectorizer\ntry:\n    client = weaviate.connect_to_wcs(\n        cluster_url=wcd_url,\n        auth_credentials=auth_credentials,\n        headers={\n            \"X-OpenAI-Api-Key\": openai_api_key\n        }\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\n\n    # --- 2. Prepare and Execute the Query ---\n    # Get a handle to the 'WineReview' collection\n    reviews = client.collections.get(\"WineReview\")\n\n    # Define the search query\n    search_query = \"dessert wine\"\n\n    print(f\"\\nSearching for wines similar to: '{search_query}'\\n\")\n\n    # Execute the vector search (near_text) query\n    response = reviews.query.near_text(\n        query=search_query,\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # --- 3. Print the Results ---\n    if not response.objects:\n        print(\"No results found.\")\n    else:\n        print(\"Found matching wines:\")\n        for i, wine in enumerate(response.objects):\n            # The properties are stored in the .properties attribute\n            props = wine.properties\n            print(f\"--- Result {i+1} ---\")\n            print(f\"  Title:   {props.get('title')}\")\n            print(f\"  Country: {props.get('country')}\")\n            print(f\"  Price:   ${props.get('price'):.2f}\" if props.get('price') is not None else \"  Price:   N/A\")\n            print(f\"  Points:  {props.get('points')}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # --- 4. Close the connection ---\n    # It's good practice to close the connection when you're done\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"\\nConnection to Weaviate closed.\")\n\n```\n\n### How the Code Works\n\n1.  **Import Libraries**: It imports `weaviate` for client operations and `os` to access environment variables.\n2.  **Connect to Weaviate**:\n    *   It retrieves the Weaviate URL, Weaviate API key, and OpenAI API key from environment variables.\n    *   It uses `weaviate.auth.AuthApiKey` to prepare the authentication token.\n    *   `weaviate.connect_to_wcs` establishes a secure connection to your Weaviate Cloud instance. The OpenAI key is passed in the `headers` so that the `text2vec-openai` module can vectorize the query.\n3.  **Execute Query**:\n    *   `client.collections.get(\"WineReview\")` gets a reference to the specific collection we want to query.\n    *   `reviews.query.near_text(...)` performs the vector search.\n        *   `query=\"dessert wine\"`: This text is sent to OpenAI's API to be converted into a vector. Weaviate then searches for objects with vectors most similar to this query vector.\n        *   `limit=2`: This restricts the number of results to a maximum of two.\n        *   `return_properties=[...]`: This specifies which data fields to include in the search results.\n4.  **Process Results**:\n    *   The results are located in the `response.objects` list.\n    *   The code iterates through this list, and for each returned object (`wine`), it accesses its data via the `wine.properties` dictionary.\n    *   Finally, it prints the requested fields in a user-friendly format.\n5.  **Close Connection**: The `finally` block ensures that `client.close()` is called to gracefully terminate the connection to Weaviate, even if an error occurs.",
      "stdout": "Successfully connected to Weaviate Cloud.\n\nSearching for wines similar to: 'dessert wine'\n\nFound matching wines:\n--- Result 1 ---\n  Title:   Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price:   $24.00\n  Points:  88\n--- Result 2 ---\n  Title:   Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price:   $40.00\n  Points:  88\n\nConnection to Weaviate closed.\n",
      "stderr": "/code/code.py:21: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:37:19.722557",
      "duration": 19.585593938827515,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Check for environment variables\nwcd_url = os.getenv(\"WCD_TEST_URL\")\nwcd_api_key = os.getenv(\"WCD_TEST_KEY\")\nopenai_api_key = os.getenv(\"OPENAI_API_KEY\")\n\nif not all([wcd_url, wcd_api_key, openai_api_key]):\n    print(\n        \"Error: Make sure WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY \"\n        \"environment variables are set.\"\n    )\n    exit(1)\n\n# It's a good practice to wrap the client connection in a try...finally block\n# to ensure the connection is always closed.\ntry:\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=wcd_url,\n        auth_credentials=Auth.api_key(wcd_api_key),\n        headers={\n            # Pass the OpenAI API key for the text2vec-openai vectorizer\n            \"X-OpenAI-API-Key\": openai_api_key\n        },\n    )\n\n    # Get a reference to the 'WineReview' collection\n    reviews = client.collections.get(\"WineReview\")\n\n    # Perform the near_text (semantic) search\n    response = reviews.query.near_text(\n        query=\"dessert wine\",\n        limit=2\n    )\n\n    print(\"Found wines matching 'dessert wine':\\n\")\n\n    # Iterate through the results and print the desired properties\n    for item in response.objects:\n        properties = item.properties\n        print(f\"  - Title: {properties.get('title')}\")\n        print(f\"    Country: {properties.get('country')}\")\n        print(f\"    Price: ${properties.get('price')}\")\n        print(f\"    Points: {properties.get('points')}\\n\")\n\nfinally:\n    # Close the connection to Weaviate\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"Client connection closed.\")\n```\n\n### To run this code:\n\n1.  **Install libraries:**\n    ```bash\n    pip install weaviate-client python-dotenv\n    ```\n\n2.  **Set environment variables:**\n    Create a file named `.env` in the same directory with your credentials:\n    ```\n    WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n    WCD_TEST_KEY=\"YOUR_WEAVIATE_CLOUD_API_KEY\"\n    OPENAI_API_KEY=\"YOUR_OPENAI_API_KEY\"\n    ```\n\n3.  **Run the script:**\n    You'll need a way to load the `.env` file. You can modify the Python script to use `dotenv` or load them in your shell before running.\n\n    **Option A: Modify the script**\n    Add this to the top of the Python file:\n    ```python\n    from dotenv import load_dotenv\n    load_dotenv()\n    ```\n\n    **Option B: Use your shell**\n    ```bash\n    # For Linux/macOS\n    export $(cat .env | xargs)\n\n    # For Windows (Command Prompt)\n    for /F \"tokens=*\" %A in (.env) do set %A\n\n    # Then run the script\n    python your_script_name.py\n    ```\n\n4.  **Expected Output:**\n    The script will print the title, country, price, and points for the two wine reviews that are most semantically similar to \"dessert wine\". The output will look something like this (actual results will vary based on your data):\n\n    ```\n    Found wines matching 'dessert wine':\n\n      - Title: Inniskillin 2008 Vidal Icewine (Niagara Peninsula)\n        Country: Canada\n        Price: $92.0\n        Points: 92\n\n      - Title: Royal DeMaria 2006 Meritage Icewine (Niagara Peninsula)\n        Country: Canada\n        Price: $390.0\n        Points: 94\n\n    Client connection closed.\n    ```",
      "stdout": "Found wines matching 'dessert wine':\n\n  - Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n    Country: US\n    Price: $24.0\n    Points: 88\n\n  - Title: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n    Country: US\n    Price: $40.0\n    Points: 88\n\nClient connection closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:37:36.958496",
      "duration": 16.843688011169434,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\n\n# This script requires environment variables for Weaviate Cloud and OpenAI.\n# Make sure to set the following before running the script:\n# WCD_TEST_URL: The URL of your Weaviate Cloud instance.\n# WCD_TEST_KEY: The API key for your Weaviate Cloud instance.\n# OPENAI_API_KEY: Your OpenAI API key.\n\ntry:\n    # Connect to Weaviate Cloud using environment variables\n    # For more information, see the Python Client library page:\n    # https://docs.weaviate.io/weaviate/client-libraries/python\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\n            \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # API key for the vectorizer\n        }\n    )\n\n    # Get a handle to the 'WineReview' collection\n    reviews = client.collections.get(\"WineReview\")\n\n    # Perform a semantic search (near_text) to find wines matching the query.\n    # The 'text2vec-openai' vectorizer will convert the query \"dessert wine\"\n    # into a vector and find the two most similar wine reviews.\n    # For more information on searching, see:\n    # https://docs.weaviate.io/weaviate/search\n    response = reviews.query.near_text(\n        query=\"dessert wine\",\n        limit=2\n    )\n\n    print(\"Found wines matching 'dessert wine':\")\n    # Iterate through the results and print the requested properties\n    for item in response.objects:\n        # Access the properties of each returned object\n        properties = item.properties\n        print(f\"  Title: {properties.get('title')}\")\n        print(f\"  Country: {properties.get('country')}\")\n        print(f\"  Price: {properties.get('price')}\")\n        print(f\"  Points: {properties.get('points')}\")\n        print(\"-\" * 20)\n\nexcept KeyError as e:\n    print(f\"Error: Environment variable {e} not set.\")\n    print(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY.\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    # Always close the connection to Weaviate\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"Connection to Weaviate closed.\")\n```",
      "stdout": "Found wines matching 'dessert wine':\n  Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price: 24.0\n  Points: 88\n--------------------\n  Title: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price: 40.0\n  Points: 88\n--------------------\nConnection to Weaviate closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:38:07.328921",
      "duration": 29.887729167938232,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Of course. Here is the Python code to perform the specified hybrid search on the 'WineReview' collection using the latest Weaviate client syntax (v4).\n\nThis script connects to a Weaviate Cloud instance, performs a hybrid search balanced between keyword and vector search, and applies multiple filters to the results.\n\n### Prerequisites\n\n1.  **Install necessary libraries:**\n    ```bash\n    pip install weaviate-client python-dotenv\n    ```\n2.  **Set up environment variables:**\n    Create a file named `.env` in the same directory as your script and add your credentials:\n    ```.env\n    # Weaviate Cloud Service (WCS) credentials\n    WCD_TEST_URL=\"your-wcs-instance-url\"\n    WCD_TEST_KEY=\"your-wcs-api-key\"\n\n    # OpenAI API Key for the vectorizer\n    OPENAI_API_KEY=\"your-openai-api-key\"\n    ```\n\n### Python Code\n\n```python\nimport weaviate\nimport os\nfrom weaviate.classes.query import Filter\nfrom dotenv import load_dotenv\n\n# Load environment variables from .env file\nload_dotenv()\n\n# 1. Get environment variables\nwcs_url = os.getenv(\"WCD_TEST_URL\")\nwcs_key = os.getenv(\"WCD_TEST_KEY\")\nopenai_key = os.getenv(\"OPENAI_API_KEY\")\n\n# Check if environment variables are set\nif not all([wcs_url, wcs_key, openai_key]):\n    print(\"Error: Required environment variables (WCD_TEST_URL, WCD_TEST_KEY, OPENAI_API_KEY) are not set.\")\n    exit(1)\n\n# Define headers for API keys, as required by the text2vec-openai vectorizer\nheaders = {\n    \"X-OpenAI-Api-Key\": openai_key\n}\n\n# 2. Connect to Weaviate Cloud\ntry:\n    client = weaviate.connect_to_wcs(\n        cluster_url=wcs_url,\n        auth_credentials=weaviate.auth.AuthApiKey(wcs_key),\n        headers=headers\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\n\n    # Get a handle to the 'WineReview' collection\n    reviews = client.collections.get(\"WineReview\")\n\n    # 3. Define the filters\n    # We need to combine three conditions with an AND logic:\n    # - price is less than 50\n    # - points is greater than 90\n    # - review_body contains AT LEAST ONE of the specified substrings (OR logic)\n\n    # This filter handles the OR condition for the review body\n    review_body_filter = Filter.any_of([\n        Filter.by_property(\"review_body\").like(\"*spice*\"),\n        Filter.by_property(\"review_body\").like(\"*fruit*\"),\n        Filter.by_property(\"review_body\").like(\"*berry*\"),\n        Filter.by_property(\"review_body\").like(\"*cherry*\"),\n        Filter.by_property(\"review_body\").like(\"*honey*\"),\n    ])\n\n    # Combine all filters using all_of for the final AND logic\n    final_filters = Filter.all_of([\n        Filter.by_property(\"price\").less_than(50),\n        Filter.by_property(\"points\").greater_than(90),\n        review_body_filter\n    ])\n\n    # 4. Execute the hybrid query\n    query_text = \"pair with steak\"\n    print(f\"\\nPerforming hybrid search for: '{query_text}'\")\n    print(\"With filters: price < 50, points > 90, and matching keywords in review.\\n\")\n\n\n    response = reviews.query.hybrid(\n        query=query_text,\n        limit=5,\n        alpha=0.5,  # 0.0 for pure keyword, 1.0 for pure vector, 0.5 for equal balance\n        filters=final_filters,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # 5. Print the results\n    if response.objects:\n        print(\"Found the following matching wines:\")\n        print(\"-\" * 80)\n        for item in response.objects:\n            wine = item.properties\n            print(f\"  Title:   {wine.get('title')}\")\n            print(f\"  Country: {wine.get('country')}\")\n            print(f\"  Price:   ${wine.get('price'):.2f}\")\n            print(f\"  Points:  {wine.get('points')}\")\n            print(\"-\" * 80)\n    else:\n        print(\"No wines found matching the specified criteria.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # 6. Close the connection\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"\\nConnection to Weaviate closed.\")\n```\n\n### Explanation\n\n1.  **Environment Variables**: The script securely loads your Weaviate and OpenAI credentials from environment variables using `python-dotenv` and `os.getenv`.\n2.  **Connection**: It uses `weaviate.connect_to_wcs` to establish a connection to your Weaviate Cloud instance. The OpenAI API key is passed in the `headers` dictionary, which the instance will use for vectorization at query time.\n3.  **Filter Construction**:\n    *   The `weaviate.classes.query.Filter` object is used to build the complex filtering logic.\n    *   `Filter.any_of([...])` creates the `OR` condition for the substrings in the `review_body`. The `like` operator with `*` wildcards checks for the presence of a substring anywhere in the text.\n    *   `Filter.all_of([...])` combines the price, points, and review body filters with an `AND` logic, ensuring all conditions must be met.\n4.  **Hybrid Query**:\n    *   `reviews.query.hybrid(...)` is the modern syntax for performing a hybrid search.\n    *   `query`: The natural language query to match.\n    *   `limit`: Sets the maximum number of results to 5.\n    *   `alpha=0.5`: Balances the BM25 (keyword) and vector (semantic) search scores equally.\n    *   `filters`: Applies the combined filter object to the search results. Only items that pass the filter are considered for the hybrid search ranking.\n    *   `return_properties`: Specifies which fields to include in the response, making the query more efficient.\n5.  **Output**: The script iterates through the `response.objects` and prints the requested properties (`title`, `country`, `price`, `points`) for each result in a clean, readable format.\n6.  **Connection Closing**: The `finally` block ensures that the connection to Weaviate is properly closed, whether the query succeeds or fails.",
      "stdout": "Successfully connected to Weaviate Cloud.\n\nPerforming hybrid search for: 'pair with steak'\nWith filters: price < 50, points > 90, and matching keywords in review.\n\nFound the following matching wines:\n--------------------------------------------------------------------------------\n  Title:   Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price:   $40.00\n  Points:  92\n--------------------------------------------------------------------------------\n  Title:   Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price:   $49.00\n  Points:  91\n--------------------------------------------------------------------------------\n  Title:   Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price:   $27.00\n  Points:  91\n--------------------------------------------------------------------------------\n  Title:   Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price:   $25.00\n  Points:  93\n--------------------------------------------------------------------------------\n  Title:   Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price:   $0.00\n  Points:  92\n--------------------------------------------------------------------------------\n\nConnection to Weaviate closed.\n",
      "stderr": "/code/code.py:26: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:38:32.563548",
      "duration": 24.8106050491333,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "Here is the Python code to perform the specified hybrid search on the 'WineReview' collection using the Weaviate v4 client.\n\nThis script connects to a Weaviate Cloud instance, executes a hybrid query to find wines that pair well with steak, and applies several filters based on price, points, and review content.\n\n### Prerequisites\n1.  **Install Weaviate Client**:\n    ```bash\n    pip install weaviate-client\n    ```\n2.  **Set Environment Variables**:\n    Make sure you have set the following environment variables in your terminal or system:\n    ```bash\n    export WCD_TEST_URL=\"your-weaviate-cloud-url\"\n    export WCD_TEST_KEY=\"your-weaviate-api-key\"\n    export OPENAI_API_KEY=\"your-openai-api-key\"\n    ```\n\n### Python Code\n\n```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\nimport os\nimport sys\n\n# --- 1. Check for and load environment variables ---\ntry:\n    wcd_url = os.environ[\"WCD_TEST_URL\"]\n    wcd_api_key = os.environ[\"WCD_TEST_KEY\"]\n    openai_api_key = os.environ[\"OPENAI_API_KEY\"]\nexcept KeyError as e:\n    print(f\"\u274c Error: Environment variable {e} is not set.\")\n    print(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY.\")\n    sys.exit(1)\n\n# --- 2. Connect to Weaviate Cloud ---\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=wcd_url,\n        auth_credentials=Auth.api_key(wcd_api_key),\n        headers={\n            \"X-OpenAI-API-Key\": openai_api_key\n        },\n    )\n    print(\"\u2705 Successfully connected to Weaviate Cloud.\")\nexcept Exception as e:\n    print(f\"\u274c Error connecting to Weaviate: {e}\")\n    sys.exit(1)\n\n\n# --- 3. Define the query and filters ---\ncollection_name = \"WineReview\"\nquery_text = \"pair with steak\"\n\n# Define the combined filter for the query\n# This uses the `&` operator to chain multiple conditions with a logical AND.\nfilters = (\n    # Condition 1: Price must be less than 50\n    Filter.by_property(\"price\").less_than(50) &\n    # Condition 2: Points must be greater than 90\n    Filter.by_property(\"points\").greater_than(90) &\n    # Condition 3: The review must contain at least one of these words\n    Filter.by_property(\"review_body\").contains_any(\n        [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n    )\n)\n\n# --- 4. Execute the hybrid search query ---\ntry:\n    # Get the collection object\n    wine_reviews = client.collections.get(collection_name)\n\n    # Perform the hybrid search\n    response = wine_reviews.query.hybrid(\n        query=query_text,\n        limit=5,          # Maximum of 5 results\n        alpha=0.5,        # Balance between keyword and vector search\n        filters=filters   # Apply the defined filters\n    )\n\n    # --- 5. Print the results ---\n    print(f\"\\nFound {len(response.objects)} wines matching your query:\\n\")\n\n    if not response.objects:\n        print(\"No results found. Try adjusting your query or filters.\")\n    else:\n        for i, obj in enumerate(response.objects):\n            # Access the properties of each returned object\n            properties = obj.properties\n            \n            print(f\"--- Result {i+1} ---\")\n            print(f\"  Title:   {properties.get('title')}\")\n            print(f\"  Country: {properties.get('country')}\")\n            print(f\"  Price:   ${properties.get('price')}\")\n            print(f\"  Points:  {properties.get('points')}\")\n\nfinally:\n    # --- 6. Close the connection ---\n    # It's good practice to close the connection when you're done.\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"\\n\u2705 Connection to Weaviate closed.\")\n```\n\n### How the Code Works\n\n1.  **Environment Variables**: It first ensures that the necessary credentials (`WCD_TEST_URL`, `WCD_TEST_KEY`, `OPENAI_API_KEY`) are available as environment variables.\n2.  **Connection**: It uses `weaviate.connect_to_weaviate_cloud` to establish a secure connection to your Weaviate instance. The OpenAI API key is passed in the `headers` dictionary, which is required by the `text2vec-openai` vectorizer.\n3.  **Filter Definition**: It constructs a multi-condition filter using the `Filter` class. The `&` operator combines the filters, ensuring that a result must satisfy all three conditions: be priced under 50, have over 90 points, and contain one of the specified keywords in its review.\n4.  **Hybrid Query**: It calls the `.query.hybrid()` method on the `WineReview` collection object.\n    *   `query`: The natural language query to search for.\n    *   `limit`: Restricts the output to a maximum of 5 results.\n    *   `alpha=0.5`: Specifies a balanced hybrid search, giving equal weight to the keyword-based (BM25) search and the vector-based (semantic) search.\n    *   `filters`: Applies the previously defined filter object to the search.\n5.  **Result Processing**: It iterates through the `response.objects` list. For each returned wine, it accesses the `properties` dictionary and prints the requested fields (`title`, `country`, `price`, `points`) in a formatted way.\n6.  **Connection Closing**: The `finally` block ensures that the connection to Weaviate is always closed, even if an error occurs during the query.",
      "stdout": "\u2705 Successfully connected to Weaviate Cloud.\n\nFound 5 wines matching your query:\n\n--- Result 1 ---\n  Title:   Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price:   $40.0\n  Points:  92\n--- Result 2 ---\n  Title:   Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price:   $49.0\n  Points:  91\n--- Result 3 ---\n  Title:   Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price:   $27.0\n  Points:  91\n--- Result 4 ---\n  Title:   Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price:   $25.0\n  Points:  93\n--- Result 5 ---\n  Title:   Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price:   $0.0\n  Points:  92\n\n\u2705 Connection to Weaviate closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:38:55.089018",
      "duration": 22.102572917938232,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\n\n# This script performs a hybrid search on a 'WineReview' collection in Weaviate.\n# It finds up to 5 wines that are a good match for \"pair with steak\",\n# cost less than 50, have a rating over 90 points, and have specific\n# keywords in their review body.\n\n# Ensure required environment variables are set\nrequired_env_vars = [\"WCD_TEST_URL\", \"WCD_TEST_KEY\", \"OPENAI_API_KEY\"]\nfor var in required_env_vars:\n    if var not in os.environ:\n        raise EnvironmentError(\n            f\"Required environment variable '{var}' is not set. \"\n            \"Please set it before running the script.\"\n        )\n\ntry:\n    # Connect to Weaviate Cloud using environment variables\n    # For more information on connecting to Weaviate, see:\n    # https://weaviate.io/developers/weaviate/client-libraries/python\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\n            \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n        }\n    )\n\n    # Get a reference to the 'WineReview' collection\n    reviews = client.collections.get(\"WineReview\")\n\n    # Define the filters to apply to the search results\n    # For more information on filtering, see:\n    # https://weaviate.io/developers/weaviate/search/filters\n    \n    # 1. Filter for price less than 50\n    price_filter = Filter.by_property(\"price\").less_than(50)\n\n    # 2. Filter for points greater than 90\n    points_filter = Filter.by_property(\"points\").greater_than(90)\n\n    # 3. Filter for at least one keyword in the review_body\n    keywords = [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n    keyword_filters = [\n        Filter.by_property(\"review_body\").like(f\"*{keyword}*\") for keyword in keywords\n    ]\n    # Combine the keyword filters using an 'OR' condition\n    review_body_filter = Filter.any_of(keyword_filters)\n\n    # Combine all individual filters into a single 'AND' condition\n    combined_filter = Filter.all_of([\n        price_filter,\n        points_filter,\n        review_body_filter\n    ])\n\n    # Perform the hybrid search\n    # For more information on hybrid search, see:\n    # https://weaviate.io/developers/weaviate/search/hybrid\n    response = reviews.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        limit=5,\n        filters=combined_filter,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # Print the results\n    print(\"Found wines matching 'pair with steak' (price < 50, points > 90):\")\n    if response.objects:\n        for item in response.objects:\n            wine = item.properties\n            print(f\"\\n  - Title: {wine.get('title')}\")\n            print(f\"    Country: {wine.get('country')}\")\n            # Ensure price is formatted correctly if it exists\n            price = wine.get('price')\n            if price is not None:\n                print(f\"    Price: ${price:.2f}\")\n            else:\n                print(f\"    Price: N/A\")\n            print(f\"    Points: {wine.get('points')}\")\n    else:\n        print(\"No matching wines found that satisfy all criteria.\")\n\nfinally:\n    # Close the client connection\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"\\nConnection to Weaviate closed.\")\n\n```",
      "stdout": "Found wines matching 'pair with steak' (price < 50, points > 90):\n\n  - Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n    Country: US\n    Price: $40.00\n    Points: 92\n\n  - Title: Bink 2014 Pinot Noir (Anderson Valley)\n    Country: US\n    Price: $49.00\n    Points: 91\n\n  - Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n    Country: Argentina\n    Price: $27.00\n    Points: 91\n\n  - Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n    Country: Hungary\n    Price: $25.00\n    Points: 93\n\n  - Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n    Country: Italy\n    Price: $0.00\n    Points: 92\n\nConnection to Weaviate closed.\n",
      "stderr": "",
      "exit_code": 0
    }
  },
  "gemini/gemini-2.5-flash": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T22:39:05.468118",
      "duration": 10.34175992012024,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "To connect to Weaviate Cloud using the latest client syntax and check server readiness, you'll need the `weaviate-client` library installed (`pip install weaviate-client`).\n\nThe code below retrieves the necessary credentials from environment variables, establishes a connection, and then verifies if the Weaviate instance is ready to accept requests.\n\n```python\nimport weaviate\nimport os\nimport sys\n\ndef connect_and_check_weaviate_cloud():\n    \"\"\"\n    Connects to Weaviate Cloud using environment variables WCD_TEST_URL and WCD_TEST_KEY,\n    and then checks if the server is ready.\n    \"\"\"\n    # 1. Retrieve Weaviate Cloud URL and API Key from environment variables\n    weaviate_url = os.getenv(\"WCD_TEST_URL\")\n    weaviate_api_key = os.getenv(\"WCD_TEST_KEY\")\n\n    # Check if environment variables are set\n    if not weaviate_url:\n        print(\"Error: WCD_TEST_URL environment variable not set.\")\n        print(\"Please set it to your Weaviate Cloud cluster URL.\")\n        sys.exit(1)\n    if not weaviate_api_key:\n        print(\"Error: WCD_TEST_KEY environment variable not set.\")\n        print(\"Please set it to your Weaviate Cloud API Key.\")\n        sys.exit(1)\n\n    print(f\"Attempting to connect to Weaviate Cloud at: {weaviate_url}\")\n\n    # 2. Connect to Weaviate Cloud using the latest client syntax\n    # The 'with' statement ensures the client connection is properly closed\n    try:\n        with weaviate.connect_to_weaviate_cloud(\n            cluster_url=weaviate_url,\n            api_key=weaviate_api_key\n        ) as client:\n            print(\"Successfully connected to Weaviate Cloud client.\")\n\n            # 3. Check if the Weaviate server is ready to accept requests\n            if client.is_ready():\n                print(\"Weaviate server is READY to accept requests.\")\n            else:\n                print(\"Weaviate server is NOT ready. It might be starting up or experiencing issues.\")\n\n    except weaviate.exceptions.WeaviateConnectionError as e:\n        print(f\"\\nFailed to connect to Weaviate Cloud: {e}\")\n        print(\"Please verify WCD_TEST_URL, WCD_TEST_KEY, and your network connection.\")\n        sys.exit(1)\n    except Exception as e:\n        print(f\"\\nAn unexpected error occurred: {e}\")\n        sys.exit(1)\n\nif __name__ == \"__main__\":\n    connect_and_check_weaviate_cloud()\n```",
      "stdout": "Attempting to connect to Weaviate Cloud at: yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\n\nAn unexpected error occurred: connect_to_weaviate_cloud() got an unexpected keyword argument 'api_key'\n",
      "stderr": "",
      "exit_code": 1
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:39:09.963487",
      "duration": 4.456807851791382,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Get Weaviate Cloud URL and API Key from environment variables\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not WCD_TEST_URL:\n    raise ValueError(\n        \"WCD_TEST_URL environment variable not set. \"\n        \"Please set it to your Weaviate Cloud URL.\"\n    )\nif not WCD_TEST_KEY:\n    raise ValueError(\n        \"WCD_TEST_KEY environment variable not set. \"\n        \"Please set it to your Weaviate Cloud API Key.\"\n    )\n\nclient = None # Initialize client to None for finally block\n\ntry:\n    # Connect to the Weaviate Cloud instance\n    print(f\"Attempting to connect to Weaviate Cloud at: {WCD_TEST_URL}\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY)\n    )\n\n    # Check that the server is ready to accept requests\n    if client.is_ready():\n        print(\"Successfully connected to Weaviate Cloud and server is ready!\")\n    else:\n        print(\"Connected to Weaviate Cloud, but server is not ready.\")\n        # Optionally raise an error if not ready\n        # raise ConnectionError(\"Weaviate server is not ready after connection.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n    # Handle specific exceptions if needed, e.g., ConnectionError, AuthenticationError\n    if \"Connection refused\" in str(e):\n        print(\"Please check if the URL is correct and accessible.\")\n    if \"Unauthorized\" in str(e):\n        print(\"Please check if the API key is correct.\")\n\nfinally:\n    # Ensure the client connection is closed\n    if client:\n        print(\"Closing Weaviate client connection.\")\n        client.close()\n```",
      "stdout": "Attempting to connect to Weaviate Cloud at: yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\nSuccessfully connected to Weaviate Cloud and server is ready!\nClosing Weaviate client connection.\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:39:19.512917",
      "duration": 9.511515855789185,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "To create a Weaviate collection named \"DemoProducts\" with the specified properties, deleting it first if it already exists, you can use the following Python code with the latest Weaviate client syntax.\n\nMake sure you have the `weaviate-client` library installed (`pip install weaviate-client`).\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\n\n# --- Configuration ---\n# Load Weaviate Cloud credentials from environment variables\nWEAVIATE_URL = os.environ.get(\"WCD_TEST_URL\")\nWEAVIATE_API_KEY = os.environ.get(\"WCD_TEST_KEY\")\nCOLLECTION_NAME = \"DemoProducts\"\n\n# Ensure environment variables are set\nif not WEAVIATE_URL or not WEAVIATE_API_KEY:\n    raise ValueError(\n        \"Please set the environment variables WCD_TEST_URL and WCD_TEST_KEY \"\n        \"before running this script.\"\n    )\n\n# --- Connect to Weaviate ---\nprint(f\"Connecting to Weaviate instance at: {WEAVIATE_URL}\")\ntry:\n    client = weaviate.connect(\n        url=WEAVIATE_URL,\n        auth_credentials=weaviate.auth.AuthApiKey(WEAVIATE_API_KEY),\n    )\n    print(\"Successfully connected to Weaviate.\")\nexcept Exception as e:\n    print(f\"Failed to connect to Weaviate: {e}\")\n    exit(1)\n\n# --- Define Collection Properties ---\nproperties_config = [\n    Property(name=\"name\", data_type=DataType.TEXT),\n    Property(name=\"description\", data_type=DataType.TEXT),\n    Property(name=\"price\", data_type=DataType.NUMBER),\n    Property(name=\"in_stock\", data_type=DataType.BOOLEAN),\n]\n\n# --- Create or Recreate Collection ---\ntry:\n    # 1. Check if the collection already exists\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it...\")\n        # 2. Delete the collection if it exists\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted successfully.\")\n    else:\n        print(f\"Collection '{COLLECTION_NAME}' does not exist.\")\n\n    # 3. Create the new collection\n    print(f\"Creating collection '{COLLECTION_NAME}' with specified properties...\")\n    products_collection = client.collections.create(\n        name=COLLECTION_NAME,\n        properties=properties_config,\n        # Default vectorizer is text2vec-contextionary.\n        # If you need a different one (e.g., for WCD with a specific model),\n        # uncomment and configure below:\n        # vectorizer_config=weaviate.classes.config.Configure.Vectorizer.text2vec_openai()\n        # or\n        # vectorizer_config=weaviate.classes.config.Configure.Vectorizer.none() # if you handle vectorization externally\n    )\n    print(f\"Collection '{COLLECTION_NAME}' created successfully!\")\n\n    # Optional: Verify the schema of the created collection\n    print(\"\\n--- Verifying Collection Schema ---\")\n    retrieved_collection = client.collections.get(COLLECTION_NAME)\n    print(f\"Collection Name: {retrieved_collection.name}\")\n    print(\"Properties:\")\n    for prop in retrieved_collection.config.properties:\n        print(f\"  - Name: {prop.name}, Data Type: {prop.data_type.value}\")\n\nexcept Exception as e:\n    print(f\"An error occurred during collection creation/deletion: {e}\")\nfinally:\n    # --- Close Connection ---\n    if client.is_connected():\n        client.close()\n        print(\"\\nWeaviate connection closed.\")\n```\n\n**Before Running:**\n\n1.  **Install Weaviate Client:**\n    ```bash\n    pip install weaviate-client\n    ```\n2.  **Set Environment Variables:** Replace `YOUR_WCD_TEST_URL` and `YOUR_WCD_TEST_KEY` with your actual Weaviate Cloud URL and API Key.\n    *   **Linux/macOS:**\n        ```bash\n        export WCD_TEST_URL=\"YOUR_WCD_TEST_URL\"\n        export WCD_TEST_KEY=\"YOUR_WCD_TEST_KEY\"\n        ```\n    *   **Windows (Command Prompt):**\n        ```cmd\n        set WCD_TEST_URL=\"YOUR_WCD_TEST_URL\"\n        set WCD_TEST_KEY=\"YOUR_WCD_TEST_KEY\"\n        ```\n    *   **Windows (PowerShell):**\n        ```powershell\n        $env:WCD_TEST_URL=\"YOUR_WCD_TEST_URL\"\n        $env:WCD_TEST_KEY=\"YOUR_WCD_TEST_KEY\"\n        ```\n    Alternatively, you can hardcode them in the script for testing, but using environment variables is recommended for security and flexibility.\n\n**Explanation:**\n\n1.  **Import necessary modules**: `os` for environment variables, `weaviate` for the client, and `Property`, `DataType` from `weaviate.classes.config` for defining collection properties.\n2.  **Configuration**: Defines the Weaviate URL, API Key (retrieved from environment variables), and the desired collection name.\n3.  **Connection**: `weaviate.connect()` is used to establish a connection to your Weaviate Cloud instance. It uses `weaviate.auth.AuthApiKey` for authentication.\n4.  **Properties Definition**: A list of `Property` objects is created, each defining a property's `name` and `data_type` using the `DataType` enum.\n5.  **Check and Delete (Idempotency)**:\n    *   `client.collections.exists(COLLECTION_NAME)` checks if a collection with that name already exists.\n    *   If it exists, `client.collections.delete(COLLECTION_NAME)` is called to remove it. This ensures that the script is *idempotent* \u2013 running it multiple times will always result in the same state (a fresh \"DemoProducts\" collection).\n6.  **Create Collection**: `client.collections.create()` is used to create the collection.\n    *   `name`: The name of the collection (\"DemoProducts\").\n    *   `properties`: The list of `Property` objects defined earlier.\n    *   *(Commented out)* `vectorizer_config`: By default, Weaviate Cloud instances use `text2vec-contextionary` or a default model. If you need a specific vectorizer (e.g., OpenAI's `text2vec-openai`) or no vectorizer (if you're providing your own vectors), you can configure it here using `weaviate.classes.config.Configure.Vectorizer`.\n7.  **Verification**: After creation, the script retrieves the collection schema using `client.collections.get()` and prints its properties to confirm it was created as expected.\n8.  **Close Connection**: `client.close()` is called in a `finally` block to ensure the connection is properly terminated, even if errors occur.",
      "stdout": "Connecting to Weaviate instance at: yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\nFailed to connect to Weaviate: 'module' object is not callable\n",
      "stderr": "",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:39:24.987018",
      "duration": 5.4312379360198975,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Get Weaviate Cloud credentials from environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    print(\"Error: WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n    print(\"Please set them before running the script.\")\n    exit(1)\n\n# Connect to the Weaviate Cloud instance\nprint(f\"Connecting to Weaviate Cloud at: {WCD_TEST_URL}\")\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY)\n    )\n    print(\"Successfully connected to Weaviate.\")\nexcept Exception as e:\n    print(f\"Failed to connect to Weaviate: {e}\")\n    exit(1)\n\n# Define the collection name\ncollection_name = \"DemoProducts\"\n\ntry:\n    # Delete the collection if it already exists (for testing purposes)\n    if client.collections.exists(collection_name):\n        print(f\"Collection '{collection_name}' already exists. Deleting it...\")\n        client.collections.delete(collection_name)\n        print(f\"Collection '{collection_name}' deleted.\")\n    else:\n        print(f\"Collection '{collection_name}' does not exist. Proceeding to create.\")\n\n    # Create the collection\n    print(f\"Creating collection: '{collection_name}'...\")\n    products_collection = client.collections.create(\n        collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n\n    print(f\"Collection '{products_collection.name}' created successfully!\")\n    print(\"Properties defined:\")\n    for prop in products_collection.config.get().properties:\n        print(f\"- Name: {prop.name}, DataType: {prop.data_type}\")\n\nexcept Exception as e:\n    print(f\"An error occurred during collection creation/deletion: {e}\")\nfinally:\n    # Close connection\n    if client.is_connected():\n        client.close()\n        print(\"Weaviate connection closed.\")\n```",
      "stdout": "Connecting to Weaviate Cloud at: yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\nSuccessfully connected to Weaviate.\nCollection 'DemoProducts' already exists. Deleting it...\nCollection 'DemoProducts' deleted.\nCreating collection: 'DemoProducts'...\nCollection 'DemoProducts' created successfully!\nProperties defined:\n- Name: name, DataType: text\n- Name: description, DataType: text\n- Name: price, DataType: number\n- Name: in_stock, DataType: boolean\nWeaviate connection closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:39:31.068537",
      "duration": 6.043318748474121,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType, Configure\nimport os\n\n# Define environment variables for Weaviate Cloud connection\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\n\n# Ensure environment variables are set\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    raise ValueError(\n        \"Please set the environment variables WCD_TEST_URL and WCD_TEST_KEY for Weaviate Cloud connection.\"\n    )\n\nCOLLECTION_NAME = \"DemoProducts\"\n\n# Connect to Weaviate Cloud using environment variables\n# For more information on client instantiation, see: https://www.docs.weaviate.io/weaviate/client-libraries/python\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY),\n        # Add inference API keys here if you plan to use generative or vectorization modules\n        # headers={\"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]}\n    )\n\n    # Check if the collection already exists and delete it if it does\n    # For more information on collection management, see: https://docs.weaviate.io/weaviate/manage-data/collections\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it...\")\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted successfully.\")\n\n    # Define the properties for the \"DemoProducts\" collection\n    properties = [\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n\n    # Create the \"DemoProducts\" collection with the specified properties\n    # It's good practice to configure a vectorizer for your collection.\n    # Weaviate Cloud (WCD) often recommends `text2vec-weaviate` as it's built-in and doesn't require extra API keys.\n    # If you have specific needs (e.g., OpenAI, Cohere), configure those instead.\n    client.collections.create(\n        name=COLLECTION_NAME,\n        properties=properties,\n        # Configure a vectorizer, e.g., text2vec-weaviate (no API key needed)\n        vector_config=Configure.Vectors.text2vec_weaviate(),\n        # Or, if you use OpenAI:\n        # vector_config=Configure.Vectors.text2vec_openai(),\n    )\n    print(f\"Collection '{COLLECTION_NAME}' created successfully with specified properties.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Ensure the client connection is closed\n    if 'client' in locals() and client.is_connected():\n        client.close()\n        print(\"Weaviate client connection closed.\")\n\n```",
      "stdout": "Collection 'DemoProducts' already exists. Deleting it...\nCollection 'DemoProducts' deleted successfully.\nCollection 'DemoProducts' created successfully with specified properties.\nWeaviate client connection closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:39:45.934248",
      "duration": 14.193766832351685,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "Here's the Python code to achieve the described task using the latest Weaviate client syntax.\n\nFirst, make sure you have the Weaviate client installed:\n`pip install weaviate-client`\n\n**Python Code:**\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.classes.data import DataObject\n\n# --- 1. Get connection details from environment variables ---\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    print(\"Error: Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set.\")\n    print(\"Please set them before running the script.\")\n    exit(1)\n\nCOLLECTION_NAME = \"DemoProducts\"\n\nclient = None  # Initialize client to None for finally block\n\ntry:\n    # --- 2. Connect to Weaviate Cloud ---\n    print(f\"Connecting to Weaviate Cloud at: {WCD_TEST_URL}\")\n    client = weaviate.connect_to_wcs(\n        cluster_url=WCD_TEST_URL,\n        api_key=WCD_TEST_KEY\n    )\n    print(\"Successfully connected to Weaviate!\")\n\n    # --- 3. (Optional) Delete collection if it already exists for a clean run ---\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it for a clean run...\")\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n\n    # --- 4. Define and Create the Collection ---\n    print(f\"Creating collection '{COLLECTION_NAME}' with specified properties...\")\n    products_collection = client.collections.create(\n        name=COLLECTION_NAME,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT, description=\"Name of the product\"),\n            Property(name=\"description\", data_type=DataType.TEXT, description=\"Description of the product\"),\n        ]\n        # You can add vectorizer_config, inverted_index_config, etc. here if needed\n        # For simplicity, default settings are used here.\n    )\n    print(f\"Collection '{COLLECTION_NAME}' created successfully.\")\n\n    # --- 5. Prepare 50 arbitrary objects for batch import ---\n    print(\"Preparing 50 objects for batch import...\")\n    data_objects_to_import = []\n    for i in range(50):\n        data_objects_to_import.append(\n            DataObject(\n                properties={\n                    \"name\": f\"Product {i+1}\",  # Start from Product 1\n                    \"description\": f\"This is the description for Product number {i+1}. It's a fantastic item!\",\n                }\n            )\n        )\n    print(f\"Prepared {len(data_objects_to_import)} objects.\")\n\n    # --- 6. Batch Import Objects ---\n    print(\"Starting batch import...\")\n    # The insert_many method is efficient for bulk imports\n    insert_result = products_collection.data.insert_many(data_objects_to_import)\n    \n    # You can inspect the insert_result for any errors during import\n    if insert_result.errors:\n        print(\"Batch import completed with some errors:\")\n        for error in insert_result.errors:\n            print(f\"- {error.message}\")\n    else:\n        print(\"Batch import completed successfully!\")\n\n    # --- 7. Print the number of objects in the collection ---\n    print(f\"\\nAggregating object count for '{COLLECTION_NAME}'...\")\n    aggregate_result = products_collection.query.aggregate()\n\n    # The total_count property gives the number of objects\n    object_count = aggregate_result.total_count\n    print(f\"Number of objects in '{COLLECTION_NAME}': {object_count}\")\n\nexcept weaviate.WeaviateConnectionError as e:\n    print(f\"Connection Error: Could not connect to Weaviate. Details: {e}\")\nexcept weaviate.WeaviateAuthError as e:\n    print(f\"Authentication Error: API key might be incorrect or expired. Details: {e}\")\nexcept weaviate.WeaviateInvalidInputError as e:\n    print(f\"Invalid Input Error: Check your schema or data. Details: {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # --- 8. Close the connection ---\n    if client:\n        client.close()\n        print(\"Weaviate connection closed.\")\n\n```\n\n**To Run This Code:**\n\n1.  **Set Environment Variables:**\n    Before running the script, open your terminal or command prompt and set the environment variables:\n    *   **Linux/macOS:**\n        ```bash\n        export WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        python your_script_name.py\n        ```\n    *   **Windows (Command Prompt):**\n        ```cmd\n        set WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        set WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        python your_script_name.py\n        ```\n    *   **Windows (PowerShell):**\n        ```powershell\n        $env:WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n        $env:WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        python your_script_name.py\n        ```\n    Replace `\"YOUR_WEAVIATE_CLUSTER_URL\"` and `\"YOUR_WEAVIATE_API_KEY\"` with your actual Weaviate Cloud (WCD) cluster URL and API key.\n\n2.  **Execute the Python Script:**\n    Save the code as a `.py` file (e.g., `weaviate_batch_import.py`) and run it from your terminal:\n    `python weaviate_batch_import.py`\n\nThis script will:\n1.  Connect to your Weaviate Cloud instance.\n2.  (Optionally) Delete the `DemoProducts` collection if it already exists, ensuring a fresh start.\n3.  Create the `DemoProducts` collection with `name` and `description` text properties.\n4.  Generate 50 sample product objects.\n5.  Perform a batch import of these 50 objects efficiently.\n6.  Query the collection to get and print the total number of objects.\n7.  Close the Weaviate connection.",
      "stdout": "Connecting to Weaviate Cloud at: yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\n",
      "stderr": "/code/code.py:22: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\nTraceback (most recent call last):\n  File \"/code/code.py\", line 22, in <module>\n    client = weaviate.connect_to_wcs(\n  File \"/usr/local/lib/python3.9/site-packages/deprecation.py\", line 260, in _inner\n    return function(*args, **kwargs)\n  File \"/usr/local/lib/python3.9/site-packages/typing_extensions.py\", line 2956, in wrapper\n    return arg(*args, **kwargs)\nTypeError: connect_to_wcs() got an unexpected keyword argument 'api_key'\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/code/code.py\", line 82, in <module>\n    except weaviate.WeaviateConnectionError as e:\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/__init__.py\", line 145, in __getattr__\n    raise AttributeError(f\"module {__name__} has no attribute {name}\")\nAttributeError: module weaviate has no attribute WeaviateConnectionError\n",
      "exit_code": 1
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:40:09.061321",
      "duration": 22.443587064743042,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "To add objects to a Weaviate collection and then verify the count, we'll follow these steps:\n\n1.  **Import necessary libraries**: `weaviate` for client operations and `os` to access environment variables.\n2.  **Connect to Weaviate Cloud**: Retrieve the cluster URL and API key from environment variables (`WCD_TEST_URL`, `WCD_TEST_KEY`) and establish a connection.\n3.  **Define and Create Collection**: Define the schema for the \"DemoProducts\" collection with `name` and `description` text properties. For a clean run, the script will delete the collection if it already exists, then recreate it. We'll explicitly set `vectorizer_config` to `none` as vectorization is not required for this simple object storage example.\n4.  **Prepare Data**: Generate a list of 50 dictionaries, each representing a product with a `name` and `description`.\n5.  **Batch Import Objects**: Use `collection.batch.dynamic()` to efficiently add all 50 objects to the collection.\n6.  **Verify Import**: Check `collection.batch.failed_objects` to report any import failures.\n7.  **Print Object Count**: Use `len(collection)` to get and print the total number of objects in the collection.\n8.  **Close Connection**: Close the Weaviate client connection.\n\nMake sure you have the `weaviate-client` library installed (`pip install weaviate-client`) and your `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables are set correctly before running the script.\n\n```python\nimport weaviate\nimport os\n\n# 1. Connect to Weaviate Cloud using environment variables\nWCD_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_KEY = os.getenv(\"WCD_TEST_KEY\")\n\nif not WCD_URL or not WCD_KEY:\n    raise ValueError(\n        \"Error: WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\"\n        \"\\nExample: export WCD_TEST_URL='https://YOUR_CLUSTER_URL.weaviate.network'\"\n        \"\\nExample: export WCD_TEST_KEY='YOUR_API_KEY'\"\n    )\n\nprint(f\"Connecting to Weaviate Cloud at {WCD_URL.split('//')[1].split('/')[0]}...\")\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_URL,\n        auth_credentials=weaviate.Auth.api_key(WCD_KEY),\n    )\n    print(\"Successfully connected to Weaviate.\")\nexcept weaviate.exceptions.WeaviateConnectionError as e:\n    print(f\"Failed to connect to Weaviate: {e}\")\n    exit()\n\nCOLLECTION_NAME = \"DemoProducts\"\n\n# 2. Define the collection schema and ensure the collection exists\n# If the collection exists, delete and recreate it for a clean run.\n# Otherwise, create it.\ntry:\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"\\nCollection '{COLLECTION_NAME}' already exists. Deleting it for a clean start...\")\n        client.collections.delete(COLLECTION_NAME)\n        print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n    \n    print(f\"Creating collection '{COLLECTION_NAME}' with specified properties...\")\n    collection = client.collections.create(\n        name=COLLECTION_NAME,\n        properties=[\n            weaviate.CollectionProperty(name=\"name\", data_type=weaviate.PropertyType.TEXT),\n            weaviate.CollectionProperty(name=\"description\", data_type=weaviate.PropertyType.TEXT),\n        ],\n        # Explicitly configure no vectorizer as it's not needed for this example.\n        # This saves resources and avoids issues if a default vectorizer isn't available.\n        vectorizer_config=weaviate.config.Configure.Vectorizer.none(),\n        # Configure no module inference (e.g., for vectorization or RAG)\n        module_config={}, \n    )\n    print(f\"Collection '{COLLECTION_NAME}' created successfully.\")\n\nexcept Exception as e:\n    print(f\"An unexpected error occurred during collection creation: {e}\")\n    # If creation failed, attempt to retrieve the collection if it somehow exists\n    if client.collections.exists(COLLECTION_NAME):\n        print(f\"Attempting to get existing collection '{COLLECTION_NAME}'.\")\n        collection = client.collections.get(COLLECTION_NAME)\n    else:\n        print(\"Could not create or retrieve the collection. Exiting.\")\n        client.close()\n        exit()\n\n\n# 3. Batch import 50 arbitrary objects\nNUM_OBJECTS_TO_IMPORT = 50\nprint(f\"\\nGenerating {NUM_OBJECTS_TO_IMPORT} arbitrary objects for batch import...\")\ndata_rows = [\n    {\n        \"name\": f\"Product {i+1:02d}\", # Product name with leading zero for single digits\n        \"description\": f\"This is the detailed description for Product number {i+1}. It highlights its unique features, benefits, and specifications.\",\n    }\n    for i in range(NUM_OBJECTS_TO_IMPORT)\n]\n\nprint(f\"Starting batch import of {NUM_OBJECTS_TO_IMPORT} objects into '{COLLECTION_NAME}'...\")\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        # Optional: Check for errors during the batching process (useful for very large batches)\n        # if batch.number_errors > 0:\n        #     print(f\"Warning: {batch.number_errors} errors encountered during batching.\")\n\n# Check for failed objects after the batch operation is complete\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Batch import completed with {len(failed_objects)} failed objects.\")\n    print(f\"First failed object details (if any): {failed_objects[0]}\")\nelse:\n    print(\"Batch import completed successfully with no failed objects.\")\n\n\n# 4. Print the number of objects in the collection\nprint(f\"\\nVerifying object count in '{COLLECTION_NAME}'...\")\ntry:\n    object_count = len(collection)\n    print(f\"Total number of objects in '{COLLECTION_NAME}': {object_count}\")\nexcept Exception as e:\n    print(f\"Error retrieving object count: {e}\")\n\n\n# 5. Close the Weaviate client connection\nprint(\"\\nClosing Weaviate connection...\")\nclient.close()\nprint(\"Connection closed.\")\n```",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 15, in <module>\n    print(f\"Connecting to Weaviate Cloud at {WCD_URL.split('//')[1].split('/')[0]}...\")\nIndexError: list index out of range\n",
      "exit_code": 1
    },
    "extensive_examples_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:40:20.855693",
      "duration": 11.094502210617065,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\nimport os\n\n# Ensure environment variables are set\n# For testing, you might set them like this:\n# os.environ[\"WCD_TEST_URL\"] = \"YOUR_WEAVIATE_CLOUD_URL\"\n# os.environ[\"WCD_TEST_KEY\"] = \"YOUR_WEAVIATE_API_KEY\"\n\n# Define collection name\nCOLLECTION_NAME = \"DemoProducts\"\n\ndef main():\n    client = None # Initialize client to None for finally block\n\n    try:\n        # 1. Connect to Weaviate Cloud\n        print(f\"Connecting to Weaviate Cloud at {os.environ.get('WCD_TEST_URL')}...\")\n        client = weaviate.connect_to_weaviate_cloud(\n            cluster_url=os.environ[\"WCD_TEST_URL\"],\n            auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n            # Add any other required headers if your Weaviate Cloud instance needs them, e.g., for vectorization\n            # headers={\n            #     \"X-OpenAI-Api-Key\": os.environ.get(\"OPENAI_API_KEY\")\n            # }\n        )\n        print(\"Successfully connected to Weaviate Cloud.\")\n\n        # 2. Define and create the collection\n        print(f\"\\nChecking for existing collection '{COLLECTION_NAME}'...\")\n        if client.collections.exists(COLLECTION_NAME):\n            print(f\"Collection '{COLLECTION_NAME}' already exists. Deleting it...\")\n            client.collections.delete(COLLECTION_NAME)\n            print(f\"Collection '{COLLECTION_NAME}' deleted.\")\n\n        print(f\"Creating collection '{COLLECTION_NAME}'...\")\n        products_collection = client.collections.create(\n            name=COLLECTION_NAME,\n            properties=[\n                Property(name=\"name\", data_type=DataType.TEXT),\n                Property(name=\"description\", data_type=DataType.TEXT),\n            ],\n            # If you want to enable vectorization, uncomment one of the following:\n            # For Weaviate Cloud, text2vec-weaviate is often a good default as it doesn't require a third-party API key\n            # vector_config=Configure.Vectors.text2vec_weaviate(),\n            # Or if using OpenAI (requires OPENAI_API_KEY env var):\n            # vector_config=Configure.Vectors.text2vec_openai(),\n            # Or self-provided vectors if you plan to supply them directly\n            # vector_config=Configure.Vectors.self_provided(),\n        )\n        print(f\"Collection '{COLLECTION_NAME}' created successfully.\")\n\n        # 3. Batch import 50 arbitrary objects\n        num_objects_to_import = 50\n        print(f\"\\nBatch importing {num_objects_to_import} objects into '{COLLECTION_NAME}'...\")\n\n        # Get the collection object for data operations\n        products_collection = client.collections.get(COLLECTION_NAME)\n\n        with products_collection.batch.fixed_size(batch_size=25) as batch: # Using a batch size of 25 for this example\n            for i in range(num_objects_to_import):\n                product_data = {\n                    \"name\": f\"Product {i+1}\",\n                    \"description\": f\"This is the description for Product {i+1}. It highlights its features and benefits.\"\n                }\n                batch.add_object(properties=product_data)\n        print(f\"Batch import completed. Errors: {len(products_collection.batch.failed_objects)}\")\n\n        # 4. Print the number of objects in the collection\n        print(f\"\\nCounting objects in '{COLLECTION_NAME}'...\")\n        total_objects = products_collection.aggregate.total_count()\n        print(f\"Total number of objects in '{COLLECTION_NAME}': {total_objects}\")\n\n    except KeyError as e:\n        print(f\"Error: Environment variable not set. Please set {e}.\")\n        print(\"Make sure WCD_TEST_URL and WCD_TEST_KEY are set in your environment.\")\n    except weaviate.exceptions.WeaviateConnectionError as e:\n        print(f\"Weaviate connection error: {e}\")\n        print(\"Please check your Weaviate Cloud URL and API Key.\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n    finally:\n        # 5. Clean up: Close the client connection\n        if client:\n            print(\"\\nClosing Weaviate client connection.\")\n            client.close()\n            print(\"Client connection closed.\")\n\nif __name__ == \"__main__\":\n    # Set dummy environment variables for demonstration if not already set\n    # In a real scenario, these would be properly configured\n    if \"WCD_TEST_URL\" not in os.environ:\n        os.environ[\"WCD_TEST_URL\"] = \"http://localhost:8080\" # Replace with your actual Weaviate Cloud URL\n        print(\"WARNING: WCD_TEST_URL not found, using placeholder. Please set your actual Weaviate Cloud URL.\")\n    if \"WCD_TEST_KEY\" not in os.environ:\n        os.environ[\"WCD_TEST_KEY\"] = \"YOUR_API_KEY_HERE\" # Replace with your actual Weaviate Cloud API Key\n        print(\"WARNING: WCD_TEST_KEY not found, using placeholder. Please set your actual Weaviate Cloud API Key.\")\n\n    main()\n```",
      "stdout": "Connecting to Weaviate Cloud at yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud...\nSuccessfully connected to Weaviate Cloud.\n\nChecking for existing collection 'DemoProducts'...\nCollection 'DemoProducts' already exists. Deleting it...\nCollection 'DemoProducts' deleted.\nCreating collection 'DemoProducts'...\nCollection 'DemoProducts' created successfully.\n\nBatch importing 50 objects into 'DemoProducts'...\nBatch import completed. Errors: 0\n\nCounting objects in 'DemoProducts'...\nAn unexpected error occurred: '_AggregateCollection' object has no attribute 'total_count'\n\nClosing Weaviate client connection.\nClient connection closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:40:34.362845",
      "duration": 12.942442655563354,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "To query the 'WineReview' collection in Weaviate Cloud for wines that best match \"dessert wine\" using the latest client syntax, and print the specified details, you can use the following Python code:\n\n```python\nimport weaviate\nimport os\n\n# --- 1. Load environment variables ---\ntry:\n    WEAVIATE_URL = os.environ[\"WCD_TEST_URL\"]\n    WEAVIATE_API_KEY = os.environ[\"WCD_TEST_KEY\"]\n    OPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\nexcept KeyError as e:\n    print(f\"Error: Missing environment variable {e}.\")\n    print(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY in your environment.\")\n    exit(1)\n\n# --- 2. Connect to Weaviate Cloud ---\nclient = None\ntry:\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_wcs(\n        cluster_url=WEAVIATE_URL,\n        auth_credentials=weaviate.AuthApiKey(WEAVIATE_API_KEY),\n        headers={\n            \"X-OpenAI-Api-Key\": OPENAI_API_KEY\n        }\n    )\n\n    if client.is_connected():\n        print(f\"Successfully connected to Weaviate at {WEAVIATE_URL}\")\n    else:\n        print(\"Failed to connect to Weaviate.\")\n        exit(1)\n\n    # --- 3. Get the 'WineReview' collection ---\n    wine_reviews_collection = client.collections.get(\"WineReview\")\n\n    # --- 4. Define the query parameters ---\n    query_text = \"dessert wine\"\n    max_results_limit = 2\n    return_properties = [\"title\", \"country\", \"price\", \"points\"]\n\n    print(f\"\\nSearching for wines best matching: '{query_text}' (Limit: {max_results_limit} results)\")\n\n    # --- 5. Perform the vector search using near_text ---\n    response = wine_reviews_collection.query.near_text(\n        query=query_text,\n        limit=max_results_limit,\n        return_properties=return_properties\n    )\n\n    # --- 6. Print the matching wine details ---\n    if response.objects:\n        print(\"\\n--- Matching Wines ---\")\n        for i, obj in enumerate(response.objects):\n            print(f\"\\nResult {i+1}:\")\n            print(f\"  Title: {obj.properties.get('title', 'N/A')}\")\n            print(f\"  Country: {obj.properties.get('country', 'N/A')}\")\n            # Format price if available, otherwise print N/A\n            price = obj.properties.get('price')\n            print(f\"  Price: ${price:.2f}\" if price is not None else \"  Price: N/A\")\n            print(f\"  Points: {obj.properties.get('points', 'N/A')}\")\n    else:\n        print(\"No matching wines found for the query.\")\n\nexcept weaviate.exceptions.WeaviateConnectionError as e:\n    print(f\"Weaviate connection error: {e}. Check your URL and network connection.\")\nexcept weaviate.exceptions.WeaviateAuthError as e:\n    print(f\"Weaviate authentication error: {e}. Check your WCD_TEST_KEY and OPENAI_API_KEY.\")\nexcept weaviate.exceptions.WeaviateGRPCError as e:\n    print(f\"Weaviate GRPC error: {e}. This might indicate issues with the collection schema or data.\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # --- 7. Close the Weaviate client connection ---\n    if client:\n        client.close()\n        print(\"\\nWeaviate client connection closed.\")\n```\n\n**To run this code:**\n\n1.  **Install the Weaviate client:**\n    ```bash\n    pip install weaviate-client\n    ```\n2.  **Set your environment variables:**\n    Make sure `WCD_TEST_URL`, `WCD_TEST_KEY`, and `OPENAI_API_KEY` are set in your shell environment before running the script.\n\n    **On Linux/macOS:**\n    ```bash\n    export WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n    export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n    export OPENAI_API_KEY=\"YOUR_OPENAI_API_KEY\"\n    python your_script_name.py\n    ```\n    **On Windows (Command Prompt):**\n    ```cmd\n    set WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n    set WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n    set OPENAI_API_KEY=\"YOUR_OPENAI_API_KEY\"\n    python your_script_name.py\n    ```\n    (Replace placeholders with your actual keys and URL).\n\nThis script will connect to your Weaviate Cloud instance, query the 'WineReview' collection using the `near_text` operator for semantic similarity to \"dessert wine\", limit the results to 2, and then print the title, country, price, and points for each matching wine.",
      "stdout": "Connecting to Weaviate Cloud...\nSuccessfully connected to Weaviate at yqdvcmlqrpwgtemp3keqpw.c0.europe-west3.gcp.weaviate.cloud\n\nSearching for wines best matching: 'dessert wine' (Limit: 2 results)\n\n--- Matching Wines ---\n\nResult 1:\n  Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price: $24.00\n  Points: 88\n\nResult 2:\n  Title: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price: $40.00\n  Points: 88\n\nWeaviate client connection closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:18: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:40:40.700147",
      "duration": 5.937510967254639,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# 1. Get API keys and cluster URL from environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Check if environment variables are set\nif not WCD_TEST_URL:\n    raise ValueError(\"Environment variable WCD_TEST_URL not set.\")\nif not WCD_TEST_KEY:\n    raise ValueError(\"Environment variable WCD_TEST_KEY not set.\")\nif not OPENAI_API_KEY:\n    raise ValueError(\"Environment variable OPENAI_API_KEY not set.\")\n\n# Initialize client outside of try-finally block to ensure it's defined\nclient = None\ntry:\n    # 2. Connect to Weaviate Cloud\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY),\n        headers={\n            \"X-OpenAI-Api-Key\": OPENAI_API_KEY\n        },\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\n\n    # 3. Get the 'WineReview' collection\n    collection = client.collections.get(\"WineReview\")\n    print(\"Accessed 'WineReview' collection.\")\n\n    # 4. Perform the query\n    print(\"Querying for 'dessert wine' (top 2 results)...\")\n    response = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        # Specify which properties to retrieve to optimize performance\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # 5. Print the results\n    if response.objects:\n        print(\"\\nMatching wines:\")\n        for i, obj in enumerate(response.objects):\n            print(f\"--- Result {i+1} ---\")\n            properties = obj.properties\n            print(f\"Title: {properties.get('title', 'N/A')}\")\n            print(f\"Country: {properties.get('country', 'N/A')}\")\n            print(f\"Price: ${properties.get('price', 'N/A')}\")\n            print(f\"Points: {properties.get('points', 'N/A')}\")\n    else:\n        print(\"\\nNo matching wines found for the query 'dessert wine'.\")\n\nexcept weaviate.exceptions.WeaviateException as e:\n    print(f\"Weaviate error: {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # 6. Close the client connection\n    if client:\n        print(\"\\nClosing Weaviate client connection.\")\n        client.close()\n    print(\"Script finished.\")\n```",
      "stdout": "Connecting to Weaviate Cloud...\nSuccessfully connected to Weaviate Cloud.\nAccessed 'WineReview' collection.\nQuerying for 'dessert wine' (top 2 results)...\n\nMatching wines:\n--- Result 1 ---\nTitle: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: $24.0\nPoints: 88\n--- Result 2 ---\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: $40.0\nPoints: 88\n\nClosing Weaviate client connection.\nScript finished.\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:40:47.590959",
      "duration": 6.45962381362915,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\nfrom weaviate.collections import Collection\n\n# Load environment variables\nWEAVIATE_URL = os.environ.get(\"WCD_TEST_URL\")\nWEAVIATE_API_KEY = os.environ.get(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\n\n# Ensure all necessary environment variables are set\nif not all([WEAVIATE_URL, WEAVIATE_API_KEY, OPENAI_API_KEY]):\n    raise EnvironmentError(\n        \"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY \"\n        \"environment variables before running the script.\"\n    )\n\nclient = None  # Initialize client to None\ntry:\n    # 1. Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WEAVIATE_URL,\n        auth_credentials=Auth.api_key(WEAVIATE_API_KEY),\n        headers={\n            \"X-OpenAI-Api-Key\": OPENAI_API_KEY  # Required for text2vec-openai vectorizer\n        }\n    )\n\n    # Check if the client is connected\n    if client.is_connected():\n        print(\"Successfully connected to Weaviate Cloud.\")\n    else:\n        print(\"Failed to connect to Weaviate Cloud.\")\n        exit()\n\n    # 2. Get the 'WineReview' collection\n    # Note: If the collection doesn't exist, this will raise a NotFoundError.\n    # For a robust solution, you might want to add a check for existence\n    # or a creation step if it's an initial setup.\n    wine_collection: Collection = client.collections.get(\"WineReview\")\n    print(\"\\nQuerying 'WineReview' collection for 'dessert wine'...\")\n\n    # 3. Query the collection using near_text\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,  # Limit to a maximum of 2 results\n        # Specify properties to return\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # 4. Print the results\n    if response.objects:\n        print(f\"\\nFound {len(response.objects)} matching wines:\")\n        for i, obj in enumerate(response.objects):\n            print(f\"\\n--- Result {i+1} ---\")\n            print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n            print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n            print(f\"Price: {obj.properties.get('price', 'N/A')}\")\n            print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n    else:\n        print(\"\\nNo matching wines found.\")\n\nexcept weaviate.exceptions.WeaviateConnectionError as e:\n    print(f\"Weaviate connection error: {e}\")\nexcept weaviate.exceptions.NotFoundError as e:\n    print(f\"Error: Collection 'WineReview' not found. Please ensure it exists in your Weaviate instance. {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # 5. Close the client connection\n    if client:\n        client.close()\n        print(\"\\nWeaviate client connection closed.\")\n\n```",
      "stdout": "Successfully connected to Weaviate Cloud.\n\nQuerying 'WineReview' collection for 'dessert wine'...\n\nFound 2 matching wines:\n\n--- Result 1 ---\nTitle: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n\n--- Result 2 ---\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n\nWeaviate client connection closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:41:04.662321",
      "duration": 16.646386861801147,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "Here's the Python code to query the 'WineReview' collection in Weaviate Cloud using the latest client syntax, matching all your requirements.\n\n```python\nimport os\nimport weaviate\nimport weaviate.classes.query as qc\nimport weaviate.classes.config as wc\n\n# 1. Load Weaviate and OpenAI API keys from environment variables\nWCD_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_KEY = os.getenv(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\nif not all([WCD_URL, WCD_KEY, OPENAI_API_KEY]):\n    print(\"Error: Please set the following environment variables:\")\n    print(\"  - WCD_TEST_URL (Weaviate Cloud URL)\")\n    print(\"  - WCD_TEST_KEY (Weaviate Cloud API Key)\")\n    print(\"  - OPENAI_API_KEY (OpenAI API Key for text2vec-openai)\")\n    exit(1)\n\n# 2. Connect to Weaviate Cloud\nclient = None # Initialize client to None for finally block\ntry:\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_wcs(\n        cluster_url=WCD_URL,\n        auth_credentials=weaviate.AuthApiKey(WCD_KEY),\n        headers={\n            \"X-OpenAI-Api-Key\": OPENAI_API_KEY\n        }\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\n\n    # 3. Get the 'WineReview' collection object\n    wine_reviews = client.collections.get(\"WineReview\")\n\n    # 4. Define the filters\n    # Filter 1: Price and Points conditions (AND)\n    price_points_filter = (\n        qc.Filter.by_property(\"price\").less_than(50)\n        & qc.Filter.by_property(\"points\").greater_than(90)\n    )\n\n    # Filter 2: review_body substring conditions (OR)\n    # Note: Weaviate's 'like' operator uses '%' as a wildcard at the beginning/end\n    # The Python client uses '*' for convenience, which gets translated to '%' internally.\n    review_body_content_filter = (\n        qc.Filter.by_property(\"review_body\").like(\"*spice*\")\n        | qc.Filter.by_property(\"review_body\").like(\"*fruit*\")\n        | qc.Filter.by_property(\"review_body\").like(\"*berry*\")\n        | qc.Filter.by_property(\"review_body\").like(\"*cherry*\")\n        | qc.Filter.by_property(\"review_body\").like(\"*honey*\")\n    )\n\n    # Combine both filters with an AND operation\n    combined_filter = price_points_filter & review_body_content_filter\n\n    # 5. Perform the hybrid search query\n    print(f\"\\nSearching for wines that 'pair with steak' (hybrid alpha=0.5)...\")\n    print(f\"Applying filters: Price < 50, Points > 90, and review_body contains specific keywords.\")\n\n    response = wine_reviews.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,           # Hybrid search blend factor\n        limit=5,             # Maximum 5 results\n        # Specify properties for the keyword search part of hybrid query\n        # (useful if you want to emphasize certain fields for keyword matching)\n        query_properties=[\"title\", \"description\", \"review_body\"],\n        # Define which properties to return for each object\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n        filters=combined_filter # Apply the combined filters\n    )\n\n    # 6. Print the results\n    if response.objects:\n        print(\"\\n--- Matching Wines Found ---\")\n        for i, obj in enumerate(response.objects):\n            props = obj.properties\n            print(f\"\\nResult {i+1}:\")\n            print(f\"  Title: {props.get('title', 'N/A')}\")\n            print(f\"  Country: {props.get('country', 'N/A')}\")\n            print(f\"  Price: ${props.get('price', 'N/A'):.2f}\")\n            print(f\"  Points: {props.get('points', 'N/A')}\")\n            # print(f\"  Review Body (filtered on, not returned): (Not displayed)\") # For verification if needed\n        print(\"\\n----------------------------\")\n    else:\n        print(\"\\nNo wines found matching the specified criteria.\")\n\nexcept weaviate.exceptions.WeaviateConnectionError as e:\n    print(f\"Weaviate Connection Error: {e}\")\nexcept weaviate.exceptions.WeaviateBaseError as e:\n    print(f\"Weaviate API Error: {e}\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # 7. Close the Weaviate client connection\n    if client:\n        client.close()\n        print(\"Connection to Weaviate closed.\")\n\n```",
      "stdout": "Connecting to Weaviate Cloud...\nSuccessfully connected to Weaviate Cloud.\n\nSearching for wines that 'pair with steak' (hybrid alpha=0.5)...\nApplying filters: Price < 50, Points > 90, and review_body contains specific keywords.\nWeaviate API Error: Query call with protocol GRPC search failed with message object search at index winereview: local shard object search winereview_3Pp7LBMzKD4W: Searching by property 'description' requires inverted index. Is `indexSearchable` option of property 'description' enabled? Set it to `true` or leave empty.\nConnection to Weaviate closed.\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:22: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:41:18.435765",
      "duration": 13.321661233901978,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter\nimport os\n\n# 1. Retrieve Weaviate and OpenAI API keys from environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\n# Ensure all necessary environment variables are set\nif not all([WCD_TEST_URL, WCD_TEST_KEY, OPENAI_API_KEY]):\n    raise ValueError(\n        \"Please set the environment variables WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY.\"\n        \"\\nExample: export WCD_TEST_URL='YOUR_WCD_URL' export WCD_TEST_KEY='YOUR_WCD_KEY' export OPENAI_API_KEY='YOUR_OPENAI_KEY'\"\n    )\n\nclient = None  # Initialize client to None for finally block\n\ntry:\n    # 2. Connect to Weaviate Cloud\n    print(\"Connecting to Weaviate Cloud...\")\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY),\n        headers={\n            \"X-OpenAI-API-Key\": OPENAI_API_KEY  # Required for text2vec-openai vectorizer\n        },\n    )\n    print(\"Successfully connected to Weaviate.\")\n\n    # 3. Get the 'WineReview' collection\n    wine_review_collection = client.collections.get(\"WineReview\")\n    print(\"Accessing 'WineReview' collection...\")\n\n    # 4. Perform a hybrid search query with filters\n    print(\"Executing hybrid query...\")\n    response = wine_review_collection.query.hybrid(\n        query=\"pair with steak\",\n        limit=5,  # Maximum 5 results\n        alpha=0.5,  # Hybrid search alpha value\n        filters=(\n            # Price less than 50\n            Filter.by_property(\"price\").less_than(50) &\n            # Points greater than 90\n            Filter.by_property(\"points\").greater_than(90) &\n            # Review body contains at least one of the specified substrings\n            Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n        ),\n        # Specify which properties to return for each matching object\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # 5. Print the results\n    print(f\"\\nFound {len(response.objects)} wines matching the criteria:\")\n    if not response.objects:\n        print(\"No matching wines found.\")\n    else:\n        for i, obj in enumerate(response.objects):\n            print(f\"\\n--- Wine {i+1} ---\")\n            # Access properties using .get() for robustness\n            print(f\"Title: {obj.properties.get('title', 'N/A')}\")\n            print(f\"Country: {obj.properties.get('country', 'N/A')}\")\n            # Format price to two decimal places\n            print(f\"Price: ${obj.properties.get('price', 0.0):.2f}\")\n            print(f\"Points: {obj.properties.get('points', 'N/A')}\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # 6. Close the client connection\n    if client and client.is_connected():\n        client.close()\n        print(\"\\nWeaviate client connection closed.\")\n\n```",
      "stdout": "Connecting to Weaviate Cloud...\nSuccessfully connected to Weaviate.\nAccessing 'WineReview' collection...\nExecuting hybrid query...\n\nFound 5 wines matching the criteria:\n\n--- Wine 1 ---\nTitle: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: $40.00\nPoints: 92\n\n--- Wine 2 ---\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: $49.00\nPoints: 91\n\n--- Wine 3 ---\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: $27.00\nPoints: 91\n\n--- Wine 4 ---\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: $25.00\nPoints: 93\n\n--- Wine 5 ---\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: $0.00\nPoints: 92\n\nWeaviate client connection closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:41:26.945827",
      "duration": 8.08308482170105,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, HybridFusion\n\n# Ensure environment variables are set\n# For local testing, you might need to set these in your shell or .env file\n# For example:\n# export WCD_TEST_URL=\"YOUR_WEAVIATE_CLUSTER_URL\"\n# export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n# export OPENAI_API_KEY=\"YOUR_OPENAI_API_KEY\"\n\n# Connect to Weaviate Cloud\nclient = None\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\n            \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n        }\n    )\n\n    # Get the 'WineReview' collection\n    wine_reviews_collection = client.collections.get(\"WineReview\")\n\n    # Define the search query\n    search_query = \"pair with steak\"\n\n    # Define the filters\n    # Price less than 50\n    price_filter = Filter.by_property(\"price\").less_than(50)\n    # Points greater than 90\n    points_filter = Filter.by_property(\"points\").greater_than(90)\n    # Review body contains any of \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\"\n    review_body_filter = Filter.by_property(\"review_body\").contains_any(\n        [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n    )\n\n    # Combine all filters using logical AND\n    combined_filters = price_filter & points_filter & review_body_filter\n\n    print(f\"Searching for wines that best match: '{search_query}'\")\n    print(\"Applying filters: Price < 50, Points > 90, Review contains 'spice', 'fruit', 'berry', 'cherry', or 'honey'\")\n    print(\"Limit: 5 results, Hybrid search alpha: 0.5\\n\")\n\n    # Perform the hybrid search with specified parameters\n    response = wine_reviews_collection.query.hybrid(\n        query=search_query,\n        alpha=0.5,\n        limit=5,\n        filters=combined_filters,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # Print the results\n    if response.objects:\n        print(\"Found matching wines:\")\n        for i, wine in enumerate(response.objects):\n            print(f\"--- Result {i+1} ---\")\n            print(f\"Title: {wine.properties.get('title', 'N/A')}\")\n            print(f\"Country: {wine.properties.get('country', 'N/A')}\")\n            print(f\"Price: {wine.properties.get('price', 'N/A')}\")\n            print(f\"Points: {wine.properties.get('points', 'N/A')}\")\n            print(\"-\" * 20)\n    else:\n        print(\"No wines found matching the criteria.\")\n\nexcept KeyError as e:\n    print(f\"Error: Environment variable {e} not set. Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY.\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    if client:\n        client.close()\n        print(\"\\nWeaviate client closed.\")\n```",
      "stdout": "Searching for wines that best match: 'pair with steak'\nApplying filters: Price < 50, Points > 90, Review contains 'spice', 'fruit', 'berry', 'cherry', or 'honey'\nLimit: 5 results, Hybrid search alpha: 0.5\n\nFound matching wines:\n--- Result 1 ---\nTitle: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: 40.0\nPoints: 92\n--------------------\n--- Result 2 ---\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: 49.0\nPoints: 91\n--------------------\n--- Result 3 ---\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: 27.0\nPoints: 91\n--------------------\n--- Result 4 ---\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: 25.0\nPoints: 93\n--------------------\n--- Result 5 ---\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: 0.0\nPoints: 92\n--------------------\n\nWeaviate client closed.\n",
      "stderr": "",
      "exit_code": 0
    }
  },
  "gemini/gemini-2.5-flash-lite": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T22:41:28.940968",
      "duration": 1.9582419395446777,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get Weaviate Cloud URL and API key from environment variables\nweaviate_url = os.environ.get(\"WCD_TEST_URL\")\nweaviate_api_key = os.environ.get(\"WCD_TEST_KEY\")\n\nif not weaviate_url or not weaviate_api_key:\n    raise ValueError(\n        \"Please set the WCD_TEST_URL and WCD_TEST_KEY environment variables.\"\n    )\n\n# Connect to Weaviate Cloud\nclient = weaviate.Client(\n    url=weaviate_url,\n    auth_client_secret=weaviate.AuthApiKey(api_key=weaviate_api_key),\n)\n\n# Check if the server is ready\ntry:\n    client.is_ready()\n    print(\"Weaviate server is ready to accept requests.\")\nexcept Exception as e:\n    print(f\"Error connecting to Weaviate server: {e}\")\n    # Optionally re-raise the exception if you want to halt execution\n    # raise e\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:14: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 14, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:41:30.873111",
      "duration": 1.8948471546173096,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Retrieve Weaviate Cloud credentials from environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\n\n# Ensure environment variables are set\nif not wcd_url:\n    raise ValueError(\"WCD_TEST_URL environment variable is not set.\")\nif not wcd_key:\n    raise ValueError(\"WCD_TEST_KEY environment variable is not set.\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=wcd_url,\n    auth_credentials=Auth.api_key(wcd_key)\n)\n\n# Check that the server is ready to accept requests\nassert client.is_ready()\n\n# Close the client connection (optional but good practice)\nclient.close()\n\nprint(\"Successfully connected to Weaviate Cloud and server is ready.\")\n```",
      "stdout": "Successfully connected to Weaviate Cloud and server is ready.\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:41:35.432143",
      "duration": 4.522002935409546,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get Weaviate Cloud connection details from environment variables\nweaviate_url = os.getenv(\"WCD_TEST_URL\")\nweaviate_api_key = os.getenv(\"WCD_TEST_KEY\")\n\n# Check if environment variables are set\nif not weaviate_url or not weaviate_api_key:\n    raise ValueError(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n\n# Initialize the Weaviate client\nclient = weaviate.Client(\n    url=weaviate_url,\n    auth_client_secret=weaviate.AuthApiKey(weaviate_api_key),\n)\n\ncollection_name = \"DemoProducts\"\n\n# Check if the collection exists and delete it if it does\nif client.collections.exists(collection_name):\n    print(f\"Collection '{collection_name}' already exists. Deleting it...\")\n    client.collections.delete(collection_name)\n    print(f\"Collection '{collection_name}' deleted.\")\nelse:\n    print(f\"Collection '{collection_name}' does not exist. Creating it...\")\n\n# Define the schema for the \"DemoProducts\" collection\ncollection_schema = {\n    \"name\": collection_name,\n    \"properties\": [\n        {\"name\": \"name\", \"dataType\": [\"text\"]},\n        {\"name\": \"description\", \"dataType\": [\"text\"]},\n        {\"name\": \"price\", \"dataType\": [\"number\"]},\n        {\"name\": \"in_stock\", \"dataType\": [\"boolean\"]},\n    ],\n}\n\n# Create the collection\nclient.collections.create(\n    collection_schema[\"name\"],\n    properties=collection_schema[\"properties\"]\n)\n\nprint(f\"Collection '{collection_name}' created successfully with the defined properties.\")\n\n# Optional: Verify the collection creation\nif client.collections.exists(collection_name):\n    print(f\"Verification: Collection '{collection_name}' exists.\")\n    retrieved_schema = client.collections.get(collection_name).properties\n    print(\"Collection Schema:\")\n    for prop in retrieved_schema:\n        print(f\"- Name: {prop['name']}, Data Type: {prop['dataType']}\")\nelse:\n    print(f\"Verification failed: Collection '{collection_name}' could not be found.\")\n```\n\n**Explanation:**\n\n1.  **Import necessary libraries:**\n    *   `os`: Used to access environment variables.\n    *   `weaviate`: The Weaviate Python client library.\n\n2.  **Get Weaviate Cloud Credentials:**\n    *   `weaviate_url = os.getenv(\"WCD_TEST_URL\")`: Retrieves the Weaviate Cloud instance URL from the `WCD_TEST_URL` environment variable.\n    *   `weaviate_api_key = os.getenv(\"WCD_TEST_KEY\")`: Retrieves the API key from the `WCD_TEST_KEY` environment variable.\n    *   An `if` statement checks if these environment variables are set. If not, it raises a `ValueError` to inform the user.\n\n3.  **Initialize Weaviate Client:**\n    *   `client = weaviate.Client(...)`: Creates an instance of the Weaviate client.\n    *   `url=weaviate_url`: Specifies the URL of your Weaviate instance.\n    *   `auth_client_secret=weaviate.AuthApiKey(weaviate_api_key)`: Configures authentication using an API key. This is the standard way to authenticate with Weaviate Cloud.\n\n4.  **Define Collection Name:**\n    *   `collection_name = \"DemoProducts\"`: Sets the name of the collection you want to create.\n\n5.  **Check and Delete Existing Collection:**\n    *   `if client.collections.exists(collection_name):`: Uses the `collections.exists()` method to check if a collection with the specified name already exists.\n    *   `client.collections.delete(collection_name)`: If the collection exists, it's deleted using the `collections.delete()` method. This ensures a clean slate for creating the new collection.\n\n6.  **Define Collection Schema:**\n    *   `collection_schema = { ... }`: A dictionary defines the structure of the collection.\n        *   `\"name\": collection_name`: Specifies the name of the collection.\n        *   `\"properties\": [...]`: A list of dictionaries, where each dictionary defines a property:\n            *   `\"name\"`: The name of the property (e.g., \"name\", \"description\").\n            *   `\"dataType\"`: A list containing the data type of the property. Common data types include:\n                *   `[\"text\"]`: For string values.\n                *   `[\"number\"]`: For floating-point or integer numbers.\n                *   `[\"boolean\"]`: For true/false values.\n\n7.  **Create the Collection:**\n    *   `client.collections.create(...)`: This is the core method for creating a collection.\n        *   The first argument is the `name` of the collection.\n        *   `properties=collection_schema[\"properties\"]`: Passes the list of defined properties to the `properties` parameter.\n\n8.  **Verification (Optional):**\n    *   The code includes an optional section to verify that the collection was created successfully.\n    *   `client.collections.exists(collection_name)` is used again to confirm its presence.\n    *   `client.collections.get(collection_name).properties` retrieves the schema of the newly created collection, and the properties are printed to the console for visual confirmation.\n\n**Before running:**\n\n1.  **Install the Weaviate client:**\n    ```bash\n    pip install weaviate-client\n    ```\n2.  **Set Environment Variables:**\n    Make sure you have set the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables in your terminal or system. For example:\n\n    *   **Linux/macOS:**\n        ```bash\n        export WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n        export WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n    *   **Windows (Command Prompt):**\n        ```cmd\n        set WCD_TEST_URL=YOUR_WEAVIATE_CLOUD_URL\n        set WCD_TEST_KEY=YOUR_WEAVIATE_API_KEY\n        ```\n    *   **Windows (PowerShell):**\n        ```powershell\n        $env:WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n        $env:WCD_TEST_KEY=\"YOUR_WEAVIATE_API_KEY\"\n        ```\n    Replace `\"YOUR_WEAVIATE_CLOUD_URL\"` and `\"YOUR_WEAVIATE_API_KEY\"` with your actual Weaviate Cloud instance URL and API key.",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:13: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 13, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:41:42.315287",
      "duration": 6.84666895866394,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Get Weaviate Cloud credentials from environment variables\ncluster_url = os.getenv(\"WCD_TEST_URL\")\napi_key = os.getenv(\"WCD_TEST_KEY\")\n\nif not cluster_url or not api_key:\n    raise ValueError(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n\n# Connect to the Weaviate Cloud instance\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=cluster_url,\n        auth_credentials=Auth.api_key(api_key)\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\nexcept weaviate.UnexpectedStatusCodeException as e:\n    print(f\"Error connecting to Weaviate Cloud: {e}\")\n    exit()\n\n# Define the collection name\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    print(f\"Collection '{collection_name}' already exists. Deleting it.\")\n    try:\n        client.collections.delete(collection_name)\n        print(f\"Collection '{collection_name}' deleted successfully.\")\n    except weaviate.UnexpectedStatusCodeException as e:\n        print(f\"Error deleting collection '{collection_name}': {e}\")\n        # Continue to try creating the collection even if deletion failed,\n        # as it might be a permission issue or transient error.\n\n# Create the collection with specified properties\nprint(f\"Creating collection '{collection_name}'...\")\ntry:\n    products_collection = client.collections.create(\n        collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n    print(f\"Collection '{products_collection.name}' created successfully.\")\nexcept weaviate.UnexpectedStatusCodeException as e:\n    print(f\"Error creating collection '{collection_name}': {e}\")\n\n# Close connection\nclient.close()\nprint(\"Connection to Weaviate Cloud closed.\")\n```\n\n**To run this code:**\n\n1.  **Install the Weaviate client:**\n    ```bash\n    pip install weaviate-client\n    ```\n\n2.  **Set Environment Variables:**\n    Before running the script, you need to set the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables. You can do this in your terminal before executing the Python script:\n\n    *   **On Linux/macOS:**\n        ```bash\n        export WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n        export WCD_TEST_KEY=\"YOUR_WEAVIATE_CLOUD_API_KEY\"\n        python your_script_name.py\n        ```\n\n    *   **On Windows (Command Prompt):**\n        ```cmd\n        set WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n        set WCD_TEST_KEY=\"YOUR_WEAVIATE_CLOUD_API_KEY\"\n        python your_script_name.py\n        ```\n\n    *   **On Windows (PowerShell):**\n        ```powershell\n        $env:WCD_TEST_URL=\"YOUR_WEAVIATE_CLOUD_URL\"\n        $env:WCD_TEST_KEY=\"YOUR_WEAVIATE_CLOUD_API_KEY\"\n        python your_script_name.py\n        ```\n\n    Replace `\"YOUR_WEAVIATE_CLOUD_URL\"` and `\"YOUR_WEAVIATE_CLOUD_API_KEY\"` with your actual Weaviate Cloud instance URL and API key.\n\n**Explanation:**\n\n1.  **Import necessary modules:** `os` for accessing environment variables, and `weaviate` along with specific classes from `weaviate.classes`.\n2.  **Get credentials:** The code retrieves the Weaviate Cloud URL and API key from the `WCD_TEST_URL` and `WCD_TEST_KEY` environment variables using `os.getenv()`. It also includes a check to ensure these variables are set.\n3.  **Connect to Weaviate Cloud:** `weaviate.connect_to_weaviate_cloud()` establishes the connection. It uses `Auth.api_key()` to provide the authentication credentials. A `try-except` block is added for basic error handling during connection.\n4.  **Define Collection Name:** The desired collection name, \"DemoProducts\", is stored in a variable.\n5.  **Check and Delete Existing Collection:**\n    *   `client.collections.exists(collection_name)` checks if a collection with that name already exists.\n    *   If it exists, `client.collections.delete(collection_name)` is called to remove it. This is crucial for ensuring a clean state for testing. Error handling is included for the deletion process.\n6.  **Create the Collection:**\n    *   `client.collections.create()` is used to create the new collection.\n    *   The `collection_name` is passed as the first argument.\n    *   The `properties` argument is a list of `Property` objects. Each `Property` object defines the `name` and `data_type` of a schema field.\n        *   `DataType.TEXT` is used for string properties.\n        *   `DataType.NUMBER` is used for numerical properties (defaults to `float`).\n        *   `DataType.BOOL` is used for boolean properties.\n    *   A `try-except` block wraps the creation process to catch potential errors.\n7.  **Print Confirmation:** A message is printed indicating that the collection was created successfully.\n8.  **Close Connection:** `client.close()` is important to release resources and properly close the connection to the Weaviate instance.",
      "stdout": "Successfully connected to Weaviate Cloud.\nCollection 'DemoProducts' already exists. Deleting it.\nCollection 'DemoProducts' deleted successfully.\nCreating collection 'DemoProducts'...\nCollection 'DemoProducts' created successfully.\nConnection to Weaviate Cloud closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:41:44.831551",
      "duration": 2.4779932498931885,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\nimport os\n\n# Replace with your actual environment variable names if they differ\nWEAVIATE_URL_ENV_VAR = \"WCD_TEST_URL\"\nWEAVIATE_KEY_ENV_VAR = \"WCD_TEST_KEY\"\n\n# Retrieve Weaviate Cloud credentials from environment variables\nweaviate_url = os.getenv(WEAVIATE_URL_ENV_VAR)\nweaviate_key = os.getenv(WEAVIATE_KEY_ENV_VAR)\n\nif not weaviate_url or not weaviate_key:\n    raise ValueError(\n        f\"Please set the environment variables '{WEAVIATE_URL_ENV_VAR}' and '{WEAVIATE_KEY_ENV_VAR}'\"\n    )\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=weaviate_url,\n    auth_credentials=weaviate.Auth.api_key(weaviate_key),\n)\n\ncollection_name = \"DemoProducts\"\n\ntry:\n    # Check if the collection exists and delete it if it does\n    if client.collections.exists(collection_name):\n        print(f\"Collection '{collection_name}' already exists. Deleting it.\")\n        client.collections.delete(collection_name)\n        print(f\"Collection '{collection_name}' deleted.\")\n\n    # Create the \"DemoProducts\" collection with specified properties\n    print(f\"Creating collection '{collection_name}'...\")\n    client.collections.create(\n        collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ],\n        # You can optionally configure a vectorizer here if you plan to perform semantic searches.\n        # For example, using Weaviate's built-in text2vec-weaviate:\n        # vector_config=weaviate.classes.config.Configure.Vectors.text2vec_weaviate(),\n    )\n    print(f\"Collection '{collection_name}' created successfully.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    client.close()\n    print(\"Weaviate client connection closed.\")\n```",
      "stdout": "",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 21, in <module>\n    auth_credentials=weaviate.Auth.api_key(weaviate_key),\n  File \"/usr/local/lib/python3.9/site-packages/weaviate/__init__.py\", line 145, in __getattr__\n    raise AttributeError(f\"module {__name__} has no attribute {name}\")\nAttributeError: module weaviate has no attribute Auth\n",
      "exit_code": 1
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:41:50.960916",
      "duration": 5.440097093582153,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom dotenv import load_dotenv\n\n# Load environment variables from a .env file\nload_dotenv()\n\n# Get Weaviate Cloud connection details from environment variables\nweaviate_url = os.getenv(\"WCD_TEST_URL\")\nweaviate_key = os.getenv(\"WCD_TEST_KEY\")\n\nif not weaviate_url or not weaviate_key:\n    raise ValueError(\"WCD_TEST_URL and WCD_TEST_KEY environment variables must be set.\")\n\n# Connect to Weaviate Cloud\nclient = weaviate.Client(\n    url=weaviate_url,\n    auth_client_secret=weaviate.AuthApiKey(weaviate_key),\n)\n\n# Define the collection schema\ncollection_name = \"DemoProducts\"\nschema = {\n    \"classes\": [\n        {\n            \"class\": collection_name,\n            \"description\": \"A collection of demo products\",\n            \"properties\": [\n                {\n                    \"name\": \"name\",\n                    \"dataType\": [\"text\"],\n                    \"description\": \"The name of the product\",\n                },\n                {\n                    \"name\": \"description\",\n                    \"dataType\": [\"text\"],\n                    \"description\": \"A description of the product\",\n                },\n            ],\n        }\n    ]\n}\n\n# Create the collection if it doesn't exist\nif not client.schema.exists(collection_name):\n    client.schema.create(schema)\n    print(f\"Collection '{collection_name}' created.\")\nelse:\n    print(f\"Collection '{collection_name}' already exists.\")\n\n# Prepare objects for batch import\nobjects_to_import = []\nfor i in range(50):\n    objects_to_import.append({\n        \"name\": f\"Product {i}\",\n        \"description\": f\"Description {i}\"\n    })\n\n# Batch import the objects\ntry:\n    with client.batch as batch:\n        batch.add_objects(\n            collection_name=collection_name,\n            objects=objects_to_import\n        )\n    print(f\"Successfully imported {len(objects_to_import)} objects into '{collection_name}'.\")\nexcept Exception as e:\n    print(f\"An error occurred during batch import: {e}\")\n\n# Get and print the number of objects in the collection\ntry:\n    count_result = client.query.aggregate(collection_name).with_total_count().do()\n    if 'data' in count_result and 'Get' in count_result['data'] and collection_name in count_result['data']['Get'] and 'totalCount' in count_result['data']['Get'][collection_name]:\n        num_objects = count_result['data']['Get'][collection_name]['totalCount']\n        print(f\"Number of objects in '{collection_name}': {num_objects}\")\n    else:\n        print(f\"Could not retrieve the total count for '{collection_name}'. Result: {count_result}\")\nexcept Exception as e:\n    print(f\"An error occurred while retrieving the object count: {e}\")\n```\n\n**Explanation:**\n\n1.  **Import necessary libraries:**\n    *   `os`: To access environment variables.\n    *   `weaviate`: The Weaviate client library.\n    *   `dotenv.load_dotenv`: To load environment variables from a `.env` file (good practice for managing secrets).\n\n2.  **Load Environment Variables:**\n    *   `load_dotenv()`: This function searches for a `.env` file in the current directory and its parents, and loads any variables defined in it into the environment.\n    *   `os.getenv(\"WCD_TEST_URL\")` and `os.getenv(\"WCD_TEST_KEY\")`: These lines retrieve the Weaviate Cloud URL and API key from the environment variables.\n    *   An error is raised if these variables are not found, as they are crucial for connecting.\n\n3.  **Connect to Weaviate Cloud:**\n    *   `client = weaviate.Client(...)`: This initializes the Weaviate client.\n        *   `url=weaviate_url`: Specifies the Weaviate instance URL.\n        *   `auth_client_secret=weaviate.AuthApiKey(weaviate_key)`: Provides the API key for authentication.\n\n4.  **Define Collection Schema:**\n    *   A Python dictionary `schema` is created to define the structure of your \"DemoProducts\" collection.\n    *   `class`: The name of the collection.\n    *   `description`: A human-readable description of the collection.\n    *   `properties`: A list of dictionaries, where each dictionary defines a property:\n        *   `name`: The name of the property (e.g., \"name\", \"description\").\n        *   `dataType`: The data type of the property (e.g., `[\"text\"]`). Weaviate uses a list for data types as a property can have multiple types in certain advanced scenarios, but for basic properties, it's usually a single type.\n        *   `description`: A description for the property.\n\n5.  **Create Collection:**\n    *   `if not client.schema.exists(collection_name):`: This checks if the collection already exists in the Weaviate instance.\n    *   `client.schema.create(schema)`: If the collection doesn't exist, this command creates it with the defined schema.\n\n6.  **Prepare Objects for Batch Import:**\n    *   An empty list `objects_to_import` is created.\n    *   A `for` loop iterates 50 times to generate the arbitrary product data.\n    *   Each product is represented as a dictionary with \"name\" and \"description\" properties.\n\n7.  **Batch Import Objects:**\n    *   `with client.batch as batch:`: This uses a context manager for efficient batch operations.\n    *   `batch.add_objects(...)`: This is the core of the batch import.\n        *   `collection_name=collection_name`: Specifies the target collection.\n        *   `objects=objects_to_import`: Provides the list of objects to be imported.\n    *   A `try-except` block is used to catch potential errors during the import process.\n\n8.  **Get and Print Object Count:**\n    *   `client.query.aggregate(collection_name).with_total_count().do()`: This is how you get the total count of objects in a collection using the latest client syntax.\n        *   `aggregate(collection_name)`: Initiates an aggregation query on the specified collection.\n        *   `with_total_count()`: Modifies the aggregation to include the total count of objects.\n        *   `do()`: Executes the query.\n    *   The code then parses the result of the aggregation query to extract and print the `totalCount`. A `try-except` block handles potential issues with retrieving the count.\n\n**To run this code:**\n\n1.  **Install libraries:**\n    ```bash\n    pip install weaviate-client python-dotenv\n    ```\n2.  **Create a `.env` file:** In the same directory as your Python script, create a file named `.env` and add your Weaviate Cloud credentials:\n    ```dotenv\n    WCD_TEST_URL=YOUR_WEAVIATE_CLOUD_URL\n    WCD_TEST_KEY=YOUR_WEAVIATE_CLOUD_API_KEY\n    ```\n    Replace `YOUR_WEAVIATE_CLOUD_URL` and `YOUR_WEAVIATE_CLOUD_API_KEY` with your actual credentials.\n3.  **Run the Python script:**\n    ```bash\n    python your_script_name.py\n    ```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:16: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 16, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:41:56.618836",
      "duration": 4.944031000137329,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nimport os\nfrom weaviate.auth import Auth\n\n# Get Weaviate Cloud credentials from environment variables\ncluster_url = os.environ.get(\"WCD_TEST_URL\")\napi_key = os.environ.get(\"WCD_TEST_KEY\")\n\nif not cluster_url or not api_key:\n    raise ValueError(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n\n# Connect to Weaviate Cloud\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=cluster_url,\n        auth_credentials=Auth.api_key(api_key),\n    )\n    print(\"Successfully connected to Weaviate Cloud.\")\nexcept Exception as e:\n    print(f\"Error connecting to Weaviate Cloud: {e}\")\n    exit()\n\ncollection_name = \"DemoProducts\"\n\n# Ensure the collection exists, create if not\nif not client.collections.exists(collection_name):\n    print(f\"Collection '{collection_name}' does not exist. Creating it...\")\n    client.collections.create(\n        name=collection_name,\n        properties=[\n            weaviate.Property(name=\"name\", data_type=weaviate.DataType.TEXT),\n            weaviate.Property(name=\"description\", data_type=weaviate.DataType.TEXT),\n        ]\n    )\n    print(f\"Collection '{collection_name}' created.\")\nelse:\n    print(f\"Collection '{collection_name}' already exists.\")\n\n# Get the collection object\ncollection = client.collections.get(collection_name)\n\n# Generate 50 arbitrary objects\ndata_rows = [\n    {\n        \"name\": f\"Product {i+1}\",\n        \"description\": f\"This is the description for product number {i+1}.\"\n    } for i in range(50)\n]\n\n# Batch import objects\nprint(\"Starting batch import...\")\ntry:\n    with collection.batch.dynamic() as batch:\n        for data_row in data_rows:\n            batch.add_object(\n                properties=data_row,\n            )\n            # Optional: add a check for errors during batching\n            if batch.number_errors > 10:\n                print(\"Batch import stopped due to excessive errors.\")\n                break\n    print(\"Batch import completed.\")\n\n    # Check for failed imports\n    failed_objects = collection.batch.failed_objects\n    if failed_objects:\n        print(f\"Number of failed imports: {len(failed_objects)}\")\n        # print(f\"First failed object: {failed_objects[0]}\") # Uncomment to see details of a failed object\n    else:\n        print(\"All objects imported successfully.\")\n\nexcept Exception as e:\n    print(f\"An error occurred during batch import: {e}\")\n\n# Print the number of objects in the collection\ntry:\n    num_objects = len(collection)\n    print(f\"Number of objects in the '{collection_name}' collection: {num_objects}\")\nexcept Exception as e:\n    print(f\"Error retrieving object count: {e}\")\n\n# Close the client connection\nclient.close()\nprint(\"Weaviate client connection closed.\")\n```",
      "stdout": "Successfully connected to Weaviate Cloud.\nCollection 'DemoProducts' already exists.\nStarting batch import...\nBatch import completed.\nAll objects imported successfully.\nNumber of objects in the 'DemoProducts' collection: 50\nWeaviate client connection closed.\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:42:00.448914",
      "duration": 3.118525743484497,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    )\nexcept KeyError as e:\n    print(f\"Error: Environment variable {e} not set.\")\n    print(\"Please set WCD_TEST_URL and WCD_TEST_KEY to connect to Weaviate Cloud.\")\n    exit()\n\n# Define the collection schema\ncollection_name = \"DemoProducts\"\nproperties = [\n    Property(name=\"name\", data_type=DataType.TEXT),\n    Property(name=\"description\", data_type=DataType.TEXT),\n]\n\n# Create the collection if it doesn't exist\nif not client.collections.exists(collection_name):\n    client.collections.create(\n        collection_name,\n        properties=properties,\n    )\n    print(f\"Collection '{collection_name}' created.\")\nelse:\n    print(f\"Collection '{collection_name}' already exists.\")\n\ncollection = client.collections.get(collection_name)\n\n# Batch import 50 arbitrary objects\nprint(\"Starting batch import...\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(50):\n        batch.add_object(\n            properties={\n                \"name\": f\"Product {i+1}\",\n                \"description\": f\"This is the description for product number {i+1}.\",\n            }\n        )\nprint(\"Batch import complete.\")\n\n# Print the number of objects in the collection\nnum_objects = collection.query.get().with_limit(1).with_fields(\"name\").do()[\"Get\"][collection_name]\nprint(f\"Number of objects in the '{collection_name}' collection: {num_objects}\")\n\n\n# Close the client connection\nclient.close()\n```",
      "stdout": "Collection 'DemoProducts' already exists.\nStarting batch import...\nBatch import complete.\n",
      "stderr": "Traceback (most recent call last):\n  File \"/code/code.py\", line 49, in <module>\n    num_objects = collection.query.get().with_limit(1).with_fields(\"name\").do()[\"Get\"][collection_name]\nAttributeError: '_QueryCollection' object has no attribute 'get'\n/usr/local/lib/python3.9/site-packages/weaviate/warnings.py:302: ResourceWarning: Con004: The connection to Weaviate was not closed properly. This can lead to memory leaks.\n            Please make sure to close the connection using `client.close()`.\n  warnings.warn(\nsys:1: ResourceWarning: unclosed <ssl.SSLSocket fd=3, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=6, laddr=('172.17.0.2', 48984), raddr=('34.111.245.21', 443)>\n",
      "exit_code": 1
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T22:42:03.334960",
      "duration": 2.442776918411255,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Connect to Weaviate Cloud\nclient = weaviate.Client(\n    url=os.getenv(\"WCD_TEST_URL\"),\n    auth_client_secret=weaviate.AuthApiKey(api_key=os.getenv(\"WCD_TEST_KEY\")),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": os.getenv(\"OPENAI_API_KEY\")\n    }\n)\n\n# Define the query\nquery = \"dessert wine\"\n\n# Perform the nearText search\ntry:\n    result = (\n        client.query\n        .get(\"WineReview\", [\"title\", \"country\", \"price\", \"points\"])\n        .with_near_text({\"concepts\": query})\n        .with_limit(2)\n        .do()\n    )\n\n    # Print the results\n    if \"data\" in result and \"Get\" in result[\"data\"] and \"WineReview\" in result[\"data\"][\"Get\"]:\n        for wine in result[\"data\"][\"Get\"][\"WineReview\"]:\n            print(f\"Title: {wine.get('title')}\")\n            print(f\"Country: {wine.get('country')}\")\n            print(f\"Price: {wine.get('price')}\")\n            print(f\"Points: {wine.get('points')}\")\n            print(\"-\" * 20)\n    else:\n        print(\"No results found or unexpected response format.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:5: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 5, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:42:07.312872",
      "duration": 3.550990104675293,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Get connection details from environment variables\nweaviate_url = os.getenv(\"WCD_TEST_URL\")\nweaviate_key = os.getenv(\"WCD_TEST_KEY\")\nopenai_api_key = os.getenv(\"OPENAI_API_KEY\")\n\n# Ensure all required environment variables are set\nif not all([weaviate_url, weaviate_key, openai_api_key]):\n    raise ValueError(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY environment variables.\")\n\ntry:\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=weaviate_url,\n        auth_credentials=Auth.api_key(weaviate_key),\n        headers={\n            \"X-OpenAI-API-Key\": openai_api_key\n        },\n    )\n\n    # Get the WineReview collection\n    collection = client.collections.get(\"WineReview\")\n\n    # Query the collection for \"dessert wine\"\n    response = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        include_vector=False  # We don't need the vector for this output\n    )\n\n    # Print the title, country, price, and points of each matching wine\n    if response.objects:\n        print(\"Matching wines:\")\n        for obj in response.objects:\n            properties = obj.properties\n            print(f\"  Title: {properties.get('title', 'N/A')}\")\n            print(f\"  Country: {properties.get('country', 'N/A')}\")\n            print(f\"  Price: {properties.get('price', 'N/A')}\")\n            print(f\"  Points: {properties.get('points', 'N/A')}\")\n            print(\"-\" * 20)\n    else:\n        print(\"No matching wines found.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    if 'client' in locals() and client:\n        client.close()\n```",
      "stdout": "Matching wines:\n  Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\n  Country: US\n  Price: 24.0\n  Points: 88\n--------------------\n  Title: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\n  Country: US\n  Price: 40.0\n  Points: 88\n--------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:42:11.109259",
      "duration": 3.301774024963379,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\n            # Add inference API keys as needed\n            \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n        }\n    )\n\n    # Get the WineReview collection\n    wine_reviews = client.collections.get(\"WineReview\")\n\n    # Query for \"dessert wine\" with a limit of 2 results\n    response = wine_reviews.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # Print the results\n    for wine in response.objects:\n        print(f\"Title: {wine.properties.get('title')}\")\n        print(f\"Country: {wine.properties.get('country')}\")\n        print(f\"Price: {wine.properties.get('price')}\")\n        print(f\"Points: {wine.properties.get('points')}\")\n        print(\"-\" * 20)\n\nexcept weaviate.UnexpectedStatusCodeException as e:\n    print(f\"An error occurred: {e}\")\n    print(\"Please ensure that:\")\n    print(\"1. The WCD_TEST_URL and WCD_TEST_KEY environment variables are set correctly.\")\n    print(\"2. The OPENAI_API_KEY environment variable is set correctly.\")\n    print(\"3. The 'WineReview' collection exists and uses the 'text2vec-openai' vectorizer.\")\nexcept KeyError as e:\n    print(f\"Environment variable not set: {e}\")\n    print(\"Please ensure that WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY are set.\")\nexcept Exception as e:\n    print(f\"An unexpected error occurred: {e}\")\nfinally:\n    # Ensure the client connection is closed\n    if 'client' in locals() and client:\n        client.close()\n```",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n--------------------\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n--------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:42:15.171856",
      "duration": 3.6293461322784424,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Get Weaviate Cloud connection details from environment variables\nwcd_url = os.environ.get(\"WCD_TEST_URL\")\nwcd_key = os.environ.get(\"WCD_TEST_KEY\")\nopenai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n\nif not all([wcd_url, wcd_key, openai_api_key]):\n    raise ValueError(\n        \"Please set the WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY environment variables.\"\n    )\n\n# Connect to Weaviate Cloud\nclient = weaviate.Client(\n    url=wcd_url,\n    auth_client_secret=weaviate.AuthApiKey(api_key=wcd_key),\n    additional_headers={\n        \"X-OpenAI-Api-Key\": openai_api_key,\n    },\n)\n\n# Define the query\nquery = \"pair with steak\"\n\n# Define the hybrid search parameters\nhybrid_params = {\n    \"keywords\": query,\n    \"alpha\": 0.5,\n}\n\n# Define the filter conditions\nwhere_filter = {\n    \"operator\": \"And\",\n    \"operands\": [\n        {\n            \"path\": [\"price\"],\n            \"operator\": \"LessThan\",\n            \"value_number\": 50,\n        },\n        {\n            \"path\": [\"points\"],\n            \"operator\": \"GreaterThan\",\n            \"value_number\": 90,\n        },\n        {\n            \"operator\": \"Or\",\n            \"operands\": [\n                {\n                    \"path\": [\"review_body\"],\n                    \"operator\": \"ContainsAny\",\n                    \"value_string\": \"spice\",\n                },\n                {\n                    \"path\": [\"review_body\"],\n                    \"operator\": \"ContainsAny\",\n                    \"value_string\": \"fruit\",\n                },\n                {\n                    \"path\": [\"review_body\"],\n                    \"operator\": \"ContainsAny\",\n                    \"value_string\": \"berry\",\n                },\n                {\n                    \"path\": [\"review_body\"],\n                    \"operator\": \"ContainsAny\",\n                    \"value_string\": \"cherry\",\n                },\n                {\n                    \"path\": [\"review_body\"],\n                    \"operator\": \"ContainsAny\",\n                    \"value_string\": \"honey\",\n                },\n            ],\n        },\n    ],\n}\n\n# Build the GraphQL query\ntry:\n    response = (\n        client.query.get(\n            \"WineReview\",\n            [\n                \"title\",\n                \"country\",\n                \"price\",\n                \"points\",\n            ],\n        )\n        .with_hybrid(**hybrid_params)\n        .with_where(where_filter)\n        .with_limit(5)\n        .do()\n    )\n\n    # Print the results\n    if response and \"data\" in response and \"Get\" in response[\"data\"] and \"WineReview\" in response[\"data\"][\"Get\"]:\n        wines = response[\"data\"][\"Get\"][\"WineReview\"]\n        if wines:\n            print(\"Matching wines:\")\n            for wine in wines:\n                print(f\"- Title: {wine.get('title', 'N/A')}\")\n                print(f\"  Country: {wine.get('country', 'N/A')}\")\n                print(f\"  Price: {wine.get('price', 'N/A')}\")\n                print(f\"  Points: {wine.get('points', 'N/A')}\")\n        else:\n            print(\"No wines found matching the criteria.\")\n    else:\n        print(\"Error retrieving data or no results found.\")\n        if response:\n            print(\"Response:\", response)\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:15: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 15, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:42:18.896327",
      "duration": 3.2245380878448486,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\n# Retrieve credentials from environment variables\nWCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.environ.get(\"OPENAI_API_KEY\")\n\nif not all([WCD_TEST_URL, WCD_TEST_KEY, OPENAI_API_KEY]):\n    raise ValueError(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY environment variables.\")\n\ntry:\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY),\n        headers={\n            \"X-OpenAI-API-Key\": OPENAI_API_KEY\n        },\n    )\n\n    # Get the WineReview collection\n    collection = client.collections.get(\"WineReview\")\n\n    # Perform the hybrid search\n    response = collection.query.hybrid(\n        query=\"pair with steak\",\n        limit=5,\n        alpha=0.5,\n        filters=(\n            Filter.by_property(\"price\").less_than(50) &\n            Filter.by_property(\"points\").greater_than(90) &\n            Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n        ),\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n        return_metadata=MetadataQuery(score=True)\n    )\n\n    # Print the results\n    if response.objects:\n        print(\"Matching wines:\")\n        for obj in response.objects:\n            print(f\"  Title: {obj.properties['title']}\")\n            print(f\"  Country: {obj.properties['country']}\")\n            print(f\"  Price: ${obj.properties['price']}\")\n            print(f\"  Points: {obj.properties['points']}\")\n            print(f\"  Score: {obj.metadata.score:.4f}\")\n            print(\"-\" * 20)\n    else:\n        print(\"No wines found matching the criteria.\")\n\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\n\nfinally:\n    # Close the client connection\n    if 'client' in locals() and client:\n        client.close()\n```",
      "stdout": "Matching wines:\n  Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price: $40.0\n  Points: 92\n  Score: 0.5000\n--------------------\n  Title: Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price: $49.0\n  Points: 91\n  Score: 0.3765\n--------------------\n  Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price: $27.0\n  Points: 91\n  Score: 0.0451\n--------------------\n  Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price: $25.0\n  Points: 93\n  Score: 0.0162\n--------------------\n  Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price: $0.0\n  Points: 92\n  Score: 0.0010\n--------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:42:23.334149",
      "duration": 3.9525840282440186,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, HybridFusion\nfrom weaviate.classes.config import DataType, Property\nimport os\n\n# Connect to Weaviate Cloud\ntry:\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\n            \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n        }\n    )\n\n    # Get the WineReview collection\n    wine_reviews = client.collections.get(\"WineReview\")\n\n    # Define the search query and filters\n    search_query = \"pair with steak\"\n    keyword_filters = [\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ]\n    price_filter = Filter.by_property(\"price\").less_than(50)\n    points_filter = Filter.by_property(\"points\").greater_than(90)\n\n    # Combine all filters\n    combined_filters = Filter.all_of(\n        filters=[\n            Filter.any_of(filters=keyword_filters),\n            price_filter,\n            points_filter\n        ]\n    )\n\n    # Perform the hybrid search\n    response = wine_reviews.query.hybrid(\n        query=search_query,\n        alpha=0.5,  # Hybrid search balance\n        filters=combined_filters,\n        limit=5,\n        return_properties=[\"title\", \"country\", \"price\", \"points\", \"review_body\"]\n    )\n\n    # Print the results\n    if response.objects:\n        print(f\"Found {len(response.objects)} wines that match your criteria:\")\n        for wine in response.objects:\n            print(f\"- Title: {wine.properties['title']}\")\n            print(f\"  Country: {wine.properties['country']}\")\n            print(f\"  Price: ${wine.properties['price']:.2f}\")\n            print(f\"  Points: {wine.properties['points']}\")\n    else:\n        print(\"No wines found matching your criteria.\")\n\nexcept KeyError as e:\n    print(f\"Environment variable not set: {e}\")\n    print(\"Please set WCD_TEST_URL, WCD_TEST_KEY, and OPENAI_API_KEY environment variables.\")\nexcept Exception as e:\n    print(f\"An error occurred: {e}\")\nfinally:\n    # Close the client connection\n    if 'client' in locals() and client:\n        client.close()\n```",
      "stdout": "Found 5 wines that match your criteria:\n- Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\n  Country: US\n  Price: $40.00\n  Points: 92\n- Title: Bink 2014 Pinot Noir (Anderson Valley)\n  Country: US\n  Price: $49.00\n  Points: 91\n- Title: Do\u00f1a Silvina 2011 Malbec (Mendoza)\n  Country: Argentina\n  Price: $27.00\n  Points: 91\n- Title: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\n  Country: Hungary\n  Price: $25.00\n  Points: 93\n- Title: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\n  Country: Italy\n  Price: $0.00\n  Points: 92\n",
      "stderr": "",
      "exit_code": 0
    }
  },
  "openai/gpt-5-2025-08-07": {
    "zero_shot_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:42:43.013692",
      "duration": 19.660351991653442,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\nurl = os.environ[\"WCD_TEST_URL\"]\napi_key = os.environ[\"WCD_TEST_KEY\"]\n\nwith weaviate.connect_to_wcs(\n    cluster_url=url,\n    auth_credentials=Auth.api_key(api_key),\n) as client:\n    if client.is_ready():\n        print(\"Weaviate server is ready.\")\n    else:\n        raise SystemExit(\"Weaviate server is not ready.\")",
      "stdout": "Weaviate server is ready.\n",
      "stderr": "/code/code.py:8: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  with weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:42:52.736715",
      "duration": 9.704532146453857,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n)\n\nassert client.is_ready()\n\nclient.close()",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:43:12.554415",
      "duration": 19.798925638198853,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:43:24.733979",
      "duration": 12.144175052642822,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Read connection details from environment variables\ncluster_url = os.getenv(\"WCD_TEST_URL\")\napi_key = os.getenv(\"WCD_TEST_KEY\")\n\nif not cluster_url or not api_key:\n    raise ValueError(\"Please set the WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key),\n)\n\ntry:\n    collection_name = \"DemoProducts\"\n\n    # Delete the collection if it already exists\n    if client.collections.exists(collection_name):\n        client.collections.delete(collection_name)\n\n    # Create the collection\n    products_collection = client.collections.create(\n        collection_name,\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ],\n    )\n\n    print(f\"Created collection: {products_collection.name}\")\nfinally:\n    # Close connection\n    client.close()",
      "stdout": "Created collection: DemoProducts\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:43:45.016408",
      "duration": 20.26258111000061,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Configure, Property, DataType\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n)\n\ntry:\n    # Delete collection if it already exists\n    if client.collections.exists(\"DemoProducts\"):\n        client.collections.delete(\"DemoProducts\")\n\n    # Create the collection with properties\n    client.collections.create(\n        \"DemoProducts\",\n        # Recommended for Weaviate Cloud; no third-party API key required\n        vector_config=Configure.Vectors.text2vec_weaviate(),\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ],\n    )\nfinally:\n    client.close()\n```",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:44:08.882263",
      "duration": 23.204583168029785,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:44:29.105413",
      "duration": 19.530550956726074,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:45:00.670170",
      "duration": 30.886969089508057,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "zero_shot_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:45:19.375634",
      "duration": 18.277709007263184,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "import os\nimport weaviate\n\n# Connect to Weaviate Cloud (WCS) and pass the OpenAI API key for text2vec-openai\nclient = weaviate.connect_to_wcs(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=weaviate.AuthApiKey(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]},\n)\n\ntry:\n    collection = client.collections.get(\"WineReview\")\n\n    result = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n    )\n\n    for obj in result.objects:\n        props = obj.properties or {}\n        print(f\"Title:   {props.get('title')}\")\n        print(f\"Country: {props.get('country')}\")\n        print(f\"Price:   {props.get('price')}\")\n        print(f\"Points:  {props.get('points')}\")\n        print(\"-\" * 40)\nfinally:\n    client.close()",
      "stdout": "Title:   Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice:   24.0\nPoints:  88\n----------------------------------------\nTitle:   Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice:   40.0\nPoints:  88\n----------------------------------------\n",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:5: DeprecatedWarning: connect_to_wcs is deprecated as of 4.6.2. \nThis method is deprecated and will be removed in a future release. Use :func:`connect_to_weaviate_cloud` instead.\n\n  client = weaviate.connect_to_wcs(\n/usr/local/lib/python3.9/site-packages/deprecation.py:260: DeprecationWarning: This method is deprecated and will be removed in a future release. Use `connect_to_weaviate_cloud` instead.\n  return function(*args, **kwargs)\n",
      "exit_code": 0
    },
    "simple_example_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:45:40.687930",
      "duration": 20.9065580368042,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\ndef main():\n    cluster_url = os.environ[\"WCD_TEST_URL\"]\n    wcd_api_key = os.environ[\"WCD_TEST_KEY\"]\n    openai_key = os.environ[\"OPENAI_API_KEY\"]\n\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=cluster_url,\n        auth_credentials=Auth.api_key(wcd_api_key),\n        headers={\"X-OpenAI-API-Key\": openai_key},\n    )\n\n    try:\n        collection = client.collections.get(\"WineReview\")\n\n        response = collection.query.near_text(\n            query=\"dessert wine\",\n            limit=2\n        )\n\n        for obj in response.objects:\n            props = obj.properties or {}\n            print(f\"Title: {props.get('title')}\")\n            print(f\"Country: {props.get('country')}\")\n            print(f\"Price: {props.get('price')}\")\n            print(f\"Points: {props.get('points')}\")\n            print()\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    main()",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice: 24.0\nPoints: 88\n\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice: 40.0\nPoints: 88\n\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:46:06.634298",
      "duration": 25.50486397743225,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\ndef main():\n    with weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n        headers={\"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]},\n    ) as client:\n        collection = client.collections.get(\"WineReview\")\n        response = collection.query.near_text(\n            query=\"dessert wine\",\n            limit=2,\n            return_properties=[\"title\", \"country\", \"price\", \"points\"],\n        )\n\n        for obj in response.objects:\n            props = obj.properties or {}\n            print(\n                f\"Title: {props.get('title')}, \"\n                f\"Country: {props.get('country')}, \"\n                f\"Price: {props.get('price')}, \"\n                f\"Points: {props.get('points')}\"\n            )\n\nif __name__ == \"__main__\":\n    main()",
      "stdout": "Title: Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA)), Country: US, Price: 24.0, Points: 88\nTitle: Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast), Country: US, Price: 40.0, Points: 88\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:46:35.127884",
      "duration": 28.098787784576416,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:46:54.603382",
      "duration": 19.05248713493347,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\n\n# Load environment variables\ncluster_url = os.environ[\"WCD_TEST_URL\"]\nwcd_api_key = os.environ[\"WCD_TEST_KEY\"]\nopenai_api_key = os.environ[\"OPENAI_API_KEY\"]\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(wcd_api_key),\n    headers={\"X-OpenAI-Api-Key\": openai_api_key},\n)\n\ntry:\n    collection = client.collections.get(\"WineReview\")\n\n    response = collection.query.hybrid(\n        query=\"pair with steak\",\n        limit=5,\n        alpha=0.5,\n        filters=(\n            Filter.by_property(\"price\").less_than(50)\n            & Filter.by_property(\"points\").greater_than(90)\n            & Filter.by_property(\"review_body\").contains_any(\n                [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n            )\n        ),\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n        return_metadata=MetadataQuery(score=True),\n    )\n\n    for obj in response.objects:\n        props = obj.properties or {}\n        print(f\"Title: {props.get('title')}\")\n        print(f\"Country: {props.get('country')}\")\n        print(f\"Price: {props.get('price')}\")\n        print(f\"Points: {props.get('points')}\")\n        print(f\"Score: {obj.metadata.score}\")\n        print(\"---\")\nfinally:\n    client.close()",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: 40.0\nPoints: 92\nScore: 0.5\n---\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: 49.0\nPoints: 91\nScore: 0.3765353560447693\n---\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: 27.0\nPoints: 91\nScore: 0.04513849690556526\n---\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: 25.0\nPoints: 93\nScore: 0.016171861439943314\n---\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: 0.0\nPoints: 92\nScore: 0.0010482011130079627\n---\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:47:36.803590",
      "duration": 41.79946684837341,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "",
      "error": "No code was executed"
    }
  },
  "openai/gpt-5-mini-2025-08-07": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T22:47:51.293989",
      "duration": 14.458086013793945,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "import os\nimport sys\nimport weaviate\n\nurl = os.environ.get(\"WCD_TEST_URL\")\napi_key = os.environ.get(\"WCD_TEST_KEY\")\n\nif not url or not api_key:\n    print(\"Environment variables WCD_TEST_URL and WCD_TEST_KEY must be set.\", file=sys.stderr)\n    sys.exit(2)\n\nclient = weaviate.Client(\n    url=url,\n    auth_client_secret=weaviate.AuthApiKey(api_key=api_key)\n)\n\nif client.is_ready():\n    print(\"Weaviate is ready\")\n    sys.exit(0)\nelse:\n    print(\"Weaviate is not ready\", file=sys.stderr)\n    sys.exit(1)",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:12: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 12, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_connect": {
      "success": false,
      "timestamp": "2025-08-17T22:48:01.514948",
      "duration": 10.201438188552856,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\n\n# Read credentials from environment\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\n\n# Connect to Weaviate Cloud\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n)\n\n# Check the server is ready to accept requests\nif not client.is_ready():\n    raise SystemExit(\"Weaviate server is not ready\")\n\nclient.close()\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:9: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 9, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:48:33.761682",
      "duration": 32.228538036346436,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:49:02.281582",
      "duration": 28.490673065185547,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:49:16.214627",
      "duration": 13.905470371246338,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "import os\nimport sys\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\ndef main():\n    WCD_TEST_URL = os.environ.get(\"WCD_TEST_URL\")\n    WCD_TEST_KEY = os.environ.get(\"WCD_TEST_KEY\")\n\n    if not WCD_TEST_URL or not WCD_TEST_KEY:\n        print(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\n        sys.exit(1)\n\n    collection_name = \"DemoProducts\"\n\n    # Use context manager to auto-close the client\n    with weaviate.connect_to_weaviate_cloud(\n        cluster_url=WCD_TEST_URL,\n        auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    ) as client:\n        try:\n            # If the collection exists, delete it first\n            if client.collections.exists(collection_name):\n                print(f\"Collection '{collection_name}' exists \u2014 deleting it...\")\n                client.collections.delete(collection_name)\n\n            # Define properties\n            properties = [\n                Property(name=\"name\", data_type=DataType.TEXT),\n                Property(name=\"description\", data_type=DataType.TEXT),\n                Property(name=\"price\", data_type=DataType.NUMBER),\n                Property(name=\"in_stock\", data_type=DataType.BOOL),\n            ]\n\n            # Create the collection\n            client.collections.create(\n                collection_name,\n                properties=properties\n            )\n\n            print(f\"Collection '{collection_name}' created with properties: name, description, price, in_stock\")\n\n        except Exception as e:\n            print(\"Error:\", e)\n            sys.exit(1)\n\nif __name__ == \"__main__\":\n    main()",
      "stdout": "Collection 'DemoProducts' exists \u2014 deleting it...\nCollection 'DemoProducts' created with properties: name, description, price, in_stock\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:49:36.627186",
      "duration": 19.76351308822632,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:50:01.859702",
      "duration": 24.54169988632202,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_batch_import": {
      "success": true,
      "timestamp": "2025-08-17T22:50:21.537733",
      "duration": 18.952510833740234,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "Here's a complete Python script using the latest Weaviate client syntax from your examples. It connects to Weaviate Cloud using WCD_TEST_URL and WCD_TEST_KEY, creates the \"DemoProducts\" collection (if it doesn't exist) with name and description text properties, batch-imports 50 objects, and prints the number of objects in the collection.\n\nSave as e.g. demo_products_import.py and run.\n\n```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\ndef main():\n    # Read connection details from environment\n    wc_url = os.environ[\"WCD_TEST_URL\"]\n    wc_key = os.environ[\"WCD_TEST_KEY\"]\n\n    # Connect to Weaviate Cloud\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=wc_url,\n        auth_credentials=Auth.api_key(wc_key)\n    )\n\n    try:\n        collection_name = \"DemoProducts\"\n\n        # Create collection if it doesn't exist\n        if not client.collections.exists(collection_name):\n            client.collections.create(\n                collection_name,\n                properties=[\n                    Property(name=\"name\", data_type=DataType.TEXT),\n                    Property(name=\"description\", data_type=DataType.TEXT),\n                ]\n            )\n            print(f\"Created collection '{collection_name}'\")\n        else:\n            print(f\"Collection '{collection_name}' already exists\")\n\n        # Get the collection object\n        collection = client.collections.get(collection_name)\n\n        # Batch import 50 objects\n        with collection.batch.fixed_size(batch_size=50) as batch:\n            for i in range(50):\n                batch.add_object(\n                    properties={\n                        \"name\": f\"Product {i}\",\n                        \"description\": f\"Description {i}\",\n                    }\n                )\n            # optional: check for errors while still in context\n            if batch.number_errors:\n                print(f\"Batch reported errors: {batch.number_errors}\")\n\n        # Check for failed objects after batch completes\n        failed = collection.batch.failed_objects\n        if failed:\n            print(f\"Number of failed objects: {len(failed)}\")\n            # Optionally inspect failed objects\n            # for f in failed: print(f)\n\n        # Count objects in the collection by iterating (works reliably)\n        count = sum(1 for _ in collection.iterator())\n        print(f\"Number of objects in '{collection_name}': {count}\")\n\n    finally:\n        client.close()\n\nif __name__ == \"__main__\":\n    main()\n```\n\nNotes:\n- This uses the batch.fixed_size(...) context manager to send 50 objects in a single batch.\n- Counting is done via collection.iterator(), which is simple and reliable for small collections (and fine for 50 objects). If you need a more direct/efficient count for very large datasets, use the appropriate count API if available in your environment.",
      "stdout": "Collection 'DemoProducts' already exists\nNumber of objects in 'DemoProducts': 50\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T22:50:39.413945",
      "duration": 17.458653926849365,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "```python\nimport os\nimport sys\nimport weaviate\n\n# Load environment variables\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\nif not WCD_TEST_URL or not WCD_TEST_KEY:\n    sys.exit(\"Please set WCD_TEST_URL and WCD_TEST_KEY environment variables.\")\nif not OPENAI_API_KEY:\n    sys.exit(\"Please set OPENAI_API_KEY environment variable.\")\n\n# Connect to Weaviate Cloud using API key auth and pass OpenAI key to the server\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n    additional_headers={\"X-OpenAI-Api-Key\": OPENAI_API_KEY},\n)\n\n# Query the WineReview class for the best matches to \"dessert wine\", limit 2\nresponse = (\n    client.query\n    .get(\"WineReview\", [\"title\", \"country\", \"price\", \"points\"])\n    .with_near_text({\"concepts\": [\"dessert wine\"]})\n    .with_limit(2)\n    .do()\n)\n\n# Extract results\nitems = response.get(\"data\", {}).get(\"Get\", {}).get(\"WineReview\", [])\n\nif not items:\n    print(\"No results found.\")\nelse:\n    for i, item in enumerate(items, start=1):\n        title = item.get(\"title\")\n        country = item.get(\"country\")\n        price = item.get(\"price\")\n        points = item.get(\"points\")\n        print(f\"Result {i}:\")\n        print(f\"  Title:   {title}\")\n        print(f\"  Country: {country}\")\n        print(f\"  Price:   {price}\")\n        print(f\"  Points:  {points}\")\n        print()\n```",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:16: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 16, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "simple_example_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T22:50:59.080325",
      "duration": 19.1612491607666,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "import os\nimport weaviate\n\n# Load credentials from environment\nWCD_TEST_URL = os.getenv(\"WCD_TEST_URL\")\nWCD_TEST_KEY = os.getenv(\"WCD_TEST_KEY\")\nOPENAI_API_KEY = os.getenv(\"OPENAI_API_KEY\")\n\nif not (WCD_TEST_URL and WCD_TEST_KEY and OPENAI_API_KEY):\n    raise RuntimeError(\"Please set WCD_TEST_URL, WCD_TEST_KEY and OPENAI_API_KEY environment variables.\")\n\n# Connect to Weaviate Cloud (latest client syntax)\nclient = weaviate.Client(\n    url=WCD_TEST_URL,\n    auth_client_secret=weaviate.AuthApiKey(api_key=WCD_TEST_KEY),\n    additional_headers={\"X-OpenAI-API-Key\": OPENAI_API_KEY},\n)\n\ntry:\n    # Get the collection\n    collection = client.collections.get(\"WineReview\")\n\n    # Perform a near-text query for \"dessert wine\" with a maximum of 2 results\n    response = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2\n    )\n\n    # Extract objects robustly (handle different possible return shapes)\n    objs = getattr(response, \"objects\", None) or response.get(\"objects\", []) or []\n\n    for obj in objs:\n        props = getattr(obj, \"properties\", None) or obj.get(\"properties\", {}) or {}\n        title = props.get(\"title\")\n        country = props.get(\"country\")\n        price = props.get(\"price\")\n        points = props.get(\"points\")\n\n        print(f\"Title: {title}\")\n        print(f\"Country: {country}\")\n        print(f\"Price: {price}\")\n        print(f\"Points: {points}\")\n        print(\"-\" * 40)\n\nfinally:\n    client.close()",
      "stdout": "",
      "stderr": "/usr/local/lib/python3.9/site-packages/weaviate/__init__.py:143: DeprecationWarning: Dep010: Importing AuthApiKey from weaviate is deprecated. Import AuthApiKey from its module: weaviate.auth\n  _Warnings.root_module_import(name, map_[name])\n/code/code.py:13: DeprecationWarning: \nPython client v3 `weaviate.Client(...)` has been removed.\n\nUpgrade your code to use Python client v4 `weaviate.WeaviateClient` connections and methods.\n    - For Python Client v4 usage, see: https://weaviate.io/developers/weaviate/client-libraries/python\n    - For code migration, see: https://weaviate.io/developers/weaviate/client-libraries/python/v3_v4_migration\n\nIf you have to use v3 code, install the v3 client and pin the v3 dependency in your requirements file: `weaviate-client>=3.26.7;<4.0.0`\n  client = weaviate.Client(\nTraceback (most recent call last):\n  File \"/code/code.py\", line 13, in <module>\n    client = weaviate.Client(\nTypeError: __init__() got an unexpected keyword argument 'url'\n",
      "exit_code": 1
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:51:15.094773",
      "duration": 15.55816912651062,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Ensure required environment variables are present\nfor var in (\"WCD_TEST_URL\", \"WCD_TEST_KEY\", \"OPENAI_API_KEY\"):\n    if var not in os.environ:\n        raise EnvironmentError(f\"Environment variable {var} is required\")\n\n# Connect to Weaviate Cloud (and provide OpenAI API key for the text2vec-openai vectorizer)\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]},\n)\n\ntry:\n    collection = client.collections.get(\"WineReview\")\n\n    # Semantic search for \"dessert wine\" with a maximum of 2 results\n    response = collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n    )\n\n    if not response.objects:\n        print(\"No matching wines found.\")\n    else:\n        for obj in response.objects:\n            props = obj.properties or {}\n            print(\"Title:  \", props.get(\"title\"))\n            print(\"Country:\", props.get(\"country\"))\n            print(\"Price:  \", props.get(\"price\"))\n            print(\"Points: \", props.get(\"points\"))\n            print(\"-\" * 40)\nfinally:\n    client.close()",
      "stdout": "Title:   Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA))\nCountry: US\nPrice:   24.0\nPoints:  88\n----------------------------------------\nTitle:   Clos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast)\nCountry: US\nPrice:   40.0\nPoints:  88\n----------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:51:36.324986",
      "duration": 20.784691095352173,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:51:53.128078",
      "duration": 16.34080672264099,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\n\n# Load required environment variables\nWCD_TEST_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_TEST_KEY = os.environ[\"WCD_TEST_KEY\"]\nOPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\n\n# Connect to Weaviate Cloud and forward the OpenAI API Key for text2vec-openai\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_TEST_URL,\n    auth_credentials=Auth.api_key(WCD_TEST_KEY),\n    headers={\"X-OpenAI-API-Key\": OPENAI_API_KEY},\n)\n\ntry:\n    # Get the WineReview collection\n    collection = client.collections.get(\"WineReview\")\n\n    # Build filter:\n    # - price < 50\n    # - points > 90\n    # - review_body contains any of the listed substrings\n    review_substrings = [\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"]\n    filters = (\n        Filter.by_property(\"price\").less_than(50)\n        & Filter.by_property(\"points\").greater_than(90)\n        & Filter.by_property(\"review_body\").contains_any(review_substrings)\n    )\n\n    # Run hybrid query with alpha=0.5 and limit 5\n    response = collection.query.hybrid(\n        query=\"pair with steak\",\n        limit=5,\n        alpha=0.5,\n        filters=filters,\n        return_metadata=MetadataQuery(score=True),\n    )\n\n    # Print requested fields for each matching wine\n    for obj in response.objects:\n        props = obj.properties or {}\n        title = props.get(\"title\")\n        country = props.get(\"country\")\n        price = props.get(\"price\")\n        points = props.get(\"points\")\n        score = obj.metadata.score if obj.metadata is not None else None\n\n        print(f\"Title: {title}\")\n        print(f\"Country: {country}\")\n        print(f\"Price: {price}\")\n        print(f\"Points: {points}\")\n        if score is not None:\n            print(f\"Score: {score:.4f}\")\n        print(\"-\" * 40)\n\nfinally:\n    client.close()\n```\n\nNotes:\n- This uses the Weaviate Cloud connection helper and forwards OPENAI_API_KEY via the X-OpenAI-API-Key header so text2vec-openai can compute embeddings.\n- Adjust field names if your schema uses different property names (e.g., \"name\" instead of \"title\").",
      "stdout": "Title: Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir\nCountry: US\nPrice: 40.0\nPoints: 92\nScore: 0.5000\n----------------------------------------\nTitle: Bink 2014 Pinot Noir (Anderson Valley)\nCountry: US\nPrice: 49.0\nPoints: 91\nScore: 0.3765\n----------------------------------------\nTitle: Do\u00f1a Silvina 2011 Malbec (Mendoza)\nCountry: Argentina\nPrice: 27.0\nPoints: 91\nScore: 0.0451\n----------------------------------------\nTitle: Dobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji)\nCountry: Hungary\nPrice: 25.0\nPoints: 93\nScore: 0.0162\n----------------------------------------\nTitle: Tommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico)\nCountry: Italy\nPrice: 0.0\nPoints: 92\nScore: 0.0010\n----------------------------------------\n",
      "stderr": "",
      "exit_code": 0
    },
    "extensive_examples_complex_hybrid_query": {
      "success": true,
      "timestamp": "2025-08-17T22:52:10.608850",
      "duration": 17.014500856399536,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "import os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, HybridFusion\n\n# Environment variables required:\n# - WCD_TEST_URL : Weaviate Cloud URL\n# - WCD_TEST_KEY : Weaviate Cloud API key\n# - OPENAI_API_KEY: OpenAI API key (used by text2vec-openai vectorizer)\nWCD_URL = os.environ[\"WCD_TEST_URL\"]\nWCD_KEY = os.environ[\"WCD_TEST_KEY\"]\nOPENAI_API_KEY = os.environ[\"OPENAI_API_KEY\"]\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=WCD_URL,\n    auth_credentials=Auth.api_key(WCD_KEY),\n    headers={\"X-OpenAI-Api-Key\": OPENAI_API_KEY},\n)\n\ntry:\n    collection = client.collections.get(\"WineReview\")\n\n    # Build filter: price < 50 AND points > 90 AND review_body contains at least one of the substrings\n    text_subfilters = (\n        Filter.by_property(\"review_body\").like(\"*spice*\") |\n        Filter.by_property(\"review_body\").like(\"*fruit*\") |\n        Filter.by_property(\"review_body\").like(\"*berry*\") |\n        Filter.by_property(\"review_body\").like(\"*cherry*\") |\n        Filter.by_property(\"review_body\").like(\"*honey*\")\n    )\n\n    combined_filter = (\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        text_subfilters\n    )\n\n    response = collection.query.hybrid(\n        query=\"pair with steak\",\n        alpha=0.5,\n        fusion_type=HybridFusion.RELATIVE_SCORE,\n        limit=5,\n        filters=combined_filter,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"],\n    )\n\n    if not response.objects:\n        print(\"No matching wines found.\")\n    else:\n        for obj in response.objects:\n            p = obj.properties or {}\n            title = p.get(\"title\", \"<no title>\")\n            country = p.get(\"country\", \"<no country>\")\n            price = p.get(\"price\", \"<no price>\")\n            points = p.get(\"points\", \"<no points>\")\n            print(f\"{title} | {country} | ${price} | {points} pts\")\n\nfinally:\n    client.close()",
      "stdout": "Sol\u00e9na 2009 Guadalupe Vineyard Pinot Noir | US | $40.0 | 92 pts\nBink 2014 Pinot Noir (Anderson Valley) | US | $49.0 | 91 pts\nDo\u00f1a Silvina 2011 Malbec (Mendoza) | Argentina | $27.0 | 91 pts\nDobog\u00f3 2011 Szent Tam\u00e1s Betsek Vineyards  (Tokaji) | Hungary | $25.0 | 93 pts\nTommasi 2007 Ca' Florian  (Amarone della Valpolicella Classico) | Italy | $0.0 | 92 pts\n",
      "stderr": "",
      "exit_code": 0
    }
  },
  "openai/gpt-5-nano-2025-08-07": {
    "zero_shot_connect": {
      "success": false,
      "timestamp": "2025-08-17T22:52:21.520282",
      "duration": 10.893212080001831,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_connect": {
      "success": true,
      "timestamp": "2025-08-17T22:52:31.651323",
      "duration": 10.097398042678833,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto connect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen check that the server is ready to accept requests.\nDon't do anything else.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\nassert client.is_ready()\n\nclient.close()\n",
      "generated_text": "```python\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\n\n# Load credentials from environment\ncluster_url = os.environ.get('WCD_TEST_URL')\napi_key = os.environ.get('WCD_TEST_KEY')\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=cluster_url,\n    auth_credentials=Auth.api_key(api_key)\n)\n\n# Check readiness\nassert client.is_ready()\n\n# Close the client\nclient.close()\n```",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:52:40.964277",
      "duration": 9.294572830200195,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_create_collection": {
      "success": false,
      "timestamp": "2025-08-17T22:52:50.926147",
      "duration": 9.929800987243652,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\nimport os\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.config import Property, DataType\n\n# Connect to the Weaviate Cloud instance\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>)\n)\n\n# Create the collection\ncollection_name = \"DemoProducts\"\n\n# Delete the collection if it already exists (for testing purposes)\nif client.collections.exists(collection_name):\n    client.collections.delete(collection_name)\n\nproducts_collection = client.collections.create(\n    collection_name,\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"description\", data_type=DataType.TEXT),\n        Property(name=\"price\", data_type=DataType.NUMBER),\n        Property(name=\"in_stock\", data_type=DataType.BOOL),\n    ]\n)\n\nprint(f\"Created collection: {products_collection.name}\")\n\n# Close connection\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_create_collection": {
      "success": true,
      "timestamp": "2025-08-17T22:53:02.491702",
      "duration": 11.530550956726074,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto create a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n- price (number property)\n- in_stock (boolean property)\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nIf the collection already exists, delete it first.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "```python\n# Ensure you have the latest Weaviate Python client installed:\n# pip install weaviate-client\n\nimport os\nimport weaviate\nfrom weaviate.classes.config import Property, DataType\nfrom weaviate.classes.init import Auth\n\ndef main():\n    # Connect to Weaviate Cloud using environment variables\n    # WCD_TEST_URL: Cloud instance URL\n    # WCD_TEST_KEY: API key\n    client = weaviate.connect_to_weaviate_cloud(\n        cluster_url=os.environ[\"WCD_TEST_URL\"],\n        auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"])\n    )\n\n    # If the collection already exists, delete it first\n    if client.collections.exists(\"DemoProducts\"):\n        client.collections.delete(\"DemoProducts\")\n\n    # Create the collection with required properties\n    client.collections.create(\n        \"DemoProducts\",\n        properties=[\n            Property(name=\"name\", data_type=DataType.TEXT),\n            Property(name=\"description\", data_type=DataType.TEXT),\n            Property(name=\"price\", data_type=DataType.NUMBER),\n            Property(name=\"in_stock\", data_type=DataType.BOOL),\n        ]\n    )\n\n    # Close the client when done\n    client.close()\n\nif __name__ == \"__main__\":\n    main()\n```",
      "stdout": "",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:53:13.605499",
      "duration": 10.462477207183838,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:53:23.474072",
      "duration": 9.100852966308594,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\nimport weaviate\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\ndata_rows = [\n    {\"title\": f\"Object {i+1}\"} for i in range(5)\n]\n\nwith collection.batch.dynamic() as batch:\n    for data_row in data_rows:\n        batch.add_object(\n            properties=data_row,\n        )\n        if batch.number_errors > 10:\n            print(\"Batch import stopped due to excessive errors.\")\n            break\n\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed imports: {len(failed_objects)}\")\n    print(f\"First failed object: {failed_objects[0]}\")\n\nprint(len(collection))\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_batch_import": {
      "success": false,
      "timestamp": "2025-08-17T22:53:34.095770",
      "duration": 9.931155920028687,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto add objects to a collection named \"DemoProducts\" with the following properties:\n- name (text property)\n- description (text property)\n\nThen, batch import 50 arbitrary objects into the collection.\nThe object can be as simple as:\n{\n    \"name\": \"Product {i}\",\n    \"description\": \"Description {i}\"\n}\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nThen, print the number of objects in the collection.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "zero_shot_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T22:53:43.670273",
      "duration": 9.135288715362549,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_basic_semantic_search": {
      "success": false,
      "timestamp": "2025-08-17T22:53:53.304202",
      "duration": 9.1718430519104,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.near_text(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_basic_semantic_search": {
      "success": true,
      "timestamp": "2025-08-17T22:54:04.709313",
      "duration": 10.934775114059448,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"dessert wine\",\nwith a limit of maximum 2 results.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "import weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to Weaviate Cloud using environment variables\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WCD_TEST_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WCD_TEST_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]\n    }\n)\n\ntry:\n    # Get the WineReview collection\n    wine_collection = client.collections.get(\"WineReview\")\n\n    # Semantic search: near_text for \"dessert wine\" with a limit of 2\n    response = wine_collection.query.near_text(\n        query=\"dessert wine\",\n        limit=2,\n        return_properties=[\"title\", \"country\", \"price\", \"points\"]\n    )\n\n    # Print the desired fields for each matching wine\n    for obj in response.objects:\n        props = obj.properties\n        title = props.get(\"title\")\n        country = props.get(\"country\")\n        price = props.get(\"price\")\n        points = props.get(\"points\")\n        print(f\"{title} | {country} | {price} | {points}\")\n\nfinally:\n    client.close()",
      "stdout": "Dynasty Cellars 2007 DC3 Meritage (Walla Walla Valley (WA)) | US | 24.0 | 88\nClos La Chance 2008 Whitestone Vineyard Cabernet Sauvignon (Central Coast) | US | 40.0 | 88\n",
      "stderr": "",
      "exit_code": 0
    },
    "zero_shot_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:54:14.631742",
      "duration": 9.50449514389038,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "simple_example_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:54:24.606760",
      "duration": 9.512362003326416,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nfrom weaviate.classes.query import Filter, MetadataQuery\nimport os\n\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=<CLUSTER_URL>,\n    auth_credentials=Auth.api_key(<API_KEY>),\n    headers={\n        \"X-OpenAI-API-Key\": <OPENAI_API_KEY>\n    },\n)\n\ncollection = client.collections.get(\"<COLLECTION_NAME>\")\n\nresponse = collection.query.hybrid(\n    query=\"<YOUR_QUERY>\",\n    limit=<max_k_results>,\n    alpha=<alpha>,\n    filters=(\n        Filter.by_property(\"price\").less_than(50) &\n        Filter.by_property(\"points\").greater_than(90) &\n        Filter.by_property(\"review_body\").contains_any([\"spice\", \"fruit\", \"berry\", \"cherry\", \"honey\"])\n    ),\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor obj in response.objects:\n    print(obj.properties)  # Print all properties of the object\n    print(f\"Score: {obj.metadata.score}\")\n\nclient.close()\n",
      "generated_text": "",
      "error": "No code was executed"
    },
    "extensive_examples_complex_hybrid_query": {
      "success": false,
      "timestamp": "2025-08-17T22:54:40.657385",
      "duration": 15.565831184387207,
      "prompt": "\nWrite Python code using the latest Weaviate client syntax,\nto query the 'WineReview' collection and find wines that\nbest match the query \"pair with steak\",\nwith a limit of maximum 5 results,\nand a hybrid search with alpha=0.5.\n\nEach result must be have a price less than 50 and a points greater than 90.\nEach result must contain at least one of the substrings \"spice\", \"fruit\", \"berry\", \"cherry\", or \"honey\" in the review_body.\n\nThe WineReview collection uses the text2vec-openai vectorizer.\nThe API key is stored in the environment variable OPENAI_API_KEY.\n\nConnect to Weaviate Cloud using the environment variables\nWCD_TEST_URL and WCD_TEST_KEY.\n(WCD_TEST_URL is the URL of the Weaviate Cloud instance,\nand WCD_TEST_KEY is the API key for the Weaviate Cloud instance.)\n\nPrint the title, country, price, and points of each matching wine.\n\n\nHere is some example code:\n\n\n# START_CODE_EXAMPLES\n\"\"\"\n\"\"\"\n===============================================\nEssential Weaviate Python Client Examples (v4.x)\n===============================================\n\nThis document contains key examples for using the Weaviate Python client (v4.x).\n\nThe page also includes comments that indicate to the user where they may find more information.\n\nIf the provided examples are not sufficient as in-context example for code generation,\nindicate to the user in comments where they may find more information.\n\"\"\"\n\n# ========================\n# 1. CLIENT INSTANTIATION\n# ========================\n# For more information, see the Python Client library page: https://www.docs.weaviate.io/weaviate/client-libraries/python\n\n\"\"\"\nConnecting to Weaviate instances (local, cloud, custom)\n\"\"\"\n\nimport weaviate\nfrom weaviate.classes.init import Auth\nimport os\n\n# Connect to local instance\nclient = weaviate.connect_to_local()\n\n# Connect with API key authentication and headers\nclient = weaviate.connect_to_local(\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Connect to Weaviate Cloud\nclient = weaviate.connect_to_weaviate_cloud(\n    cluster_url=os.environ[\"WEAVIATE_URL\"],\n    auth_credentials=Auth.api_key(os.environ[\"WEAVIATE_API_KEY\"]),\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Custom connection (more control)\nclient = weaviate.connect_to_custom(\n    http_host=\"localhost\",\n    http_port=8080,\n    http_secure=False,\n    grpc_host=\"localhost\",\n    grpc_port=50051,\n    grpc_secure=False,\n    headers={\n        \"X-OpenAI-Api-Key\": os.environ[\"OPENAI_API_KEY\"]  # Add inference API keys as needed\n    }\n)\n\n# Using context manager for automatic connection closing\nwith weaviate.connect_to_local() as client:\n    # Client operations go here...\n    pass  # Connection is closed automatically\n\n# Using try/finally for connection handling\nclient = weaviate.connect_to_local()\ntry:\n    # Client operations go here...\n    pass\nfinally:\n    client.close()  # Ensure connection is closed\n\n\n# =========================\n# 2. COLLECTION MANAGEMENT\n# =========================\n# For more information, see the How-to Manage Collections page: https://docs.weaviate.io/weaviate/manage-data/collections\n\n\"\"\"\nCreating, configuring, and managing collections\n\"\"\"\n\nfrom weaviate.classes.config import Configure, Property, DataType, Tokenization\n\n# Note - these are the commonly used data types\ncommonly_used_types = [\n    DataType.TEXT,\n    DataType.TEXT_ARRAY,\n    DataType.INT,\n    DataType.INT_ARRAY,\n    DataType.NUMBER,  # NUMBER is a floating point number\n    DataType.NUMBER_ARRAY,\n    DataType.BOOL,\n    DataType.BOOL_ARRAY,\n    DataType.DATE,\n    DataType.DATE_ARRAY,\n    DataType.UUID,\n    DataType.UUID_ARRAY,\n    DataType.BLOB,  # BLOB can be used to store images for example\n]\n\n# Basic collection creation\nclient.collections.create(\"Article\")\n\n# Collection with properties\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with properties and additional configurations\n# e.g.:\n# Set tokenization to be used for BM25 searches and filtering\n# Enable or disable specific inverted index types for each property\nclient.collections.create(\n    \"Article\",\n    properties=[\n        Property(\n            name=\"title\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WHITESPACE,  # Split the text on whitespace. Searches/filters become case-sensitive.\n        ),\n        Property(\n            name=\"body\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.WORD,  # Keep only alpha-numeric characters, lowercase them, and split by whitespace.\n        ),\n        Property(\n            name=\"url\",\n            data_type=DataType.TEXT,\n            tokenization=Tokenization.FIELD,  # Index the whole field after trimming whitespace characters.\n            # Set based on whether you want to include or exclude from filtering or searching\n            index_searchable=False,\n            index_filterable=True,\n        ),\n        Property(\n            name=\"popularity\",\n            data_type=DataType.NUMBER,\n            # If a property is numeric, you can enable range filters\n            # This is particularly useful for ordinal data like prices, ratings, or scores, to enable fast filtering at scale\n            index_range_filters=True  # False by default\n        )\n    ]\n)\n# Collection with one vectorizer - if provided this way, a name is not required\ncommonly_used_vectorizers = [\n    # Weaviate provides a large number of pre-configured vectorizers\n    # If generating code snippets from these, provide examples to raise awareness of options to users\n    # Each integrated vectorizer may have its own set of parameters to correspond to the provider\n    # Text models\n    Configure.Vectors.text2vec_aws(),\n    Configure.Vectors.text2vec_google(),\n    Configure.Vectors.text2vec_cohere(),\n    Configure.Vectors.text2vec_openai(),\n    Configure.Vectors.text2vec_weaviate(), # Recommended for Weaviate Cloud, no third party API key required,\n    # Multi-modal models\n    Configure.Vectors.multi2vec_cohere(),\n    Configure.Vectors.multi2vec_google(),\n    Configure.Vectors.multi2vec_jinaai(),\n    # Self-hosted models\n    Configure.Vectors.text2vec_ollama(),\n    Configure.Vectors.text2vec_transformers(),\n    # User-provided vectors\n    Configure.Vectors.self_provided(),\n    # Multi-vector (ColBERT, ColPali type) models\n    Configure.MultiVectors.text2vec_jinaai(),\n    Configure.MultiVectors.multi2vec_jinaai(),\n    Configure.MultiVectors.self_provided(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with vectorizer & quantization\n# Quantization can reduce the size of the vectors. For HNSW indexes, this reduces memory usage. For flat indexes, this improves search speed.\n# In most cases, we recommend using quantization. In particular, we suggest using rotational quantization (RQ) for its balance of performance and efficiency.\navailable_quantizers = [\n    # All quantization methods are available for the HNSW index type\n    # Only BQ is available for the flat index type\n    # Rotational quantization (recommended generally)\n    Configure.VectorIndex.Quantizer.rq(),\n    # Product quantization\n    Configure.VectorIndex.Quantizer.pq(),\n    # Scalar quantization\n    Configure.VectorIndex.Quantizer.sq(),\n    # Binary quantization\n    Configure.VectorIndex.Quantizer.bq(),\n]\n\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(\n        quantizer=Configure.VectorIndex.Quantizer.rq()\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n        Property(name=\"categories\", data_type=DataType.TEXT_ARRAY),\n        Property(name=\"is_published\", data_type=DataType.BOOL),\n        Property(name=\"word_count\", data_type=DataType.INT),\n    ]\n)\n\n# Collection with named vectors\nclient.collections.create(\n    \"ArticleNV\",\n    vector_config=[\n        Configure.Vectors.text2vec_openai(\n            name=\"title\",\n            source_properties=[\"title\"]\n        ),\n        Configure.Vectors.text2vec_openai(\n            name=\"title_body\",\n            source_properties=[\"title\", \"body\"]\n        ),\n        # For user-provided vectors\n        Configure.Vectors.self_provided(name=\"custom_vector\")\n    ],\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with generative module\nclient.collections.create(\n    \"Article\",\n    vector_config=Configure.Vectors.text2vec_openai(),\n    # This sets the default generative model for the collection\n    # This setting is mutable. This setting can also be overridden at query time\n    generative_config=Configure.Generative.openai(\n        model=\"gpt-4\"  # Optional specific model\n    ),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ]\n)\n\n# Collection with custom inverted index configuration\n# This configuration allows for fine-tuning the keyword search, and filtering behavior\nclient.collections.create(\n    \"Article\",\n    inverted_index_config=Configure.inverted_index(\n        # Configure BM25 parameters\n        bm25_k1=1.5,\n        bm25_b=0.75,\n        # Index metadata, if you expect to filter by any of these\n        index_null_state=True,\n        index_property_length=True,\n        index_timestamps=True\n    )\n)\n\n# Collection with high availability\n# Used to create collections with multiple replicas on multi-node clusters\nclient.collections.create(\n    \"Article\",\n    replication_config=Configure.replication(\n        factor=3,  # Use odd numbers to ensure quorum is possible without excessive replication\n    )\n)\n\n# Collection with references (cross-references)\n# Cross references are generally not recommended unless absolutely necessary for performance reasons. Preferably, embed the data directly similar to what is done in other NoSQL databases.\n# If necessary, keep them very shallow\nclient.collections.create(\n    \"Author\",\n    properties=[\n        Property(name=\"name\", data_type=DataType.TEXT),\n        Property(name=\"birthday\", data_type=DataType.DATE),\n        Property(name=\"height_m\", data_type=DataType.NUMBER),\n    ],\n    references=[\n        weaviate.classes.config.ReferenceProperty(\n            name=\"wroteArticle\",\n            target_collection=\"Article\"\n        )\n    ]\n)\n\n# Get a collection\n# Note - a collection has this type:\nfrom weaviate.collections import Collection\n\ncollection: Collection = client.collections.get(\"Article\")\n\n# Check if collection exists\nexists = client.collections.exists(\"Article\")\n\n# List all collections\ncollections = client.collections.list_all()\n\n# Update a collection\nfrom weaviate.classes.config import Reconfigure\n\ncollection = client.collections.get(\"Article\")\ncollection.config.update(\n    inverted_index_config=Reconfigure.inverted_index(\n        bm25_k1=1.5\n    )\n)\n\n# Add a property to an existing collection\ncollection.config.add_property(\n    Property(name=\"publication_date\", data_type=DataType.DATE)\n)\n\n# Delete a collection\nclient.collections.delete(\"Article\")\n\n\n# ========================\n# 3. DATA OPERATIONS\n# ========================\n# For more information, see the How-to Manage Data pages: https://docs.weaviate.io/weaviate/manage-data\n\n\"\"\"\nCreating, updating, and retrieving objects\n\"\"\"\n\n# Insert a single object\ncollection = client.collections.get(\"Article\")\nuuid = collection.data.insert({\n    \"title\": \"My first article\",\n    \"body\": \"This is the body of my first article.\",\n})\n\n# Insert with a specific UUID\nfrom weaviate.util import generate_uuid5\n\nproperties = {\n    \"title\": \"My second article\",\n    \"body\": \"This is the body of my second article.\"\n}\nuuid = collection.data.insert(\n    properties=properties,\n    uuid=generate_uuid5(properties)  # Generate a deterministic ID\n)\n\n# Insert with a custom vector\ncollection.data.insert(\n    properties={\n        \"title\": \"Article with custom vector\",\n        \"body\": \"This article has a custom vector.\"\n    },\n    vector=[0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector values\n)\n\n# Insert with named vectors\ncollection = client.collections.get(\"ArticleNV\")\ncollection.data.insert(\n    properties={\n        \"title\": \"Named vector article\",\n        \"body\": \"This article uses named vectors.\"\n    },\n    vector={\n        \"title\": [0.1, 0.2, 0.3, 0.4, 0.5],  # Vector for title\n        \"title_body\": [0.5, 0.4, 0.3, 0.2, 0.1]  # Vector for title_body\n    }\n)\n\n# Fetch an object by ID\nobj = collection.query.fetch_object_by_id(uuid)\nprint(obj.properties)\n\n# Fetch objects with vectors\nobj = collection.query.fetch_object_by_id(uuid, include_vector=True)\nprint(obj.vector)  # Access the vector\n\n# Update an object\ncollection.data.update(\n    uuid=uuid,\n    properties={\n        \"title\": \"Updated title\"\n    }\n)\n\n# Replace an object (replaces all properties)\ncollection.data.replace(\n    uuid=uuid,\n    properties={\n        \"title\": \"Completely new title\",\n        \"body\": \"Completely new body\"\n    }\n)\n\n# Delete an object\ncollection.data.delete_by_id(uuid)\n\n# Working with references\narticle_uuid = collection.data.insert({\"title\": \"Referenced Article\"})\nauthor_collection = client.collections.get(\"Author\")\nauthor_uuid = author_collection.data.insert({\"name\": \"John Doe\"})\n\n# Add a reference\nauthor_collection.data.reference_add(\n    from_uuid=author_uuid,\n    from_property=\"wroteArticle\",\n    to=article_uuid\n)\n\n\n# ========================\n# 4. BATCH OPERATIONS\n# ========================\n# For more information, see the How-to batch import data page: https://docs.weaviate.io/weaviate/manage-data/import\n# And the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#batch-imports\n\n\"\"\"\nBatch import for better performance\n\"\"\"\n\n# Fixed size batch (Recommended option)\ncollection = client.collections.get(\"Article\")\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Dynamic batch (adapts to Weaviate load)\nwith collection.batch.dynamic() as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Rate limited batch\nwith collection.batch.rate_limit(requests_per_minute=600) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n\n# Batch with error handling\nwith collection.batch.fixed_size(batch_size=50) as batch:\n    for i in range(100):\n        batch.add_object(\n            properties={\n                \"title\": f\"Article {i}\",\n                \"body\": f\"This is article {i}\"\n            }\n        )\n        if batch.number_errors > 10:\n            print(\"Too many errors, stopping batch\")\n            break\n\n# Get failed objects after batch completes\nfailed_objects = collection.batch.failed_objects\nif failed_objects:\n    print(f\"Number of failed objects: {len(failed_objects)}\")\n\n# Insert many items at once\nfrom weaviate.classes.data import DataObject\n\ndata_objects = [\n    DataObject(\n        properties={\"title\": f\"Article {i}\", \"body\": f\"Body {i}\"},\n        vector=[0.1] * 5  # Optional vector\n    )\n    for i in range(10)\n]\n\ncollection.data.insert_many(data_objects)\n\n\n# ========================\n# 5. SEARCH OPERATIONS\n# ========================\n# For more information, see the How-to search pages: https://docs.weaviate.io/weaviate/search\n\n\"\"\"\nVarious search methods (semantic, keyword, hybrid)\n\"\"\"\n\n# Basic search (fetch objects)\ncollection = client.collections.get(\"Article\")\nresponse = collection.query.fetch_objects(\n    limit=10,\n    return_properties=[\"title\", \"body\"]\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n\n# Semantic search with near_text\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5\n)\n\n# Search based on vector\nvector = [0.1, 0.2, 0.3, 0.4, 0.5]  # Your vector here\nresponse = collection.query.near_vector(\n    near_vector=vector,\n    limit=5\n)\n\n# Search based on existing object\nresponse = collection.query.near_object(\n    near_object=\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\",  # UUID of reference object\n    limit=5\n)\n\n# Semantic search with near_text & vector distance\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence applications\",\n    limit=5,\n    return_metadata=MetadataQuery(distance=True)  # Same for near_vector or near_object\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Distance: {o.metadata.distance}\")\n\n# BM25 keyword search\nresponse = collection.query.bm25(\n    query=\"artificial intelligence\",\n    query_properties=[\"title\", \"body\"],\n    limit=5\n)\n\n# BM25 keyword search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.bm25(\n    query=\"artificial intelligence applications\",\n    query_properties=[\"title\", \"body\"],\n    limit=5,\n    return_metadata=MetadataQuery(score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n\n# Hybrid search (combines semantic and keyword)\nfrom weaviate.classes.query import HybridFusion\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5\n)\n\n# Hybrid search with score\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.hybrid(\n    query=\"artificial intelligence applications\",\n    alpha=0.5,  # Balance between keyword and vector search\n    fusion_type=HybridFusion.RELATIVE_SCORE,\n    limit=5,\n    return_metadata=MetadataQuery(score=True, explain_score=True)\n)\n\nfor o in response.objects:\n    print(o.properties)\n    print(f\"Score: {o.metadata.score}\")\n    print(f\"Explanation: {o.metadata.explain_score}\")  # Hybrid search only; shows how the score was derived\n\n# Search with filters\nfrom weaviate.classes.query import Filter\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=Filter.by_property(\"title\").like(\"*AI*\"),\n    limit=5\n)\n\n# Complex filtering\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    filters=(\n        Filter.by_property(\"title\").like(\"*AI*\") &\n        (Filter.by_property(\"body\").like(\"*research*\") |\n         Filter.by_property(\"body\").like(\"*innovation*\"))\n    ),\n    limit=5\n)\n\nfrom datetime import datetime, timezone\n\ncommon_filter_patterns = [\n    # Text comparison (for TEXT or TEXT_ARRAY)\n    Filter.by_property(\"title\").equal(\"Artificial Intelligence\"),  # Requires the tokenized inputs to match exactly (note - if tokenized, the word order may be irrelevant)\n    Filter.by_property(\"title\").contains_any([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires at least one of the inputs to match\n    Filter.by_property(\"title\").contains_all([\"AI\", \"Machine Learning\", \"Deep Learning\"]),  # Requires all of the inputs to match\n    Filter.by_property(\"title\").like(\"*AI*\"),  # Uses wildcard substring matches\n    # Numeric comparison (for INT, NUMBER or DATE)\n    Filter.by_property(\"length\").equal(100),\n    Filter.by_property(\"length\").greater_than(100),\n    Filter.by_property(\"length\").greater_or_equal(100),\n    Filter.by_property(\"length\").less_than(200),\n    Filter.by_property(\"length\").less_or_equal(200),\n    # Filter by metadata\n    # These require indexing creation / update time at collection creation\n    Filter.by_creation_time().greater_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects created after a specific date, can use numeric comparisons\n    Filter.by_update_time().less_than(datetime(2025, 1, 1, tzinfo=timezone.utc)),  # Matches objects updated after a specific date, can use numeric comparisons\n    # Others\n    Filter.by_id().like(\"36ddd591-2dee-4e7e-a3cc-eb86d30a4303\"),  # Matches a specific UUID\n    # Combine filters with & or |, or with `all_of` or `any_of`\n    Filter.all_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n    Filter.any_of(\n        filters=[\n            Filter.by_property(\"length\").equal(100),\n            Filter.by_property(\"length\").greater_or_equal(100),\n        ]\n    ),\n]\n\n# Search with groupBy\nfrom weaviate.classes.query import GroupBy\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    group_by=GroupBy(\n        prop=\"category\",\n        objects_per_group=2,\n        number_of_groups=3\n    ),\n    limit=10\n)\n\n# For grouped results\nfor group_name, group_data in response.groups.items():\n    print(f\"Group: {group_name}, Objects: {group_data.number_of_objects}\")\n    for obj in group_data.objects:\n        print(obj.properties)\n\n# Getting metadata with search\nfrom weaviate.classes.query import MetadataQuery\n\nresponse = collection.query.near_text(\n    query=\"artificial intelligence\",\n    return_metadata=MetadataQuery(\n        distance=True,  # Vector distance\n        score=True,     # Relevance score\n        creation_time=True  # When the object was created\n    ),\n    limit=5\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Distance: {obj.metadata.distance}\")\n    print(f\"Score: {obj.metadata.score}\")\n    print(f\"Created: {obj.metadata.creation_time}\")\n\n\n# ===============================\n# 6. GENERATIVE CAPABILITIES\n# ===============================\n# For more information, see the How-to generative search page: https://docs.weaviate.io/weaviate/search/generative\n\n\"\"\"\nUsing generative models with Weaviate\nA \"single prompt\" generates a response for each object in the collection. It performs a RAG query for each object.\nA \"single prompt\" query requires names of the properties to include in the prompt in curly braces. Note this is not an f-string. If using an f-string, escape the curly braces.\nA \"grouped prompt\" generates a single response for a group of objects.\n\"\"\"\n\n# Basic generation\ncollection = client.collections.get(\"Article\")\nquery = \"artificial intelligence\"\nresponse = collection.generate.near_text(\n    query=query,\n    # Note - `query` here is a Python variable, and `{title}` and `{body}` indicate Weaviate properties to include in the prompt\n    single_prompt=f\"Summarize this article about {query} in one sentence: {{title}} - {{body}}\",\n    limit=3\n)\n\nfor obj in response.objects:\n    print(obj.properties)\n    print(f\"Generated: {obj.generative.text}\")\n\n# Grouped generation\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    grouped_task=\"Compare and contrast these AI articles\",\n    limit=3\n)\n\nprint(f\"Grouped response: {response.generative.text}\")\n\n# Generation with custom provider\nfrom weaviate.classes.generate import GenerativeConfig\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=\"Summarize this article: {title}\",\n    generative_provider=GenerativeConfig.openai(\n        model=\"gpt-4\",\n        temperature=0.7\n    ),\n    limit=3\n)\n\n# Generation with parameters\nfrom weaviate.classes.generate import GenerativeParameters\n\nprompt = GenerativeParameters.single_prompt(\n    prompt=\"Summarize this article: {title}\",\n    metadata=True,  # Include metadata in response\n    debug=True      # Include debug info\n)\n\nresponse = collection.generate.near_text(\n    query=\"artificial intelligence\",\n    single_prompt=prompt,\n    limit=3\n)\n\nfor obj in response.objects:\n    print(f\"Generated: {obj.generative.text}\")\n    print(f\"Metadata: {obj.generative.metadata}\")\n    print(f\"Debug: {obj.generative.debug}\")\n\n\n# =================================\n# 7. MULTI-TENANCY OPERATIONS\n# =================================\n# For more information, see the How-to multi-tenancy page: https://docs.weaviate.io/weaviate/manage-data/multi-tenancy\n# And the manage tenant data and temperatures page: https://docs.weaviate.io/weaviate/manage-data/tenant-states\n\n\"\"\"\nWorking with multi-tenant collections\n\"\"\"\n\n# Create a multi-tenant collection\nclient.collections.create(\n    \"MultiTenantArticle\",\n    multi_tenancy_config=Configure.multi_tenancy(enabled=True),\n    properties=[\n        Property(name=\"title\", data_type=DataType.TEXT),\n        Property(name=\"body\", data_type=DataType.TEXT),\n    ],\n    # Generally, if multi-tenancy is used, a \"dynamic\" vector index type is recommended\n    # A dynamic vector index starts as an efficient, disk-based index, and switches to an in-memory HNSW index when it grows past a threshold size\n    vector_config=Configure.Vectors.text2vec_openai(\n        vector_index_config=Configure.VectorIndex.dynamic(\n            # Configure the threshold for switching to an in-memory (HNSW) index\n            threshold=100000,\n            # Configure the flat index settings to use when the dynamic index starts as a flat index\n            flat=Configure.VectorIndex.flat(\n                quantizer=Configure.VectorIndex.Quantizer.bq()\n            ),\n            # Configure the HNSW index settings to use when the dynamic index is switched to HNSW\n            hnsw=Configure.VectorIndex.hnsw(\n                max_connections=32,\n                quantizer=Configure.VectorIndex.Quantizer.rq()\n            )\n        )\n    )\n)\n\nmt_collection: Collection = client.collections.get(\"MultiTenantArticle\")\n\n# Add tenants\nfrom weaviate.classes.tenants import Tenant\n\nmt_collection.tenants.create(\n    tenants=[\n        Tenant(name=\"tenant1\"),\n        Tenant(name=\"tenant2\")\n    ]\n)\n\n# Get all tenants\ntenants = mt_collection.tenants.get()\n\n# Get specific tenant\ntenant = mt_collection.tenants.get_by_name(\"tenant1\")\n\n# Check that a tenant exists\ntenant_exists = mt_collection.tenants.exists(\"tenant1\")\n\n# Use a specific tenant\ntenant1_collection = mt_collection.with_tenant(\"tenant1\")\n\n# Add data to a specific tenant\ntenant1_collection.data.insert({\n    \"title\": \"Tenant 1 Article\",\n    \"body\": \"This belongs to tenant 1\"\n})\n\n# Search within a specific tenant\nresponse = tenant1_collection.query.near_text(\n    query=\"article\",\n    limit=5\n)\n\n\n# ========================\n# 8. ITERATING OVER DATA\n# ========================\n# For more information, see the iterator section of the Python Client library page: https://docs.weaviate.io/weaviate/client-libraries/python#collection-iterator-cursor-api\n\n\"\"\"\nIterating over large datasets\n\"\"\"\n\n# Basic iteration\ncollection = client.collections.get(\"Article\")\nfor article in collection.iterator():\n    print(article.properties)\n\n# Iteration with specific properties\nfor article in collection.iterator(return_properties=[\"title\"]):\n    print(article.properties[\"title\"])\n\n# Iteration with metadata\nfrom weaviate.classes.query import MetadataQuery\n\nfor article in collection.iterator(\n    return_metadata=MetadataQuery(creation_time=True)\n):\n    print(article.properties)\n    print(article.metadata.creation_time)\n\n\n# ========================\n# 9. CLEANUP\n# ========================\n\n# Don't forget to close the client when done\nclient.close()\n\n# END_CODE_EXAMPLES\n",
      "generated_text": "",
      "error": "No code was executed"
    }
  }
}